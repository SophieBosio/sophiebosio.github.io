[{"content":"One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.\nWe\u0026rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here\u0026rsquo;s how we approached it and some of my reflections when looking back at it.\nI\u0026rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it\u0026rsquo;s easier to see how monads work when seeing the implementation. The parser, on the other hand, uses the monad combinator library Parsec, which is both more complicated and more well-documented elsewhere.\nI\u0026rsquo;ll assume you\u0026rsquo;re familiar with monads and their operations, but this is also a great project to try your hand at if you\u0026rsquo;re still getting the hang of using them.\nThe code is available in its entirety on my GitHub, and I would encourage you to follow along!\nThe Boa Language The Boa language is a small subset of Python. It looks pretty familiar to anyone who has programmed in Python before, and if you\u0026rsquo;re interested in a more thorough explanation of the language, you can check out the ./docs folder in the repo.\nThe most important aspects of the language, for our interpreter, is that it has global state. In our purely functional implementation language, computations are normally not stateful. So, we have to make use of a monad to model the program environment and interpret terms with respect to the existing bindings.\nThankfully, Boa computations can make do with read-only access to the environment. Therefore, we can use a neat and (as far as monads go) pretty intuitive monad, namely the Reader monad. We\u0026rsquo;ll implement it ourselves, but you could also just import the above package in your project.\nSpoiler Alert! Syntax File Below, you can find the finished Syntax.hs file. If you want to implement the language yourself, you might want to try your hand at writing this file, too, before seeing this suggestion.\nSyntax.hs\rmodule Syntax where data Value = None | Boolean Bool | Number Integer | Text String | List [Value] deriving (Eq, Show, Read) data Expression = Constant Value | Variable VariableName | Operation OperationSymbol Expression Expression | Not Expression | Call FunctionName FunctionInput | ListExpression [Expression] | ListComprehension Expression [Clause] deriving (Eq, Show, Read) type VariableName = String type FunctionName = String type FunctionInput = [Expression] type FunctionArguments = [Value] data OperationSymbol = Plus | Minus | Times | Div | Mod | Eq | Less | Greater | In deriving (Eq, Show, Read) data Clause = For VariableName Expression | If Expression deriving (Eq, Show, Read) type Program = [Statement] data Statement = Define VariableName Expression | Execute Expression deriving (Eq, Show, Read) Monad Implementation Executing a Boa program means evaluating all the program statements, starting from the empty environment and populating it as we go. If we encounter any runtime errors underway, we\u0026rsquo;ll stop execution and print an error message. If all is well, we\u0026rsquo;ll continue until there are no more statements, and then print the output of the program.\nLet\u0026rsquo;s use the following abbreviations.\ntype Output = [String] type ErrorMessage = String data RuntimeError = UnboundVariable VariableName | BadFunction FunctionName | BadArgument ErrorMessage deriving (Eq, Show) type Environment = [(VariableName, Value)] type Runtime a = Environment -\u0026gt; (Either RuntimeError a, Output) An environment is a mapping from variable names to values. What we want is a monad that allows us to keep track of the variable bindings in the environment. When we want to perform a computation, we need a runtime where we can read from the environment and either raise a runtime error or return a value, and append the output from the computation so we can print it later. This is essentially what we would want to use the Reader monad for! Let\u0026rsquo;s implement a simple version.\nThe Boa Monad Every monad is an applicative functor and every applicative functor is a functor. Those are interesting to read about in their own right, but for now, we just need to know that if we implement the monad correctly, we get these two for free. For these freebies, we need to import Control.Monad. We\u0026rsquo;ll also need a newtype Boa a, whose \u0026ldquo;run\u0026rdquo; action will have the type Runtime a.\nimport Control.Monad newtype Boa a = Boa {run :: Runtime a} instance Functor Boa where fmap = liftM instace Applicative Boa where pure = return (\u0026lt;$\u0026gt;) = ap Nice! Now, we need to define two functions for our monad, namely return and \u0026gt;\u0026gt;=, and we have a fully fledged monad instance!\nFor a quick refresher, let\u0026rsquo;s look at their type signatures.\nreturn :: Monad m =\u0026gt; a -\u0026gt; m a (\u0026gt;\u0026gt;=) :: Monad m =\u0026gt; m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b In the case of return, we just want to take a value and put it inside the monad. What\u0026rsquo;s the simplest way we can do that? Well, our monad lets us read from the environment and we\u0026rsquo;re supposed to return either an error message or a value a, and then the output we want to print after the computation is done. The simplest way, then, is to not read anything from the environment, just put in the value, and not add anything to the output.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u0026gt;\u0026gt;= f = undefined Essentially, this says \u0026ldquo;I don\u0026rsquo;t care about the environment, just give me the tuple with a and no output in it, then put it all inside the Boa monad for me\u0026rdquo;. The following notation is semantically equivalent, but the syntax may be easier to read depending on what you\u0026rsquo;re used to.\nreturn a = Boa (\\_ -\u0026gt; (Right a, [])) Then what do we want to do for \u0026gt;\u0026gt;=, is define a way to take a value out of the monad, apply a function to it, and then put the result back into the monad. To unwrap the value a from ba, we can simply use our monad\u0026rsquo;s run function. We have to take in an environment so that we can run the monad in the environment and look at the result. If it\u0026rsquo;s an error, then we just return the error. But if we get a value a out and some output, then we want to run the function f on a. What we\u0026rsquo;re gonna return, is the result of f a and the output of that computation appended to all the previous output. Finally, we put it all back into the Boa monad.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u0026gt;\u0026gt;= f = Boa $ \\env -\u0026gt; case run ba env of (Left re, out) -\u0026gt; (Left re, out) -- just return the error (Right a, out) -\u0026gt; let (result, out\u0026#39;) = run (f a) env -- run f a in the environment in (result, out ++ out\u0026#39;) -- append the new output to the old Sweet! Now let\u0026rsquo;s define some operations that let us interact with the monad in a more ergonomic way.\nMonad Operations Now we have the monad itself, but it\u0026rsquo;s nice to abstract away some details and instead work with more intuitive function names. Let\u0026rsquo;s write some functions with more easily understood names.\nabort :: RuntimeError -\u0026gt; Boa a look :: VariableName -\u0026gt; Boa Value bind :: VariableName -\u0026gt; Value -\u0026gt; (Boa a -\u0026gt; Boa a) output :: String -\u0026gt; Boa () abort should just accept a runtime error and put it into the Boa monad.\nabort :: RuntimeError -\u0026gt; Boa a abort re = Boa $ const (Left re, []) -- or equivalently, abort re = Boa (\\_ -\u0026gt; (Left re, [])) look should accept a variable name and look to see if it is in the environment. if it is, return the value inside the monad. If it isn\u0026rsquo;t, return an \u0026ldquo;unbound variable\u0026rdquo; runtime error inside the monad. In either case, no output is necessary.\nlook :: VariableName -\u0026gt; Boa Value look x = Boa $ \\env -\u0026gt; case lookup x env of Just a -\u0026gt; (Right a, []) Nothing -\u0026gt; (Left (UnboundVariable x), []) bind takes a variable name and a value. What it should do, is run the monad with that name-value binding prepended to the old environment, and then put the value of that computation back into the monad. It needs to be prepended and not appended because when we perform a lookup, we want to find the most recent bindings first.\nbind :: VariableName -\u0026gt; Value -\u0026gt; (Boa a -\u0026gt; Boa a) bind x v ba = Boa $ \\env -\u0026gt; run ba $ (x,v) : env -- or equivalently, bind x v ba = Boa (\\env -\u0026gt; run ba ( [(x,v)] ++ env )) output should take an string and put it into the monad as output.\noutput :: String -\u0026gt; Boa () output s = Boa $ const (Right (), [s]) Interpreter Functions Finally, we need the main operations of the interpreter. To execute a Boa program, we want to take a program and return a tuple with the output of the program and possibly a runtime error.\nexecute :: Program -\u0026gt; (Output, Maybe Runtime Error) execute p = undefined Since a Program is made up of Define and Execute statements, we can write a helper function exec that pattern matches on the type of statement.\nexec :: Program -\u0026gt; Boa () exec [] = undefined exec ((Define x e) : s) = undefined exec ((Execute e) : s) = undefined And finally, we\u0026rsquo;ll need a helper function eval that\u0026rsquo;s responsible for evaluating a single expression and putting the resulting value into the Boa monad for us. This is what we\u0026rsquo;ll focus on for now.\neval :: Expression -\u0026gt; Boa Value Since they\u0026rsquo;re not the most interesting part of the interpreter, I\u0026rsquo;m omitting quite a few other helper functions, notably operate ::\rOperationSymbol -\u0026gt; Value -\u0026gt; Value -\u0026gt; Either ErrorMessage Value and apply ::\rFunctionName -\u0026gt; FunctionArguments -\u0026gt; Boa Value. They\u0026rsquo;re of course in the repo, and I\u0026rsquo;d encourage you to try implementing them yourself.\neval needs to pattern match on each expression. There are the following types of Expression:\nConstant Variable VariableName Not Expression Operation OperationSymbol Expression Expression Call FunctionName FunctionInput ListExpression [Expression] ListComprehension Expression [Clause] Constant Let\u0026rsquo;s start with Constant.\neval (Constant v) = return v It\u0026rsquo;s already a value, so we can just take it and put it directly in the monad. Easy!\nVariable What about a variable? Well, either it\u0026rsquo;s bound in the environment or it\u0026rsquo;s not and should return an error. look seems like a perfect fit for the job. It even returns an error message for us if x is not present in the environment.\neval (Variable x) = look x Not If we meet a Not expression, we should evaluate the sub-expression to a Boolean value, then take the opposite value, cast it as a Boolean and put it in the Boa monad. Actually, we can do all of this by fmap-ing (Boolean . not . truthy) onto the evaluated expression. That unwraps the expression, applies the three functions above, and then wraps it back up in the monad.\nNote that \u0026lt;$\u0026gt; is just an infix version of fmap, and truthy is a helper function that evaluates a Value to a Boolean value.\neval (Not e) = Boolean . not . truthy \u0026lt;$\u0026gt; eval e Operation An Operation is performed by evaluating each of its arguments, extracting the Value from each, using operate on them to get the result Value, and wrapping that result back in the monad. In this case, do-notation makes our code much more readable.\neval (Operation o e1 e2) = do v1 \u0026lt;- eval e1 v2 \u0026lt;- eval e2 case operate o v1 v2 of Right v -\u0026gt; return v Left re -\u0026gt; abort $ BadArgument re Call Recall that Call takes a function name f and a list of expressions es, which is the function input. What we want to do, is to evaluate all the function arguments, and then send all those values to our helper function apply, which will apply f to the evaluated es and put the result into the Boa monad.\nWith the help of mapM, we can write the function for Call expressions very succinctly. Its type signature is\nmapM :: (Traversable t, Monad m) ==\u0026gt; (a -\u0026gt; m b) -\u0026gt; t a -\u0026gt; m (t b).\nIn our case, the traversable structure is a list and the monad is the Boa monad. In our case, we can rewrite it as\nmapM :: (Expression -\u0026gt; Boa Value) -\u0026gt; [Expression] -\u0026gt; Boa ([Value]).\neval, of course has the type Expression -\u0026gt; Boa Value and the function input has type [Expression].\nGreat! So if we do mapM eval es, we\u0026rsquo;ll get a Boa [Value], where each Value is an evaluated function argument. Then we just want to take this list of values out of the monad and send it to the apply f function.\neval (Call f es) = mapM eval es \u0026gt;\u0026gt;= apply f List Expression We can do something similar for ListExpression, except this case is much easier! We want to evaluate all the expressions, as above, but then all we need is to put the results in a List and wrap it in the monad. Then we can just fmap List onto the evaluated expressions.\neval (ListExpression es) = List \u0026lt;$\u0026gt; mapM eval es List Comprehension Now, the ListComprehension is probably the trickiest case to write. Once way is to write two mutually recursive functions, the eval case for ListComprehension and a helper function comprehension.\nThe eval case for list comprehension, does more or less the same as the ListExpression does: It takes the result of evaluating the contents, and puts the resulting List into the Boa monad. Then, comprehension is the function that actually computes the result.\neval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension = undefined comprehension takes in a list of clauses, and a Clause is either an if-statement on the form If Expression or a for-statement on the form For VariableName Expression=.\nTherefore, comprehension pattern matches on three cases: The empty list, a for-statement and more clauses, or an if-statement and more clauses.\neval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension [] = undefined comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined In the case of the empty list, we have a list comprehension that is really just a list expression, on the form ListComprehension Expression []. So in that case, comprehension can just evaluate e1 and return the list containing that one value, inside the Boa monad.\nOnce again, there\u0026rsquo;s a very handy function we can use, to write this code in a single, short line, namely \u0026lt;\u0026amp;\u0026gt;. It\u0026rsquo;s implemented as flip fmap and has the type signature\n(\u0026lt;\u0026amp;\u0026gt;) :: Functor f ==\u0026gt; f a -\u0026gt; (a -\u0026gt; b) -\u0026gt; f b.\nIn our case, we\u0026rsquo;re applying it like this,\n(\u0026lt;\u0026amp;\u0026gt;) :: Boa Value -\u0026gt; (Value -\u0026gt; [Value]) -\u0026gt; Boa [Value].\nThe return we\u0026rsquo;re using here is the return of the list monad. Basically, we\u0026rsquo;re saying \u0026ldquo;evaluate e1, which gives us a Boa Value. Then, take that value out of the Boa monad, put it into the list monad with return, and finally put that list with the value back in the Boa monad\u0026rdquo;.\neval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension [] = eval e1 \u0026lt;\u0026amp;\u0026gt; return comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined Recall that the result of evaluating a list comprehension should be on the form Boa (List [Value]), which (because List [Value] is itself a Value) is just a Boa\rValue. When we return from comprehension to eval, we can fmap the constructor List onto the Boa [Value], which accomplishes exactly this: It turns the result Boa [Value] into Boa (List [Value]).\nWhen we encounter an If-expression, the syntax corresponds to e1 if e2 . So we know that the expression e2 should be a Boolean value. Luckily, in Boa as in Python, non-Boolean values correspond to a Boolean value. E.g., 1==True is true and 0==True is false.The first thing we can do, then, is to evaluate e2 and find the corresponding Boolean value with truthy.\nBy fmap-ing truthy onto the evaluated expression, we get a Boa Bool, i.e., a normal Haskell Boolean inside the Boa monad. By using do-notation, then, we can give b the unwrapped Boolean and we can use it directly in an if-statement. If the condition b holds, then evaluate the rest of the list comprehension. Else, there\u0026rsquo;s no more to evaluate.\neval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension [] = eval e1 \u0026lt;\u0026amp;\u0026gt; return comprehension (If e2 : c2) = do b \u0026lt;- truthy \u0026lt;$\u0026gt; eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = undefined The case for For statements is probably the hardest to read, but it\u0026rsquo;s not that bad now that we\u0026rsquo;re more familiar with \u0026lt;$\u0026gt; and mapM.\nThe corresponding syntax is e1 for x in e2 so we know that e2 is the list where we should bind the variable name x to an element, for each iteration.\nWe evaluate e2 to v2. If v2 is not iterable, then it\u0026rsquo;s not possible to use it in a for-statement and we should throw an error. If it\u0026rsquo;s a list, then we want to bind each value in xs to x inside the rest of the comprehension, c2.\nRecall the following function types.\ncomprehension :: [Clause] -\u0026gt; Boa [Value]\nbind :: VariableName -\u0026gt; Value -\u0026gt; (Boa a -\u0026gt; Boa a)\nmapM :: (a -\u0026gt; m b) -\u0026gt; [a] -\u0026gt; m ([b])\nWe want to do bind x v (comprehension c2), where v is each of the values from xs. We already have the variable name x and the comprehension c2, but bind needs a single value v, whereas xs is a list of values. Time for some mapM magic.\nSince xs has the type [Value], we can rewrite mapM as\nmapM :: (Value -\u0026gt; Boa Value) -\u0026gt; [Value] -\u0026gt; Boa [Value]\nThen xs can be the second argument! In order for bind to be the first argument, we can write an anonymous function (\\v -\u0026gt; bind x v (comprehension c2)) :: Value\r-\u0026gt; Boa Value.\nNow mapM (\\v -\u0026gt; bind x v (comprehension c2)) xs does exactly what we wanted it to do! Except that we\u0026rsquo;re mapping a function that returns a list, over a list, so the result is a Boa [[Value]]. To fix this, we can simply fmap the function concat over the result to turn it into a single, flat list and put it inside the Boa monad. And then, we\u0026rsquo;re all done with eval!\neval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension [] = eval e1 \u0026lt;\u0026amp;\u0026gt; return comprehension (If e2 : c2) = do b \u0026lt;- truthy \u0026lt;$\u0026gt; eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = do v2 \u0026lt;- eval e2 case v2 of (List xs) -\u0026gt; concat \u0026lt;$\u0026gt; mapM (\\v -\u0026gt; bind x v (comprehension c2)) xs _ -\u0026gt; abort $ BadArgument $ \u0026#34;Argument \u0026#34; ++ showValue v2 ++ \u0026#34; is not iterable\u0026#34; If eval and comprehension look completely crazy to you - especially if you\u0026rsquo;re wondering how we can use e1 inside of comprehension - I\u0026rsquo;d recommend reading about closures and mutually recursive functions. It\u0026rsquo;s really powerful stuff, but I was definitely confused the first time I saw it!\nPutting It All Together Now we have the following eval function.\neval :: Expression -\u0026gt; Boa Value eval (Constant v) = return v eval (Variable x) = look x eval (Operation o e1 e2) = do v1 \u0026lt;- eval e1 v2 \u0026lt;- eval e2 case operate o v1 v2 of Right v -\u0026gt; return v Left re -\u0026gt; abort $ BadArgument re eval (Not e) = Boolean . not . truthy \u0026lt;$\u0026gt; eval e eval (Call f es) = mapM eval es \u0026gt;\u0026gt;= apply f eval (ListExpression es) = List \u0026lt;$\u0026gt; mapM eval es eval (ListComprehension e1 c1) = List \u0026lt;$\u0026gt; comprehension c1 where comprehension :: [Clause] -\u0026gt; Boa [Value] comprehension [] = eval e1 \u0026lt;\u0026amp;\u0026gt; return comprehension (For x e2 : c2) = do v2 \u0026lt;- eval e2 case v2 of (List xs) -\u0026gt; concat \u0026lt;$\u0026gt; mapM (\\v -\u0026gt; bind x v (comprehension c2)) xs _ -\u0026gt; abort $ BadArgument $ \u0026#34;Argument \u0026#34; ++ showValue v2 ++ \u0026#34; is not iterable\u0026#34; comprehension (If e2 : c2) = do b \u0026lt;- truthy \u0026lt;$\u0026gt; eval e2 if b then comprehension c2 else return [] At this point, all we need is to write exec and execute!\nexec should just perform the computations in order and collect the output. It doesn\u0026rsquo;t need to keep track of which value was just computed, so the return type of exec is just Boa ().\nWe decided earlier that it should pattern match on Define and Execute statements. If it\u0026rsquo;s a definition, then we should evaluate the expression and bind the variable name to the result in the environment.\nexec :: Program -\u0026gt; Boa () exec [] = return () exec ((Define x e) : s) = do v \u0026lt;- eval e bind x v (exec s) exec ((Execute e) : s) = undefined If it\u0026rsquo;s an execution statement, then we should just evaluate the expression and keep executing the rest of the program.\nexec :: Program -\u0026gt; Boa () exec [] = return () exec ((Define x e) : s) = do v \u0026lt;- eval e bind x v (exec s) exec ((Execute e) : s) = eval e \u0026gt;\u0026gt; exec s And\u0026hellip; That\u0026rsquo;s it! All our hard work when writing eval and its helper functions is finally paying off. This code it short, easy to read, and (relatively) easy to understand.\nThen execute is just the function that runs exec program in the empty environment.\nexecute :: Program -\u0026gt; (Output, Maybe RuntimeError) execute p = case run (exec p) [] of (Right _, out) -\u0026gt; (out, Nothing) (Left re, out) -\u0026gt; (out, Just re) Then we\u0026rsquo;re all done! After writing a driver program (like Main.hs in the repo), you can install this boa executable by typing stack install in the directory. Now you can interpret Boa ASTs!\nContact I appreciate any feedback, comments, corrections, etc. you may have. If that\u0026rsquo;s the case, you can reach me via my GitHub or my email at sophie.bosio@outlook.com. Happy coding!\n","permalink":"https://sophiebosio.github.io/posts/boa-interpreter-haskell/","summary":"One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.\nWe\u0026rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here\u0026rsquo;s how we approached it and some of my reflections when looking back at it.\nI\u0026rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it\u0026rsquo;s easier to see how monads work when seeing the implementation.","title":"Implementing a Small Interpreter in Haskell"},{"content":"In my opinion, the power of Emacs is that you\u0026rsquo;re able to program your own working environment. Other editors may be just as, or possibly more, efficient to use, but I haven\u0026rsquo;t come across any that give you control over as many aspects of your editor as Emacs does. Customising and tweaking your configuration may be an endless endeavour, but it\u0026rsquo;s also a highly rewarding one.\nAll that being said, I was inspired to tweak the look of my Org Mode setup, especially after reading this post. Below you can find screenshots and code. I hope there\u0026rsquo;s something in here that you might want to steal for your own config! In case I change these settings later, my most recently updated config is always available on my GitHub.\nTheme The easiest and quickest way to change the look of vanilla Emacs is to load a colour theme. I\u0026rsquo;m using the doom-nord theme, which is part of the doom-themes package. I find both it and several of the other themes from that pack to be excellent.\nYou can find an updated list of themes on emacsthemes.com where they have screenshots. From spending time on the Emacs subreddit, I also know that people are very fond of Prot\u0026rsquo;s Modus and Ef themes, as well as the built-in leuven theme. Feel free to play around!\nFonts Next up is setting up variable-pitch and fixed-pitch fonts. I love Roboto Mono and I use a ligaturised version of it for programming, from the a-better-ligaturizer project. Here, I\u0026rsquo;ll add that a package such as ligature.el is required to display the ligatures.\nFor variable-pitch (regular) text, I want to use Source Sans Pro.\nIn my Emacs config, I have set these fonts outside the Org section, under \u0026ldquo;Interaction, Look \u0026amp; Feel\u0026rdquo;.\n(when (member \u0026#34;Roboto Mono\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;default nil :font \u0026#34;Roboto Mono\u0026#34; :height 108) (set-face-attribute \u0026#39;fixed-pitch nil :family \u0026#34;Roboto Mono\u0026#34;)) (when (member \u0026#34;Source Sans Pro\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;variable-pitch nil :family \u0026#34;Source Sans Pro\u0026#34; :height 1.18)) Then, back in the Org-specific part of the config, I resize the Org headings and choose Source Sans Pro to be the header font.\n;; Resize Org headings (dolist (face \u0026#39;((org-level-1 . 1.35) (org-level-2 . 1.3) (org-level-3 . 1.2) (org-level-4 . 1.1) (org-level-5 . 1.1) (org-level-6 . 1.1) (org-level-7 . 1.1) (org-level-8 . 1.1))) (set-face-attribute (car face) nil :font \u0026#34;Source Sans Pro\u0026#34; :weight \u0026#39;bold :height (cdr face))) ;; Make the document title a bit bigger (set-face-attribute \u0026#39;org-document-title nil :font \u0026#34;Source Sans Pro\u0026#34; :weight \u0026#39;bold :height 1.8) In order to avoid line spacing issues when a line of text contains both variable- and fixed-pitch text, we need to make sure that the org-indent face inherits from fixed-pitch.\n(require \u0026#39;org-indent) (set-face-attribute \u0026#39;org-indent nil :inherit \u0026#39;(org-hide fixed-pitch)) And then, we want to make sure that some parts of the Org document always use fixed-pitch even when variable-pitch-mode is on.\n(set-face-attribute \u0026#39;org-block nil :foreground nil :inherit \u0026#39;fixed-pitch :height 0.85) (set-face-attribute \u0026#39;org-code nil :inherit \u0026#39;(shadow fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-indent nil :inherit \u0026#39;(org-hide fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-verbatim nil :inherit \u0026#39;(shadow fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-special-keyword nil :inherit \u0026#39;(font-lock-comment-face fixed-pitch)) (set-face-attribute \u0026#39;org-meta-line nil :inherit \u0026#39;(font-lock-comment-face fixed-pitch)) (set-face-attribute \u0026#39;org-checkbox nil :inherit \u0026#39;fixed-pitch) For this all to come together, we need to make sure that variable-pitch-mode is always active in Org buffers.\n(add-hook \u0026#39;org-mode-hook \u0026#39;variable-pitch-mode) Also, if you\u0026rsquo;re having troubles with the size of LaTeX-previews like I did, you can increase the size like so.\n(plist-put org-format-latex-options :scale 2) Decluttering \u0026amp; Text Prettification We\u0026rsquo;ll declutter by hiding leading starts in headings and emphasis markers (e.g., the slashes in /.../ ). We\u0026rsquo;ll also use \u0026ldquo;pretty entities\u0026rdquo;, which allow us to insert special characters LaTeX-style by using a leading backslash (e.g., \\alpha to write the greek letter alpha). org-ellipsis is the symbol displayed after an Org-heading that is collapsed - I prefer a simple dot.\n(setq org-adapt-indentation t org-hide-leading-stars t org-hide-emphasis-markers t org-pretty-entities t org-ellipsis \u0026#34; ·\u0026#34;) For source code blocks specifically, I want Org to display the contents using the major mode of the relevant language. I also want TAB to behave inside the source code block like it normally would when writing code in that language.\n(setq org-src-fontify-natively t org-src-tab-acts-natively t org-edit-src-content-indentation 0) Centring \u0026amp; Line Breaks I want the text to fill the screen adaptively, so that long lines of text adapt to the size of the window. It also breaks lines instead of truncating them.\n(add-hook \u0026#39;org-mode-hook \u0026#39;visual-line-mode) I prefer having my Org buffer centred. I think it looks prettier when I only have one buffer open, and it\u0026rsquo;s barely noticeable when several are open because the width of the margins adapt. For this, I use Olivetti, which I think is a great package for this purpose.\n(add-hook \u0026#39;org-mode-hook \u0026#39;olivetti-mode) As you can see in the below screenshot, the Org document fills up the left side of the screen comfortably even when olivetti-mode is on.\nTask \u0026amp; Time Tracking Org mode is also a really powerful tool for tracking tasks and time usage. However, the default colours don\u0026rsquo;t go too well with our new look.\nOf course, you should change the keywords and the number of priorities to suit your tastes. I have lifted my colours straight from the official Nord theme pallette so that they go well with my preferred theme.\nLet\u0026rsquo;s set the number of task priorities and specify the colour for each priority.\n(setq org-lowest-priority ?F) ;; Gives us priorities A through F (setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E]. (setq org-priority-faces \u0026#39;((65 . \u0026#34;#BF616A\u0026#34;) (66 . \u0026#34;#EBCB8B\u0026#34;) (67 . \u0026#34;#B48EAD\u0026#34;) (68 . \u0026#34;#81A1C1\u0026#34;) (69 . \u0026#34;#5E81AC\u0026#34;) (70 . \u0026#34;#4C566A\u0026#34;))) And then the keywords and their colours.\n(setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;PROJ\u0026#34; \u0026#34;READ\u0026#34; \u0026#34;CHECK\u0026#34; \u0026#34;IDEA\u0026#34; ; Needs further action \u0026#34;|\u0026#34; \u0026#34;DONE\u0026#34;))) ; Needs no action currently (setq org-todo-keyword-faces \u0026#39;((\u0026#34;TODO\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#A3BE8C\u0026#34; :weight bold) (\u0026#34;PROJ\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#88C0D0\u0026#34; :weight bold) (\u0026#34;READ\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#8FBCBB\u0026#34; :weight bold) (\u0026#34;CHECK\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#81A1C1\u0026#34; :weight bold) (\u0026#34;IDEA\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#EBCB8B\u0026#34; :weight bold) (\u0026#34;DONE\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#30343d\u0026#34; :weight bold))) Here, you can see a screenshot of these TODOs in action.\nPrettier UI Elements I use a combination of org-modern and org-superstar to style my UI elements. org-modern is what gives me such pretty source code blocks, for example. Here\u0026rsquo;s my (relatively minimal) setup for it.\n(use-package org-modern :config (setq org-auto-align-tags t org-tags-column 0 org-fold-catch-invisible-edits \u0026#39;show-and-error org-special-ctrl-a/e t org-insert-heading-respect-content t ;; Don\u0026#39;t style the following org-modern-tag nil org-modern-priority nil org-modern-todo nil org-modern-table nil ;; Agenda styling org-agenda-tags-column 0 org-agenda-block-separator ?─ org-agenda-time-grid \u0026#39;((daily today require-timed) (800 1000 1200 1400 1600 1800 2000) \u0026#34; ┄┄┄┄┄ \u0026#34; \u0026#34;┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄\u0026#34;) org-agenda-current-time-string \u0026#34;⭠ now ─────────────────────────────────────────────────\u0026#34;) (global-org-modern-mode)) And here is the setup for org-superstar.\n(use-package org-superstar :config (setq org-superstar-leading-bullet \u0026#34; \u0026#34;) (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes (setq org-superstar-todo-bullet-alist \u0026#39;((\u0026#34;TODO\u0026#34; . 9744) (\u0026#34;DONE\u0026#34; . 9744) (\u0026#34;READ\u0026#34; . 9744) (\u0026#34;IDEA\u0026#34; . 9744) (\u0026#34;WAITING\u0026#34; . 9744) (\u0026#34;CANCELLED\u0026#34; . 9744) (\u0026#34;PROJECT\u0026#34; . 9744) (\u0026#34;POSTPONED\u0026#34; . 9744))) ) Conclusion There it is, that\u0026rsquo;s pretty much all of the visual Org-specific code in my config. If you\u0026rsquo;re interested in other aspects of my config, you\u0026rsquo;re of course welcome to check it out. I\u0026rsquo;m just starting out, so I\u0026rsquo;d also really appreciate constructive criticism or tips!\n","permalink":"https://sophiebosio.github.io/posts/beautifying-emacs-org-mode/","summary":"In my opinion, the power of Emacs is that you\u0026rsquo;re able to program your own working environment. Other editors may be just as, or possibly more, efficient to use, but I haven\u0026rsquo;t come across any that give you control over as many aspects of your editor as Emacs does. Customising and tweaking your configuration may be an endless endeavour, but it\u0026rsquo;s also a highly rewarding one.\nAll that being said, I was inspired to tweak the look of my Org Mode setup, especially after reading this post.","title":"Beautifying Emacs Org Mode"},{"content":"I\u0026rsquo;m Sophie! I was born in Oslo in 1999, and after some moving back and forth for my studies, I\u0026rsquo;m back in my home city.\nI\u0026rsquo;m very interested in programming, coffee, natural languages, and music.\nCurrently, I\u0026rsquo;m enjoying the wild ride of learning Emacs and working on my MSc thesis, which about using program inversion to simplify automatic testing. By inverting your program, I hope to derive a good test input generator for you that you can feed to QuickCheck to automatically test your program with property-based tests, without having to write the generator by hand.\nThese days, I\u0026rsquo;m really enjoying using Haskell, and that\u0026rsquo;s the language I\u0026rsquo;ll use for my thesis as well.\nBesides programming languages, I am also known to occasionally nerd out about natural languages. In addition to Norwegian and English, I speak French and Italian reasonably well.\nI wanted to learn French because I have some family in France and so I spent a year in Dijon trying to learn some more of the language.\nDuring my bachelor\u0026rsquo;s degree, I went to Bologna, Italy for an exchange semester, where I had some courses in Italian. The Italian skills were doubly useful because my French family is from a town bordering Italy, meaning I get to practice both languages when I\u0026rsquo;m visiting!\nIf you want to reach me, you\u0026rsquo;re welcome to do so via my UiO email at sabosio@uio.no or through my GitHub ✨\n","permalink":"https://sophiebosio.github.io/about/","summary":"I\u0026rsquo;m Sophie! I was born in Oslo in 1999, and after some moving back and forth for my studies, I\u0026rsquo;m back in my home city.\nI\u0026rsquo;m very interested in programming, coffee, natural languages, and music.\nCurrently, I\u0026rsquo;m enjoying the wild ride of learning Emacs and working on my MSc thesis, which about using program inversion to simplify automatic testing. By inverting your program, I hope to derive a good test input generator for you that you can feed to QuickCheck to automatically test your program with property-based tests, without having to write the generator by hand.","title":"About"},{"content":"BSc I have a bachelor\u0026rsquo;s degree in Cognitive Science from the University of Bergen, Norway.\nThe full course plan for the degree can be found at the university\u0026rsquo;s websites, but unfortunately, the relevant plan (admission in 2019) is only available in Norwegian.\nMost of the course pages do however have an English version. A brief overview with links is provided below for the reader\u0026rsquo;s convenience. Programming languages used in the courses have been added in parentheses where relevant.\nDuring my BSc, I had an exchange semester at the University of Bologna, Italy. The relevant courses from my exchange are appended to the list.\nCourses in Cognitive Science at UiB\rKOGVIT101 - Introduction to the Cognitive Sciences INF100 - Introduction to Programming (Python) EXFAC00SK - Basic Linguistics DASPSTAT - Statistics for the Cognitive Sciences LOG110 - Introduction to Formal Logic LOG111 - Deduction and Meta-Logic INF101 - Object-Oriented Programming (Java) LING122 - Languages and Cognition INFO282 - Knowledge Representation and Reasoning (Prolog) INF122 - Functional Programming (Haskell) FIL105 - Philosophy of Mind PSYK120 - Biological and Cognitive Psychology EXPHIL-PSSEM - Examen Facultatum in Psychology INFO135 - Advanced Programming (Algorithms, Data Structures, and Programming) (Python) INF223 - Category Theory INF227 - Mathematical Logic MAT121 - Linear Algebra And instead of the following courses (left), I had the equivalent courses at the University of Bologna (right):\nMAT111 -\u0026gt; 79184 - Calculus I INF102 -\u0026gt; 91256 - Algorithms and Programming (Python) Free credits -\u0026gt; 90106 - Ingegneria del Software (JavaScript) MSc I am currently in the second (and final) year of my master\u0026rsquo;s degree in Programming and System Architecture at the University of Oslo, Norway, with the software specialisation. 🌱\nThe courses I have taken at UiO are briefly summarised below.\nCourses in Programming and System Architecture at UiO\rIN5130 - Modelling Unassailable IT-Systems IN5170 - Models of Concurrency TEK5510 - Security in Operating Systems and Software IN5570 - Distributed Objects IN5580 - Computability Theory INF5110 - Compiler Construction Special Curriculum - Advanced Functional Programming, Semantics, and Types ","permalink":"https://sophiebosio.github.io/education/","summary":"BSc I have a bachelor\u0026rsquo;s degree in Cognitive Science from the University of Bergen, Norway.\nThe full course plan for the degree can be found at the university\u0026rsquo;s websites, but unfortunately, the relevant plan (admission in 2019) is only available in Norwegian.\nMost of the course pages do however have an English version. A brief overview with links is provided below for the reader\u0026rsquo;s convenience. Programming languages used in the courses have been added in parentheses where relevant.","title":"Education"},{"content":"This website is built with Hugo and ox-hugo, an exporting engine that lets me write my posts in Org mode and then put it online easily.\nOrg mode is a really clever and powerful plain text format that works great for note taking, text editing, and TODO lists/agendas. Moreover, there are a lot of convenient features for us Emacs users when using ox-hugo to write our blogs (besides staying in the comfort of a well-known format and editing flow).\nFor example, I can use this code snippet from ox-hugo\u0026rsquo;s blog as a template to create a new blog post and bind it to a key combination in my Emacs configuration:\n(with-eval-after-load \u0026#39;org-capture (defun org-hugo-new-subtree-post-capture-template () \u0026#34;Returns `org-capture\u0026#39; template string for new Hugo post. See `org-capture-templates\u0026#39; for more information.\u0026#34; (let* ((title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #\u0026#39;identity `( ,(concat \u0026#34;* TODO \u0026#34; title) \u0026#34;:PROPERTIES:\u0026#34; ,(concat \u0026#34;:EXPORT_FILE_NAME: \u0026#34; fname) \u0026#34;:END:\u0026#34; \u0026#34;%?\\n\u0026#34;) ;Place the cursor here finally \u0026#34;\\n\u0026#34;))) (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;h\u0026#34; ;`org-capture\u0026#39; binding + h \u0026#34;Hugo post\u0026#34; entry (file \u0026#34;~/path/to/your/all-posts.org\u0026#34;) (function org-hugo-new-subtree-post-capture-template)))) TODO Monads in Haskell ","permalink":"https://sophiebosio.github.io/posts/hugo/","summary":"This website is built with Hugo and ox-hugo, an exporting engine that lets me write my posts in Org mode and then put it online easily.\nOrg mode is a really clever and powerful plain text format that works great for note taking, text editing, and TODO lists/agendas. Moreover, there are a lot of convenient features for us Emacs users when using ox-hugo to write our blogs (besides staying in the comfort of a well-known format and editing flow).","title":"Static Site Generation with Hugo"}]