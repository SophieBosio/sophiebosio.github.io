[{"content":"I use Clojure on the backend where I work. I think it\u0026rsquo;s really fun, especially in combination with Emacs, since Emacs is built with Emacs Lisp and Clojure is a Lisp dialect. So many of Emacs\u0026rsquo; default keybindings started clicking for me once I started working with a language in the same tradition, editing structurally and by semantic units rather than line-by-line or character-by-character. I\u0026rsquo;m not alone in loving both and there\u0026rsquo;s clearly a lot of overlap between the two communities, which is evident from the number of Clojure packages for Emacs.\nThe probably most famous and popular among these is the excellent package CIDER, which provides a full-fledged development environment for Emacs with support for interactive development. CIDER has a ton of features for evaluating, debugging, and testing your code. However, you might want to supplement CIDER with other packages for things such as peeking function argument lists, navigating your code, and finding references/implementations. Emacs has some built-in documentation (eldoc), project management (project) and reference-finding capabilities (xref). But when you need more, clojure-lsp is your friend and the LSP client for Emacs lsp-mode integrates pretty well with the aforementioned built-ins.\nBasic Setup With clojure-lsp installed, you can use your preferred package manager to get the Emacs package lsp-mode. I use use-package. lsp-mode is pretty good at integrating with the built-in Emacs features, so I\u0026rsquo;ll let it autoconfigure, which it does by default. I\u0026rsquo;ll defer the package loading to shave off some precious milliseconds at Emacs\u0026rsquo; startup.\n(use-package lsp-mode :defer t) Let\u0026rsquo;s add some hooks to start up lsp-mode when I\u0026rsquo;m programming in Clojure. I\u0026rsquo;ll also enable the which-key integration.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration))) Custom Bindings Next, I\u0026rsquo;ll bind some keys. The LSP server can suggest code actions and to execute these quickly, I\u0026rsquo;ll bind the command lsp-execute-code-action to M-\u0026lt;return\u0026gt;. xref works pretty well in Clojure and lets you jump to the definition of a symbol with M-. (and jump back by popping the ref off the stack with M-,), so to find references instead of the implementation, I\u0026rsquo;ll bind lsp-find-references to C-M-..\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\u0026#34;C-M-.\u0026#34; . lsp-find-references) (\u0026#34;C-c r\u0026#34; . lsp-rename) (\u0026#34;M-\u0026lt;return\u0026gt;\u0026#34; . lsp-execute-code-action))) Then, C-M-. pops up an xref buffer where I can see all references to a function, in which I can select an entry and jump to the call site.\nI can also press C-c r to rename a symbol as you\u0026rsquo;d expect.\nM-\u0026lt;return\u0026gt; gives me a minibuffer with available code actions.\nAs a quick note, the code actions show up in a regular minibuffer. I just use vertico with vertico-posframe, which gives me a nice childframe for mine.\nIn case you\u0026rsquo;re interested, you can get rounded corners (on Mac OS) and fringes (Mac OS \u0026amp; Linux) by setting the variable vertico-posframe-paramters with the following settings:\n(setq vertico-posframe-parameters \u0026#39;((left-fringe . 12) (right-fringe . 12) (undecorated . nil))) Diagnostics LSP mode automatically tries to figure out which diagnostics tool you\u0026rsquo;re using, but I ran into some strange problem with the :auto setting when using Flycheck, so I set it to use Flycheck manually.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\u0026#34;C-M-.\u0026#34; . lsp-find-references) (\u0026#34;C-c r\u0026#34; . lsp-rename) (\u0026#34;M-\u0026lt;return\u0026gt;\u0026#34; . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck)) This gives me the regular Flycheck indicators (the arrows) that something\u0026rsquo;s wrong, but also information in the echo area and in a popup childframe on mouse hover.\nCustomisation From this point onwards, the LSP server works really well on my machine for Clojure. However, lsp-mode comes with a few more bells and whistles than I\u0026rsquo;d like, so I\u0026rsquo;ll finish by deactivating some features. A tour of on-by-default features and guide on how to disable them can be found here.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\u0026#34;C-M-.\u0026#34; . lsp-find-references) (\u0026#34;C-c r\u0026#34; . lsp-rename) (\u0026#34;M-\u0026lt;return\u0026gt;\u0026#34; . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck) ;; Disable visual features (setq lsp-headerline-breadcrumb-enable nil ;; No breadcrumbs lsp-ui-sideline-enable nil ;; No sideline lsp-lens-enable nil ;; No lenses ;; Disable all mode line features, since I use a custom mode line lsp-modeline-code-actions-enable nil lsp-modeline-diagnostics-enable nil ;; Limit raising of the echo area to show docs lsp-signature-doc-lines 3)) With all this, I get a lot of nice LSP features. In conjunction with CIDER, this is starting to feel really smooth.\nFor example, the function\u0026rsquo;s docstring in the echo area when it\u0026rsquo;s at point.\nLSP-mode also plays nicely with my completion system, here using corfu.\nPerformance Improvements And finally, LSP-mode works a little bit faster if we set it to use plists for serialisation. We can set this in the :init-block of the use-package declaration.\n:init (setq lsp-use-plists t) Note that if you want to do this, you also need to add (setenv \u0026quot;LSP_USE_PLISTS\u0026quot; \u0026quot;true\u0026quot;) to your early-init.el. See the performance part of the lsp-mode documentation for more information.\nFinal Configuration \u0026amp; Further Reading And here\u0026rsquo;s the final configuration that I\u0026rsquo;m using for Clojure as of September 2024.\n(use-package lsp-mode :defer t :init (setq lsp-use-plists t) :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\u0026#34;C-M-.\u0026#34; . lsp-find-references) (\u0026#34;C-c r\u0026#34; . lsp-rename) (\u0026#34;M-\u0026lt;return\u0026gt;\u0026#34; . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck) ;; Disable visual features (setq lsp-headerline-breadcrumb-enable nil ;; No breadcrumbs lsp-ui-sideline-enable nil ;; No sideline lsp-lens-enable nil ;; No lenses ;; Disable all mode line features, since I use a custom mode line lsp-modeline-code-actions-enable nil lsp-modeline-diagnostics-enable nil ;; Limit raising of the echo area to show docs lsp-signature-doc-lines 3)) The next thing I would consider to enhance my Clojure coding experience even further, is incorporating structural editing. Clojure, being a LISP dialect and therefore pretty close to an abstract syntax tree, is especially well-suited to structural editing. paredit is the classic and what I\u0026rsquo;ve used previously. Now, I use a combination of paredit and lispy, which has many more functions than paredit, with paredit-style keybindings. Smartparens is a paredit-alternative. puni is the most language-agnostic alternative, as far as I can tell.\nThanks for reading! I welcome feedback, comments, or questions. You can reach me via email or GitHub.\n","permalink":"http://localhost:1313/posts/lsp-mode-for-clojure/","summary":"\u003cp\u003eI use \u003ca href=\"https://clojure.org/\"\u003eClojure\u003c/a\u003e on the backend \u003ca href=\"https://www.ardoq.com/\"\u003ewhere I work\u003c/a\u003e. I think it\u0026rsquo;s really fun, especially in combination with Emacs, since Emacs is built with Emacs Lisp and Clojure is a Lisp dialect. So many of Emacs\u0026rsquo; default keybindings started clicking for me once I started working with a language in the same tradition, editing structurally and by semantic units rather than line-by-line or character-by-character. I\u0026rsquo;m not alone in loving both and there\u0026rsquo;s clearly a lot of overlap between the two communities, which is evident from the number of Clojure packages for Emacs.\u003c/p\u003e","title":"Setting Up Emacs LSP-Mode For Clojure"},{"content":"Emacs is a wonderful piece of software. It\u0026rsquo;s easily my favourite program of all time. It can also be a little overwhelming to configure for the first time.\nOne of the many things that make Emacs great, though, is its dedicated and helpful user base. I hope to add a small contribution to that community with this post, going over what I would have told my past self as I was just starting out using Emacs and trying to write my first Emacs configuration file.\nI\u0026rsquo;ll assume you know the basics of editing with Emacs and won\u0026rsquo;t cover general concepts like major modes or how to save files in Emacs. I\u0026rsquo;ll primarily be focusing on how you can get started personalising it.\nBefore we get into it, I\u0026rsquo;d like to cover three things: (1) Emacs is a Lisp interpreter at heart, (2) there are great places to get help, and (3) you should try out pieces of other people\u0026rsquo;s configs.\nPreamble A Primer in Emacs and Elisp Emacs is often thought of as a text editor. While it is built around text editing and has many great packages to do so, I\u0026rsquo;d argue it\u0026rsquo;s more useful to think of it as an (Emacs) Lisp interpreter.\nYour configuration file is a program of Emacs Lisp (or \u0026ldquo;elisp\u0026rdquo; for short) code that modifies the behaviour of Emacs itself. Most of the behaviours of vanilla Emacs are written in Elisp, and the rest in C. Therefore, almost everything that Emacs does, you can change! You can, of course, add and create new functionality as well.\nThe power to build your ideal editor is right at your fingertips! As long as you\u0026rsquo;re willing to learn a little bit of a Lisp dialect.\nThankfully, Elisp is a pretty readable language and as long as you watch your parentheses, you\u0026rsquo;ll be fine.\nGet Help The Emacs community is very friendly and are often keep to help out. I hang out a lot on the r/emacs subreddit and have gotten tons of tips and troubleshooting help from there. r/planetemacs is also great \u0026mdash; they focus mostly on packages and blog posts/article links.\nEmacs also has a pretty good documentation and help system. You can take the Emacs tutorial using C-h t. Ask Emacs for help using:\nC-h v to see the documentation for a variable C-h f to see the documentation for a function C-h k to see what a keybinding does C-h m to show help for the current major and minor modes Or read on the Emacs Wiki.\nConfig Inspo This brings me to my first and (I think) most helpful tip: Get inspired by other people\u0026rsquo;s configurations.\nI\u0026rsquo;ll talk a little later about the basics of using Elisp for your config file, and that might be useful to help you read and understand the configs, but I think it\u0026rsquo;s good to have a starting point and to start experimenting early.\nIf you\u0026rsquo;re only just starting out, I invite you to check out my config and send me any questions you might have by email. (If you\u0026rsquo;re experienced, I invite you to send me any corrections or improvements!)\nHere are some of the configurations I have stolen a lot of my configuration from and can heartily recommend checking out.\nLars Tveito Jake Boxerman, with accompanying video Protesilaos Stavrou David Wilson (System Crafters) Nicolas Rougier Check out the configs piece by piece by copying something into your own config and testing it out for a while. This is probably what has been the most helpful to me.\nYou could also get a lot of useful tips and tricks from checking out some curated, \u0026ldquo;sane defaults\u0026rdquo; builds of Emacs. These are designed to be minimal and extensible, just configuring some settings to make the initial switch to Emacs a little smoother and give you a solid foundation for writing your own config. Most of them don\u0026rsquo;t include too many extra packages, either. Some of these include:\nPrelude Crafted Emacs Purcell\u0026rsquo;s Emacs config Nano Emacs Basics: Setting Variables Your configuration file is an Emacs Lisp file called init.el, located in your Emacs home directory. Usually, this is at ~/.emacs.d/init.el. This is where you\u0026rsquo;ll add your code, and Emacs will load this file at startup.\nEmacs can be configured either by modifying default behaviour or by installing and configuring community packages. You\u0026rsquo;ll probably want to do both.\nThere are quite a few blog posts and configurations that cover how to set \u0026ldquo;sane defaults\u0026rdquo; \u0026mdash; i.e., modify the default behaviour of Emacs in a way most people would agree with. Check out the \u0026ldquo;early init\u0026rdquo; files or startup sections of the configs above. You might also want to check out sensible-defaults, which contains a lot of useful and, yes, sensible functions you can use in your config.\nIn general, you set the value of a variable using setq. Specify the name of the variable or the mode, then set it to an accepted value. Often variables will use t / nil and modes will use 1 / 0.\n(setq enabled-option t disabled-option nil enabled-mode 1 disabled-mode 0) Installing Packages After you\u0026rsquo;re done tweaking Emacs\u0026rsquo; default behaviours, you\u0026rsquo;ll probably need some packages.\nYou can install a package from a package source or load an installed package in your load path using the require keyword.\n(require \u0026#39;package-name) This is the easiest way to get started. Add the require-line to your init.el file and use setq to configure the package.\nIn fact, at the top of your init.el file, you should (require 'package). package.el is the default package manager for Emacs.\nMany Emacs packages are available at MELPA, a package archive with generally high-quality packages. You might also want to add some other package sources. Here\u0026rsquo;s an example from my config, where I add quite a few sources and tell Emacs which places to check first.\n(setq package-archives \u0026#39;((\u0026#34;GNU ELPA\u0026#34; . \u0026#34;https://elpa.gnu.org/packages/\u0026#34;) (\u0026#34;MELPA\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) (\u0026#34;ORG\u0026#34; . \u0026#34;https://orgmode.org/elpa/\u0026#34;) (\u0026#34;MELPA Stable\u0026#34; . \u0026#34;https://stable.melpa.org/packages/\u0026#34;) (\u0026#34;nongnu\u0026#34; . \u0026#34;https://elpa.nongnu.org/nongnu/\u0026#34;)) package-archive-priorities \u0026#39;((\u0026#34;GNU ELPA\u0026#34; . 20) (\u0026#34;MELPA\u0026#34; . 15) (\u0026#34;ORG\u0026#34; . 10) (\u0026#34;MELPA Stable\u0026#34; . 5) (\u0026#34;nongnu\u0026#34; . 0))) (package-initialize) After setting up your package sources, you can add (require 'package-name) to your init.el and Emacs will automatically search, download, and install that package from the source. Remember to evaluate your init.el file for this to happen, either by using the command eval-buffer on init.el or by restarting Emacs.\nSome packages are not available on MELPA \u0026amp; Co., in which case you might want to download it and save it on your computer manually. Or maybe you want to use a package you\u0026rsquo;ve written yourself.\nIn that case, you can also point Emacs to look for .el files on your computer. It\u0026rsquo;s practical to put all these files in the same place and add all of them to your \u0026ldquo;load path\u0026rdquo; so Emacs knows where to look for them. Here\u0026rsquo;s a setup for loading files from the ~/.emacs.d/local-lisp directory and sub-directories.\n(defvar local-lisp \u0026#34;~/.emacs.d/local-lisp/\u0026#34;) (add-to-list \u0026#39;load-path local-lisp) (let ((default-directory local-lisp)) (normal-top-level-add-subdirs-to-load-path)) A note on package management\rUsing require and setting all your variables with setq statements can lead to a long and hard-to-read config when you add many packages.\nThat\u0026rsquo;s why some people prefer using other systems or wrappers around package.el, for example use-package, quelpa, or straight. You\u0026rsquo;ll see this a lot in the installation instructions for packages. Personally, I use use-package because it\u0026rsquo;s so prevalent and because it\u0026rsquo;s quite convenient.\nBut don\u0026rsquo;t get too caught up in this, you don\u0026rsquo;t need to use any of these, and it\u0026rsquo;s not very hard to refactor your code incrementally if you decide you want to try later.\nHere\u0026rsquo;s a (simple) example of how to remove some visual elements from vanilla Emacs:\n(setq tool-bar-mode 0 ;; Remove toolbar scroll-bar-mode 0 ;; Remove scollbars menu-bar-mode 0 ;; Remove menu bar blink-cursor-mode 0) ;; Solid cursor, not blinking And here\u0026rsquo;s an example of setting up the Olivetti package:\n(require \u0026#39;olivetti) ;; Make sure Olivetti is installed (setq olivetti-style t) ;; Set the \u0026#39;olivetti-style\u0026#39; variable to true Some Package Suggestions I still think you should use bits and pieces of other people\u0026rsquo;s configurations to figure out what look and feel you prefer for your Emacs experience, but below I have gathered some packages I like and some alternatives to them.\nCompletion Systems The really big one is your completion system. By default, some things in Emacs can feel a little clunky, such as entering commands, searching documents, and finding files. Thankfully, there are packages that give you a nice prompt with auto-completions, search tools, suggestions, prettification, etc. For example, they can auto-fill directory and file names when opening a file with C-x C-f.\nThese packages are usually combined with other supplementary packages, but there are a few common ones that people use as the core of their systems. They include:\nVertico Helm Ido As mentioned, there are many, many packages people pair with these systems. Ido comes built-in with Emacs, so you might want to start there. I personally use Vertico and have been very happy with that. I tried Helm, but found it a little overwhelming and felt I wasn\u0026rsquo;t using it to its full potential. People do love it though.\nPlay around with them a little, and if you like one, I\u0026rsquo;d say stick to it. Jumping around with these is kind of confusing, so I would only consider switching if I had a problem with the one I was using, or if another one had some very attractive feature.\nTerminal Emulators You can emulate a terminal inside Emacs. I.e., you never have to leave Emacs!\nThere\u0026rsquo;s a built-in terminal emulator, but it\u0026rsquo;s not particularly nice. Instead, I would suggest checking out either vterm or Eat.\nText Editing Some packages just make text editing easier.\nTake for example auto-completion packages such as the built-in dabbrev-mode, or corfu and company-mode.\nDepending on your use, you might find multiple-cursors useful.\nDe Facto Standards Magit is the best Git interface I\u0026rsquo;ve ever used.\nSpell- and syntax-checking is usually done with Flyspell and Flycheck, respectively. These are pretty great.\nHelpful gives you better help buffers.\nWhen you start a keybinding combination, which-key shows a popup with suggestions for possible continuations of the sequence.\nMore Packages For suggestions on more packages to check out, awesome-emacs is a curated and oft-updated package list. I also love browsing the top posts on the Emacs subreddits mentioned above.\nAesthetics: Fonts \u0026amp; Themes The quickest way to make your Emacs experience feel more personalised!\nThere are many different ways to set fonts in Emacs. You can also set different fonts for the Emacs UI, for programming (monospaced or \u0026ldquo;fixed pitch\u0026rdquo; fonts) and for prose editing (regular or \u0026ldquo;variable pitch\u0026rdquo; fonts).\nHere\u0026rsquo;s how I set my fonts. I use Roboto Mono for the UI and for programming, and I use Source Sans Pro for my other documents. I check that the relevant font is installed, and then set their size using the :height property.\n(when (member \u0026#34;Roboto Mono\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;default nil :font \u0026#34;Roboto Mono\u0026#34; :height 108) (set-face-attribute \u0026#39;fixed-pitch nil :family \u0026#34;Roboto Mono\u0026#34;)) (when (member \u0026#34;Source Sans Pro\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;variable-pitch nil :family \u0026#34;Source Sans Pro\u0026#34; :height 1.18)) Note that I don\u0026rsquo;t set the height of the programming (fixed pitch) font. It simply uses the same height as the default font. I do set the size of the prose (variable pitch) font, though, and I do that by giving a relative size \u0026ndash; it\u0026rsquo;s relative to the size of the default font.\nWhen it comes to themes, I\u0026rsquo;d recommend starting with a pack so you can explore many different options quickly, without needing to install a bunch of theme packages by hand. A great place to get started, is Doom Emacs\u0026rsquo; theme pack called doom-themes. I particularly like the doom-nord theme. You can install and enable it like this:\n(require\u0026#39; doom-themes) ;; Make sure doom-themes are installed (load-theme \u0026#39;doom-nord t) ;; Load the doom-nord theme I also really like the Modus themes, the Ef themes and the Nano themes. You can find many more on emacsthemes.com.\nProgramming Eglot (Emacs polyGLOT) is an LSP server client for Emacs that comes pre-installed from Emacs 29. You can install it manually in Emacs \u0026gt;26.3.\nYou can also build Emacs with tree-sitter support. It\u0026rsquo;s available for Emacs \u0026gt;25.1.\nBesides this, there are tons of major modes for various languages, usually called \u0026lt;language-name\u0026gt;-mode. These will often give you basic syntax highlighting and commands.\nFor example, here\u0026rsquo;s a simple way to get basic Python 3.11 support:\n(require \u0026#39;python-mode) (setq python-shell-interpreter \u0026#34;python3.11\u0026#34;) Here\u0026rsquo;s my current setup for Haskell (except I\u0026rsquo;ve rewritten it to use require instead of use-package) using the Stack tool to build my Haskell projects:\n(require \u0026#39;haskell-mode) (add-hook \u0026#39;haskell-mode \u0026#39;haskell-doc-mode) (setq haskell-hoogle-command \u0026#34;hoogle\u0026#34; haskell-compile-stack-build-command \u0026#34;stack build\u0026#34; haskell-compile-stack-build-alt-command \u0026#34;stack build --pedantic\u0026#34;) (define-key haskell-mode-map (kbd \u0026#34;C-c h\u0026#34;) \u0026#39;haskell-hoogle) (define-key haskell-mode-map (kbd \u0026#34;C-c C-c\u0026#34;) \u0026#39;haskell-compile) Hooks In the Haskell example above, we briefly saw how to add a hook. A hook lets you run a function each time a specific thing happens. Most of the time, this is used to execute some function or activate/deactivate a mode when a certain mode is activated.\nFor example, in my Haskell config, I want to activate haskell-doc-mode each time I activate haskell-mode, so that I always have documentation on hand while I\u0026rsquo;m programming in Haskell.\nMaybe you want to activate line numbers each time you start programming. To do that, you can add a hook to prog-mode like so:\n;; Activate \u0026#39;display-line-numbers-mode\u0026#39; when programming (add-hook \u0026#39;prog-mode-hook \u0026#39;display-line-numbers-mode) Note the apostrophe before the names of the functions (here, the names of the modes)!\nYou can do so many more things with hooks and get really creative! I mostly use them to set up my modes the way I like them. E.g., I always center my text buffers (Org mode, LaTeX, etc.) with Olivetti and I hide the line numbers.\nBinding Keys We can get pretty deep on the subject of keybindings, so I\u0026rsquo;ll try to keep it brief.\nMost major modes with have a dedicated \u0026ldquo;mode map\u0026rdquo; of all the keybindings you can use while in that mode. Remember that you can always check out the currently available keybindings with C-h m, which describes the current major and minor modes.\nThis separation is very useful, as it allows you to bind the same keys to similar commands in different settings. E.g., you can bind C-c C-c to the relevant compilation command in all your programming languages if you like, even if the actual compilation command is different for each. You can also define your own custom keymaps and dictate when they should be used (another thing you can use hooks for!)\nIn general, you can bind a key globally, locally, or in a specific keymap like so:\n(global-set-key KEY COMMAND) (local-set-key KEY COMMAND) (define-key KEYMAP KEY COMMAND) Note that the KEY must be given in a way Emacs understands. You can use the kbd macro and then provide your keystrokes as a string, e.g., (kbd \u0026quot;C-c C-c\u0026quot;). Navigation keys and the function keys must be surrounded by \u0026lt;\u0026gt;, e.g., \u0026lt;tab\u0026gt; and \u0026lt;F1\u0026gt;.\nAgain from the Haskell config, I set keybindings for haskell-compile and haskell-hoogle commands in the haskell-mode-map.\n(define-key haskell-mode-map (kbd \u0026#34;C-c h\u0026#34;) \u0026#39;haskell-hoogle) (define-key haskell-mode-map (kbd \u0026#34;C-c C-c\u0026#34;) \u0026#39;haskell-compile) You can define keybindings for any command in Emacs. People even build personalised mnemonic systems. If you want to dive deep into keybindings, I would recommend checking out the package Hydra.\nConclusion Tinkering with my Emacs config is probably my favourite past-time, but even I will admit it was a bit of a headache in the very, very beginning. I hope this post has put a small dent in that frustration for you, or maybe given you some pointers to where you might want to take your WIP config.\nI welcome corrections, feedback, and questions by email. Happy hacking!\n","permalink":"http://localhost:1313/posts/first-emacs-config/","summary":"\u003cp\u003e\u003ca href=\"https://www.gnu.org/software/emacs/\"\u003eEmacs\u003c/a\u003e is a wonderful piece of software. It\u0026rsquo;s easily my favourite program of all\ntime. It can also be a little overwhelming to configure for the first time.\u003c/p\u003e\n\u003cp\u003eOne of the many things that make Emacs great, though, is its dedicated and\nhelpful user base. I hope to add a small contribution to that community with\nthis post, going over what I would have told my past self as I was just starting\nout using Emacs and trying to write my first Emacs configuration file.\u003c/p\u003e","title":"Building Your First Emacs Config"},{"content":"In my opinion, the power of Emacs is that you\u0026rsquo;re able to program your own working environment. Other editors may be just as, or possibly more, efficient to use, but I haven\u0026rsquo;t come across any that give you control over as many aspects of your editor as Emacs does. Customising and tweaking your configuration may be an endless endeavour, but it\u0026rsquo;s also a highly rewarding one.\nAll that being said, I was inspired to tweak the look of my Org Mode setup, especially after reading the blog post Beautifying Org Mode in Emacs. Below you can find screenshots and code. I hope there\u0026rsquo;s something in here that you might want to steal for your own config! In case I change these settings later, my most recently updated config is always available on my GitHub.\nTheme The easiest and quickest way to change the look of vanilla Emacs is to load a colour theme. I\u0026rsquo;m using the doom-nord theme, which is part of the doom-themes package. I find both it and several of the other themes from that pack to be excellent.\nYou can find an updated list of themes on emacsthemes.com where they have screenshots. From spending time on the Emacs subreddit, I also know that people are very fond of Prot\u0026rsquo;s Modus and Ef themes, as well as the built-in leuven theme. Feel free to play around!\nFonts Next up is setting up variable-pitch and fixed-pitch fonts. I love Roboto Mono and I use a ligaturised version of it for programming, from the a-better-ligaturizer project. Here, I\u0026rsquo;ll add that a package such as ligature.el is required to display the ligatures.\nFor variable-pitch (regular) text, I want to use Source Sans Pro.\nIn my Emacs config, I have set these fonts outside the Org section, under \u0026ldquo;Interaction, Look \u0026amp; Feel\u0026rdquo;.\n(when (member \u0026#34;Roboto Mono\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;default nil :font \u0026#34;Roboto Mono\u0026#34; :height 108) (set-face-attribute \u0026#39;fixed-pitch nil :family \u0026#34;Roboto Mono\u0026#34;)) (when (member \u0026#34;Source Sans Pro\u0026#34; (font-family-list)) (set-face-attribute \u0026#39;variable-pitch nil :family \u0026#34;Source Sans Pro\u0026#34; :height 1.18)) Then, back in the Org-specific part of the config, I resize the Org headings and choose Source Sans Pro to be the header font.\n;; Resize Org headings (dolist (face \u0026#39;((org-level-1 . 1.35) (org-level-2 . 1.3) (org-level-3 . 1.2) (org-level-4 . 1.1) (org-level-5 . 1.1) (org-level-6 . 1.1) (org-level-7 . 1.1) (org-level-8 . 1.1))) (set-face-attribute (car face) nil :font \u0026#34;Source Sans Pro\u0026#34; :weight \u0026#39;bold :height (cdr face))) ;; Make the document title a bit bigger (set-face-attribute \u0026#39;org-document-title nil :font \u0026#34;Source Sans Pro\u0026#34; :weight \u0026#39;bold :height 1.8) In order to avoid line spacing issues when a line of text contains both variable- and fixed-pitch text, we need to make sure that the org-indent face inherits from fixed-pitch.\n(require \u0026#39;org-indent) (set-face-attribute \u0026#39;org-indent nil :inherit \u0026#39;(org-hide fixed-pitch)) And then, we want to make sure that some parts of the Org document always use fixed-pitch even when variable-pitch-mode is on.\n(set-face-attribute \u0026#39;org-block nil :foreground nil :inherit \u0026#39;fixed-pitch :height 0.85) (set-face-attribute \u0026#39;org-code nil :inherit \u0026#39;(shadow fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-indent nil :inherit \u0026#39;(org-hide fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-verbatim nil :inherit \u0026#39;(shadow fixed-pitch) :height 0.85) (set-face-attribute \u0026#39;org-special-keyword nil :inherit \u0026#39;(font-lock-comment-face fixed-pitch)) (set-face-attribute \u0026#39;org-meta-line nil :inherit \u0026#39;(font-lock-comment-face fixed-pitch)) (set-face-attribute \u0026#39;org-checkbox nil :inherit \u0026#39;fixed-pitch) For this all to come together, we need to make sure that variable-pitch-mode is always active in Org buffers.\n(add-hook \u0026#39;org-mode-hook \u0026#39;variable-pitch-mode) Also, if you\u0026rsquo;re having troubles with the size of LaTeX-previews like I did, you can increase the size like so.\n(plist-put org-format-latex-options :scale 2) Decluttering We\u0026rsquo;ll use \u0026ldquo;pretty entities\u0026rdquo;, which allow us to insert special characters LaTeX-style by using a leading backslash (e.g., \\alpha to write the greek letter alpha). org-ellipsis is the symbol displayed after an Org-heading that is collapsed - I prefer a simple dot.\n(setq org-adapt-indentation t org-hide-leading-stars t org-pretty-entities t org-ellipsis \u0026#34; ¬∑\u0026#34;) For source code blocks specifically, I want Org to display the contents using the major mode of the relevant language. I also want TAB to behave inside the source code block like it normally would when writing code in that language.\n(setq org-src-fontify-natively t org-src-tab-acts-natively t org-edit-src-content-indentation 0) It\u0026rsquo;s common to hide emphasis markers (e.g., /.../ for italics, *...* for bold, etc.) to have a cleaner visual look, but this makes it harder to edit the text. org-appear is the solution to all my troubles. It displays the markers when the cursor is within them and hides them otherwise, making edits easy while looking pretty.\n(use-package org-appear :commands (org-appear-mode) :hook (org-mode . org-appear-mode) :config (setq org-hide-emphasis-markers t) ; Must be activated for org-appear to work (setq org-appear-autoemphasis t ; Show bold, italics, verbatim, etc. org-appear-autolinks t ; Show links org-appear-autosubmarkers t)) ; Show sub- and superscripts And finally, I have some Org options to deal with headers and TODO\u0026rsquo;s nicely.\n(setq org-log-done t org-auto-align-tags t org-tags-column -80 org-fold-catch-invisible-edits \u0026#39;show-and-error org-special-ctrl-a/e t org-insert-heading-respect-content t) LaTeX Previews The LaTeX previews in Org mode are pretty small by default, so I\u0026rsquo;ll increase their size a little.\n(plist-put org-format-latex-options :scale 1.35) org-fragtog works like org-appear, but for LaTeX fragments: It toggles LaTeX previews on and off automatically, depending on the cursor position. If you move the cursor to a preview, it\u0026rsquo;s toggled off so you can edit the LaTeX snippet. When you move the cursor away, the preview is turned on again.\n(use-package org-fragtog :hook (org-mode-hook . org-fragtog-mode)) Centring \u0026amp; Line Breaks I want the text to fill the screen adaptively, so that long lines of text adapt to the size of the window. It also breaks lines instead of truncating them.\n(add-hook \u0026#39;org-mode-hook \u0026#39;visual-line-mode) I prefer having my Org buffer centred. I think it looks prettier when I only have one buffer open, and it\u0026rsquo;s barely noticeable when several are open because the width of the margins adapt. For this, I use Olivetti, which I think is a great package for this purpose.\n(add-hook \u0026#39;org-mode-hook \u0026#39;olivetti-mode) As you can see in the below screenshot, the Org document fills up the left side of the screen comfortably even when olivetti-mode is on.\nTask \u0026amp; Time Tracking Org mode is also a really powerful tool for tracking tasks and time usage. However, the default colours don\u0026rsquo;t go too well with our new look.\nOf course, you should change the keywords and the number of priorities to suit your tastes. I have lifted my colours straight from the official Nord theme pallette so that they go well with my preferred theme.\nLet\u0026rsquo;s set the number of task priorities and specify the colour for each priority.\n(setq org-lowest-priority ?F) ;; Gives us priorities A through F (setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E]. (setq org-priority-faces \u0026#39;((65 . \u0026#34;#BF616A\u0026#34;) (66 . \u0026#34;#EBCB8B\u0026#34;) (67 . \u0026#34;#B48EAD\u0026#34;) (68 . \u0026#34;#81A1C1\u0026#34;) (69 . \u0026#34;#5E81AC\u0026#34;) (70 . \u0026#34;#4C566A\u0026#34;))) And then the custom keywords.\n(setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO(t)\u0026#34; \u0026#34;WAIT(w)\u0026#34; \u0026#34;READ(r)\u0026#34; \u0026#34;PROG(p)\u0026#34; ; Needs further action \u0026#34;|\u0026#34; \u0026#34;DONE(d)\u0026#34;))) ; Needs no action currently I don\u0026rsquo;t set the colours of each TODO state individually anymore, but if you wanted to, you could set the org-todo-keyword-faces variable like this:\n(setq org-todo-keyword-faces \u0026#39;((\u0026#34;TODO(t)\u0026#34; :inherit (org-todo region) :foreground \u0026#34;#A3BE8C\u0026#34; :weight bold) ...)) Bullets org-superstar styles some of my UI elements, such as bullets and special checkboxes for TODOs. It can style a lot more, so I recommend checking the package out!\n(use-package org-superstar :config (setq org-superstar-leading-bullet \u0026#34; \u0026#34;) (setq org-superstar-headline-bullets-list \u0026#39;(\u0026#34;‚óâ\u0026#34; \u0026#34;‚óã\u0026#34; \u0026#34;‚ö¨\u0026#34; \u0026#34;‚óà\u0026#34; \u0026#34;‚óá\u0026#34;)) (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes (setq org-superstar-todo-bullet-alist \u0026#39;((\u0026#34;TODO\u0026#34; . 9744) (\u0026#34;WAIT\u0026#34; . 9744) (\u0026#34;READ\u0026#34; . 9744) (\u0026#34;PROG\u0026#34; . 9744) (\u0026#34;DONE\u0026#34; . 9745))) :hook (org-mode . org-superstar-mode)) SVG Elements I use svg-tag-mode to replace progress bars, task priorities, dates, and citations with nice SVG graphics. This package can also style many more elements and I\u0026rsquo;d encourage you to read the documentation to find other things you might want to style with this.\n(use-package svg-tag-mode :config (defconst date-re \u0026#34;[0-9]\\\\{4\\\\}-[0-9]\\\\{2\\\\}-[0-9]\\\\{2\\\\}\u0026#34;) (defconst time-re \u0026#34;[0-9]\\\\{2\\\\}:[0-9]\\\\{2\\\\}\u0026#34;) (defconst day-re \u0026#34;[A-Za-z]\\\\{3\\\\}\u0026#34;) (defconst day-time-re (format \u0026#34;\\\\(%s\\\\)? ?\\\\(%s\\\\)?\u0026#34; day-re time-re)) (defun svg-progress-percent (value) (svg-image (svg-lib-concat (svg-lib-progress-bar (/ (string-to-number value) 100.0) nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11) (svg-lib-tag (concat value \u0026#34;%\u0026#34;) nil :stroke 0 :margin 0)) :ascent \u0026#39;center)) (defun svg-progress-count (value) (let* ((seq (mapcar #\u0026#39;string-to-number (split-string value \u0026#34;/\u0026#34;))) (count (float (car seq))) (total (float (cadr seq)))) (svg-image (svg-lib-concat (svg-lib-progress-bar (/ count total) nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11) (svg-lib-tag value nil :stroke 0 :margin 0)) :ascent \u0026#39;center))) (setq svg-tag-tags `( ;; Task priority (\u0026#34;\\\\[#[A-Z]\\\\]\u0026#34; . ( (lambda (tag) (svg-tag-make tag :face \u0026#39;org-priority :beg 2 :end -1 :margin 0)))) ;; Progress (\u0026#34;\\\\(\\\\[[0-9]\\\\{1,3\\\\}%\\\\]\\\\)\u0026#34; . ((lambda (tag) (svg-progress-percent (substring tag 1 -2))))) (\u0026#34;\\\\(\\\\[[0-9]+/[0-9]+\\\\]\\\\)\u0026#34; . ((lambda (tag) (svg-progress-count (substring tag 1 -1))))) ;; Citation of the form [cite:@Knuth:1984] (\u0026#34;\\\\(\\\\[cite:@[A-Za-z]+:\\\\)\u0026#34; . ((lambda (tag) (svg-tag-make tag :inverse t :beg 7 :end -1 :crop-right t)))) (\u0026#34;\\\\[cite:@[A-Za-z]+:\\\\([0-9]+\\\\]\\\\)\u0026#34; . ((lambda (tag) (svg-tag-make tag :end -1 :crop-left t)))) ;; Active date (with or without day name, with or without time) (,(format \u0026#34;\\\\(\u0026lt;%s\u0026gt;\\\\)\u0026#34; date-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1 :margin 0)))) (,(format \u0026#34;\\\\(\u0026lt;%s \\\\)%s\u0026gt;\u0026#34; date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0)))) (,(format \u0026#34;\u0026lt;%s \\\\(%s\u0026gt;\\\\)\u0026#34; date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0)))) ;; Inactive date (with or without day name, with or without time) (,(format \u0026#34;\\\\(\\\\[%s\\\\]\\\\)\u0026#34; date-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1 :margin 0 :face \u0026#39;org-date)))) (,(format \u0026#34;\\\\(\\\\[%s \\\\)%s\\\\]\u0026#34; date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face \u0026#39;org-date)))) (,(format \u0026#34;\\\\[%s \\\\(%s\\\\]\\\\)\u0026#34; date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face \u0026#39;org-date))))))) (add-hook \u0026#39;org-mode-hook \u0026#39;svg-tag-mode) Prettify Tags \u0026amp; Keywords I have a custom function to prettify tags and other elements, lifted from Jake B\u0026rsquo;s Emacs setup.\n(defun my/prettify-symbols-setup () ;; Checkboxes (push \u0026#39;(\u0026#34;[ ]\u0026#34; . \u0026#34;ÓôÄ\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;[X]\u0026#34; . \u0026#34;Ôíß\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;[-]\u0026#34; . \u0026#34;ÔìÉ\u0026#34; ) prettify-symbols-alist) ;; org-abel (push \u0026#39;(\u0026#34;#+BEGIN_SRC\u0026#34; . ?‚â´) prettify-symbols-alist) (push \u0026#39;(\u0026#34;#+END_SRC\u0026#34; . ?‚â´) prettify-symbols-alist) (push \u0026#39;(\u0026#34;#+begin_src\u0026#34; . ?‚â´) prettify-symbols-alist) (push \u0026#39;(\u0026#34;#+end_src\u0026#34; . ?‚â´) prettify-symbols-alist) (push \u0026#39;(\u0026#34;#+BEGIN_QUOTE\u0026#34; . ?‚ùù) prettify-symbols-alist) (push \u0026#39;(\u0026#34;#+END_QUOTE\u0026#34; . ?‚ùû) prettify-symbols-alist) ;; Drawers (push \u0026#39;(\u0026#34;:PROPERTIES:\u0026#34; . \u0026#34;Ó≠í\u0026#34;) prettify-symbols-alist) ;; Tags (push \u0026#39;(\u0026#34;:projects:\u0026#34; . \u0026#34;ÔÄ≠\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:work:\u0026#34; . \u0026#34;ÔÄ≠\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:inbox:\u0026#34; . \u0026#34;ÔêØ\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:task:\u0026#34; . \u0026#34;ÔÄú\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:thesis:\u0026#34; . \u0026#34;Ôëà\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:uio:\u0026#34; . \u0026#34;Ôëà\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:emacs:\u0026#34; . \u0026#34;Óò≤\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:learn:\u0026#34; . \u0026#34;ÓàØ\u0026#34;) prettify-symbols-alist) (push \u0026#39;(\u0026#34;:code:\u0026#34; . \u0026#34;Ôíâ\u0026#34;) prettify-symbols-alist) (prettify-symbols-mode)) (add-hook \u0026#39;org-mode-hook #\u0026#39;my/prettify-symbols-setup) (add-hook \u0026#39;org-agenda-mode-hook #\u0026#39;my/prettify-symbols-setup) After all this prettification, TODOs, code blocks, and lists look like screenshot below.\nConclusion There it is, that\u0026rsquo;s pretty much all of the visual Org-specific code in my config. If you\u0026rsquo;re interested in other aspects of my config, you\u0026rsquo;re of course welcome to check it out. I\u0026rsquo;m just starting out, so I\u0026rsquo;d also really appreciate constructive criticism or tips!\n","permalink":"http://localhost:1313/posts/prettifying-emacs-org-mode/","summary":"\u003cp\u003eIn my opinion, the power of Emacs is that you\u0026rsquo;re able to program your own\nworking environment. Other editors may be just as, or possibly more, efficient\nto use, but I haven\u0026rsquo;t come across any that give you control over as many aspects\nof your editor as Emacs does. Customising and tweaking your configuration may be an\nendless endeavour, but it\u0026rsquo;s also a highly rewarding one.\u003c/p\u003e\n\u003cp\u003eAll that being said, I was inspired to tweak the look of my Org Mode setup,\nespecially after reading the blog post\n\u003ca href=\"https://zzamboni.org/post/beautifying-org-mode-in-emacs/\"\u003eBeautifying\nOrg Mode in Emacs\u003c/a\u003e. Below you can find screenshots and code. I\nhope there\u0026rsquo;s something in here that you might want to steal for your own config!\nIn case I change these settings later, my most recently updated config is always\navailable on my \u003ca href=\"https://github.com/SophieBosio/.emacs.d\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e","title":"Prettifying Emacs Org Mode"},{"content":"I\u0026rsquo;m Sophie! I was born in Oslo in 1999, and after some moving back and forth for my studies, I\u0026rsquo;m back in my home city.\nI\u0026rsquo;m very interested in programming, coffee, natural languages, and music.\nCurrently, I\u0026rsquo;m working as a software engineer at Ardoq.\nI recently graduated with an MSc from the University of Oslo, where I wrote my thesis on property-based testing. I designed and implemented a small functional language called Contra, which has native support for defining properties and a built-in property-checker. It\u0026rsquo;s capable of automatically generating counterexamples, even for user-defined algebraic data types, using SMT solving.\nI implemented Contra in Haskell and at work, I\u0026rsquo;m getting to love Clojure. I\u0026rsquo;m generally interested in functional programming languages - bonus if there\u0026rsquo;s a nice Emacs mode for it!\nBesides programming languages, I am also known to occasionally nerd out about natural languages. In addition to Norwegian and English, I speak French and Italian reasonably well.\nIf you want to reach me, you\u0026rsquo;re welcome to do so via my UiO email at sabosio@uio.no, my personal email sophie.bosio@outlook.com, or through my GitHub ‚ú®\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003eI\u0026rsquo;m Sophie! I was born in Oslo in 1999, and after some moving back and forth\nfor my studies, I\u0026rsquo;m back in my home city.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m very interested in programming, coffee, natural languages, and music.\u003c/p\u003e\n\u003cp\u003eCurrently, I\u0026rsquo;m working as a software engineer at \u003ca href=\"https://www.ardoq.com/\"\u003eArdoq\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eI recently graduated with an MSc from the University of Oslo, where I wrote my thesis on \u003ca href=\"https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237\"\u003eproperty-based\ntesting\u003c/a\u003e. I designed and implemented a small functional language called \u003ca href=\"https://github.com/SophieBosio/contra\"\u003eContra\u003c/a\u003e, which has native support for defining properties and a built-in property-checker. It\u0026rsquo;s capable of automatically generating counterexamples, even for user-defined algebraic data types, using SMT solving.\u003c/p\u003e","title":"About"},{"content":"This website is built with Hugo and ox-hugo, an exporting engine that lets me write my posts in Org mode and then put it online easily.\nOrg mode is a really clever and powerful plain text format that works great for note taking, text editing, and TODO lists/agendas. Moreover, there are a lot of convenient features for us Emacs users when using ox-hugo to write our blogs (besides staying in the comfort of a well-known format and editing flow).\nFor example, I can use this code snippet from ox-hugo\u0026rsquo;s blog as a template to create a new blog post and bind it to a key combination in my Emacs configuration:\n(with-eval-after-load \u0026#39;org-capture (defun org-hugo-new-subtree-post-capture-template () \u0026#34;Returns `org-capture\u0026#39; template string for new Hugo post. See `org-capture-templates\u0026#39; for more information.\u0026#34; (let* ((title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #\u0026#39;identity `( ,(concat \u0026#34;* TODO \u0026#34; title) \u0026#34;:PROPERTIES:\u0026#34; ,(concat \u0026#34;:EXPORT_FILE_NAME: \u0026#34; fname) \u0026#34;:END:\u0026#34; \u0026#34;%?\\n\u0026#34;) ;Place the cursor here finally \u0026#34;\\n\u0026#34;))) (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;h\u0026#34; ;`org-capture\u0026#39; binding + h \u0026#34;Hugo post\u0026#34; entry (file \u0026#34;~/path/to/your/all-posts.org\u0026#34;) (function org-hugo-new-subtree-post-capture-template)))) ","permalink":"http://localhost:1313/posts/hugo/","summary":"\u003cp\u003eThis website is built with \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e and \u003ca href=\"https://ox-hugo.scripter.co/\"\u003e\u003ccode\u003eox-hugo\u003c/code\u003e\u003c/a\u003e, an exporting engine that lets me\nwrite my posts in \u003ca href=\"https://orgmode.org/\"\u003eOrg mode\u003c/a\u003e and then put it online easily.\u003c/p\u003e\n\u003cp\u003eOrg mode is a really clever and powerful plain text format that works great for note\ntaking, text editing, and TODO lists/agendas. Moreover, there are a lot of\nconvenient features for us Emacs users when using \u003ccode\u003eox-hugo\u003c/code\u003e to write our blogs\n(besides staying in the comfort of a well-known format and editing flow).\u003c/p\u003e","title":"Static Site Generation with Hugo"},{"content":"DONE Education MSc I have a master\u0026rsquo;s degree in Programming and System Architecture from the University of Oslo, Norway, with a specialisation in software. üå±\nMy thesis project and thesis text are available on GitHub.\nThe courses I have taken at UiO are briefly summarised below.\nCourses in Programming and System Architecture at UiO (in order of attendance)\rIN5130 - Modelling Unassailable IT-Systems IN5170 - Models of Concurrency TEK5510 - Security in Operating Systems and Software IN5570 - Distributed Objects IN5580 - Computability Theory INF5110 - Compiler Construction Special Curriculum - Advanced Functional Programming, Semantics, and Types BSc I have a bachelor\u0026rsquo;s degree in Cognitive Science from the University of Bergen, Norway.\nThe full course plan for the degree can be found at the university\u0026rsquo;s websites, but unfortunately, the relevant plan (admission in 2019) is only available in Norwegian.\nMost of the course pages do however have an English version. A brief overview with links is provided below for the reader\u0026rsquo;s convenience. Programming languages used in the courses have been added in parentheses where relevant.\nDuring my BSc, I had an exchange semester at the University of Bologna, Italy. The relevant courses from my exchange are appended to the list.\nCourses in Cognitive Science at UiB (in order of attendance)\rKOGVIT101 - Introduction to Cognitive Science INF100 - Introduction to Programming (Python) EXFAC00SK - Basic Linguistics DASPSTAT - Statistics for Cognitive Science LOG110 - Introduction to Formal Logic LOG111 - Deduction and Meta-Logic INF101 - Object-Oriented Programming (Java) LING122 - Languages and Cognition INFO282 - Knowledge Representation and Reasoning (Prolog) INF122 - Functional Programming (Haskell) FIL105 - Philosophy of Mind PSYK120 - Biological and Cognitive Psychology EXPHIL-PSSEM - Examen Facultatum in Psychology INFO135 - Advanced Programming (Algorithms, Data Structures, and Programming) (Python) INF223 - Category Theory INF227 - Mathematical Logic MAT121 - Linear Algebra And instead of the following courses (left), I had the equivalent courses at the University of Bologna (right):\nMAT111 -\u0026gt; 79184 - Calculus I INF102 -\u0026gt; 91256 - Algorithms and Programming (Python) Free credits -\u0026gt; 90106 - Ingegneria del Software (JavaScript) ","permalink":"http://localhost:1313/education/","summary":"\u003ch2 id=\"education\"\u003e\u003cspan class=\"org-todo done DONE\"\u003eDONE\u003c/span\u003e Education\u003c/h2\u003e\n\u003ch3 id=\"msc\"\u003eMSc\u003c/h3\u003e\n\u003cp\u003eI have a master\u0026rsquo;s degree in \u003ca href=\"https://www.uio.no/studier/program/informatikk-programmering-master/\"\u003eProgramming and System Architecture\u003c/a\u003e from the \u003ca href=\"https://www.uio.no/\"\u003eUniversity of Oslo\u003c/a\u003e, Norway, with a specialisation in software. üå±\u003c/p\u003e\n\u003cp\u003eMy thesis project and thesis text are available on \u003ca href=\"https://github.com/SophieBosio/contra\"\u003eGitHub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe courses I have taken at UiO are briefly summarised below.\u003c/p\u003e\n\u003cdetails\u003e\r\n\u003csummary\u003eCourses in Programming and System Architecture at UiO (in order of attendance)\u003c/summary\u003e\r\n\u003cdiv class=\"details\"\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/ifi/IN5130/index-eng.html\"\u003eIN5130\u003c/a\u003e - Modelling Unassailable IT-Systems\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/ifi/IN5170/index-eng.html\"\u003eIN5170\u003c/a\u003e - Models of Concurrency\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/its/TEK5510/index-eng.html\"\u003eTEK5510\u003c/a\u003e - Security in Operating Systems and Software\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/ifi/IN5570/index-eng.html\"\u003eIN5570\u003c/a\u003e - Distributed Objects\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/ifi/IN5580/\"\u003eIN5580\u003c/a\u003e - Computability Theory\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.uio.no/studier/emner/matnat/ifi/INF5110/\"\u003eINF5110\u003c/a\u003e - Compiler Construction\u003c/li\u003e\n\u003cli\u003eSpecial Curriculum - Advanced Functional Programming, Semantics, and Types\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\r\n\u003c/details\u003e\r\n\u003ch3 id=\"bsc\"\u003eBSc\u003c/h3\u003e\n\u003cp\u003eI have a bachelor\u0026rsquo;s degree in \u003ca href=\"https://www.uib.no/en/studies/BASV-KOGNI\"\u003eCognitive Science\u003c/a\u003e from the \u003ca href=\"https://www.uib.no/\"\u003eUniversity of Bergen\u003c/a\u003e, Norway.\u003c/p\u003e","title":""},{"content":"Zachary Tellman opens his book Elements of Clojure by explaining the concept of tacit knowledge. Paraphrasing, it\u0026rsquo;s all the innate/implicit/subconscious knowledge that we have acquired through experience and, because we didn\u0026rsquo;t learn it in a straightforward manner ourselves, often struggle to explain clearly to others. The result is that others, too, have to go through a frustrating and non-linear process to learn it.\nI think this is what often happens with monads, which mystify and confuse a lot of people. If they\u0026rsquo;re like me, it\u0026rsquo;s because they\u0026rsquo;re ambushed by it while checking out a purely functional language like Haskell for the first time.\nMaybe they get curious about it, but Googling the topic leaves them just as confused \u0026ndash; many of the explanations found are either terminology-heavy or overly simplified. Typically definitions range between \u0026ldquo;a monad is a monoid in the category of endofunctors\u0026rdquo; on one end and \u0026ldquo;a burrito!\u0026rdquo; on the other. Neither is particularly helpful for learners.\nI think this happens because people who understand monads struggle to communicate their tacit knowledge, which leads to people trying to learn becoming frustrated!\nAnd that\u0026rsquo;s a shame. I think we should be able to teach and learn about monads without this much pain. I won\u0026rsquo;t pretend I understand monads completely (for example, I haven\u0026rsquo;t looked into their applications in mathematics), but the way we tend to use monads in computer science isn\u0026rsquo;t all that crazy. So in this blog series, we\u0026rsquo;ll have a closer look at the humble monad.\nI personally feel a need to know where a concept came from and why I should bother with it. So in this first part, I\u0026rsquo;ll cover some of the theory behind monads. In Part 2, we\u0026rsquo;ll roll up our shirt sleeves, incrementally implement our own monad, and finally see that theory in action. Finally, in Part 3, we\u0026rsquo;ll implement a couple of famous monads for fun and I\u0026rsquo;ll provide some resources for further reading.\nIf you\u0026rsquo;re just interested in the application of monads or you\u0026rsquo;re already familiar with the theory, then you have my blessing to jump right to Part 2. Otherwise, let\u0026rsquo;s dive in!\nWhat is a Monad? The monad is a concept from a formalism called category theory.\nJust like set theory, category theory has applications in both mathematics and computer science. Category theory is the study of mathematical structures. Informally speaking, the category theorist wants to know:\nIf different mathematical concepts have similarities, what are their commonalities? Can we make out the general, shared structure? What properties does this generalised structure have? How are different generalised structures related to one another? This all sounds abstract because it is. Category theory is sometimes referred to as the \u0026ldquo;mathematics of mathematics\u0026rdquo;. But here, we\u0026rsquo;ll just dip our toes into the stuff I think is useful to us right now, and the rest you can read about later if you\u0026rsquo;re interested.\nNow, when we prove a property of a generalised structure, that property holds true for all the specific cases, too. Turns out this is really useful! And a lot of the mathematical concepts we use in programming are specific cases like these.\nAs you might already have guessed, monads are one of these general structures that we actually use all the time. For example, lists are monads! Consider that a teaser for Part 3.\nOkay, now we\u0026rsquo;ve covered some theoretical grounds. Before we jump into more theory, I think now is a good time to explain why we\u0026rsquo;re even interested in monads in the first place. They\u0026rsquo;re not just a source of factoids about things we already know how to use, like lists, but a pretty neat design pattern that we can use to structure our code.\nPure Functions (Or, Why Use Monads?) The need for monads (or some alternative) is mostly in purely functional programming languages. This being said, monads are language agnostic and can be used to great effect regardless. A monad in Haskell is the same as a monad in Typescript.\nBut back to our motivation.\nA purely functional programming language only allows you to write pure functions. There are many equivalent ways of defining pure functions. I find it useful to think of it as a mapping between outputs and inputs: Each input is mapped to one and only one output, and the function does nothing else. The function is defined entirely by its definition \u0026ndash; nothing else can affect what the function does.\nThe fact that calling a function on a given input returns the same output every time you call it, is called referential transparency. It means that anywhere in your code, you can replace a given function call with its result and vice versa without changing the semantics of your code.\n-- This program \u0026#34;I\u0026#39;m \u0026#34; ++ show (99 + 1) ++ \u0026#34; years old!\u0026#34; -- is exactly equivalent to this program \u0026#34;I\u0026#39;m \u0026#34; ++ show 100 ++ \u0026#34; years old!\u0026#34; But, borrowing an example from Tellman, if we have a strange definition of + that first sends out an email and then adds our two numbers together, the two programs above aren\u0026rsquo;t equivalent anymore!\nPure functions therefore cannot perform side-effects, such as sending emails or generally, reading from or writing to a mutable variable/state/context.\nI cannot call a function on Monday and get one result, then call it on Tuesday and get a different result because a variable changed in the meantime.\n-- \u0026#39;punctuation\u0026#39; is a variable defined elsewhere ageInfo age = \u0026#34;I\u0026#39;m \u0026#34; ++ age ++ \u0026#34; years old\u0026#34; ++ punctuation -- On Monday: ghci\u0026gt; ageInfo 100 \u0026#34;I\u0026#39;m 100 years old!\u0026#34; -- On Tuesday: ghci\u0026gt; ageInfo 100 \u0026#34;I\u0026#39;m 100 years old???\u0026#34; Another way to say this, is that a pure function cannot have any side effects. These include things like updating a mutable variable, but also reading from and writing to the terminal.\nA read from the terminal is a function call that receives some of its input at runtime and the exact same program may return different results. The definition of the function does therefore not define its behaviour completely \u0026ndash; it also depends on non-deterministic user input. Just like reading from a mutable variable, this breaks the rules.\ngreet = do name \u0026lt;- getLine -- Read a line of input, save in the variable \u0026#39;name\u0026#39; putStrLn \u0026#34;Hello, \u0026#34; ++ name -- Print greeting with supplied \u0026#39;name\u0026#39; -- Alice is using the computer: ghci\u0026gt; greet Alice -- User inputs \u0026#34;Alice\u0026#34; Hello, Alice -- Bella is using the computer: ghci\u0026gt; greet \u0026#34;Bella\u0026#34; Bella -- User inputs \u0026#34;Bella\u0026#34; Hello, Bella A write to the terminal appends line(s) of text to the bottom of whatever text was there before. Therefore, writing to the terminal is like updating an existing, mutable variable. Therefore, its behaviour depends on the current state of the terminal output and will change between calls. Also illegal!\nJust like a function call that returns a value can be replaced with that value, a pure function definition can be replaced with its definition. In other words, pure functions are immutable declarations that we can safely use in and compose with other pure functions. Therefore, a pure function can use other pure functions. The programs below are equivalent.\ncompute x = ((2 * x) + 40) -- is equivalent to double x = (2 * x) compute x = (double x) + 40 -- is equivalent to double x = (2 * x) plusForty x = x + 40 compute = plusForty . double -- Read \u0026#34;plusForty\u0026#34; after \u0026#34;double\u0026#34; But the second we use an impure function in our chain of pure functions, the whole thing becomes impure.\nAll this function purity may sound a bit restrictive, but it makes it super easy to reason about our code and to test it. Because each small function is a simple mapping from input to output, we can compose functions with confidence and quickly experiment or write tests to check that our function actually does what we expect. Composition is the core of functional programming!\nWe prefer to use pure functions as much as possible. The \u0026ldquo;meat\u0026rdquo; of our program should preferably consist of concise, pure functions that we compose to get bigger and more complex, pure functions. But at some point, we need to deal with stateful computation. Either because of the domain we\u0026rsquo;re dealing with or simply because we want to print to the terminal!\nThis is where monads come in: We can use monads to model stateful computations in a purely functional way!\nThe Case For Monads For now, you can think of a monad as a strict interface that defines how you can read from/write to state in your computations. The monad defines what operations are permissible and how to chain together stateful computations.\nNow, if we can use monads to perform stateful computations, then we can break the guarantees that functional programming gives us (confidence and composability) so why not just use an imperative language with mutable variables?\nMonads deal with immutable data structures and define explicitly wh\nA Taste of Category Theory ","permalink":"http://localhost:1313/posts/demystifying-monads-1/","summary":"\u003cp\u003eZachary Tellman opens his book \u003cem\u003eElements of Clojure\u003c/em\u003e by explaining the concept of \u003cem\u003etacit knowledge\u003c/em\u003e. Paraphrasing, it\u0026rsquo;s all the innate/implicit/subconscious knowledge that we have acquired through experience and, because we didn\u0026rsquo;t learn it in a straightforward manner ourselves, often struggle to explain clearly to others. The result is that others, too, have to go through a frustrating and non-linear process to learn it.\u003c/p\u003e\n\u003cp\u003eI think this is what often happens with monads, which mystify and confuse a lot of people. If they\u0026rsquo;re like me, it\u0026rsquo;s because they\u0026rsquo;re ambushed by it while checking out a purely functional language like Haskell for the first time.\u003c/p\u003e","title":"Demystifying Monads - Part 1/3"},{"content":"In the previous entry of this blog post series, we covered some of the theory of monads and motivated their use in the general case. This time, we\u0026rsquo;ll take a crack at a practical example.\nWe\u0026rsquo;ll implement our own, specialised version of the Writer monad. My explanation takes lots of inspiration from the videos \u0026hellip; and \u0026hellip;, both available on YouTube.\nWe\u0026rsquo;ll start with a practical example and incrementally work our way to a complete monad. Once we\u0026rsquo;ve seen how one monad works, I want to show how we can generalise the monad pattern to solve different problems. But that deserves its own blog post, so we\u0026rsquo;ll save it for Part 3 of this series.\nI\u0026rsquo;ll be using Haskell in the code examples below, but I\u0026rsquo;ll try my best to explain concepts underway so you can follow along even if you haven\u0026rsquo;t used Haskell before.\nA Running Example Say you have two pure functions, inc and sqr, that increments and squares a number, respectively. It takes an Int and returns an Int. In Haskell, this is what it would look like:\ninc :: Int -\u0026gt; Int -- Type signature inc a = a + 1 -- Implementation sqr :: Int -\u0026gt; Int sqr a = a * a Now say we want to add logging to each function so that we can run a computation like this:\nIncrement 5 Increment the previous result Square the previous result Increment the previous result Let our log be a list of strings.\ndata Log = [String] The final result should give us both the number and the following log:\n[\u0026#34;Incremented 5\u0026#34;, \u0026#34;Incremented 6\u0026#34;, \u0026#34;Squared 7\u0026#34;, \u0026#34;Incremented 49\u0026#34;] If we pretend Haskell is an imperative language, we could imagine that we had a mutable variable log that we could append to. Let\u0026rsquo;s just take the case of inc, since the procedure would be the same for sqr.\nlog :: [String] log = [] inc :: Int -\u0026gt; Int inc a = log += \u0026#34;Incremented \u0026#34; ++ show a return (a + 1) This function would no longer be pure and it would be impossible from the call site to see that it modified the log.\nIn Haskell, it is also illegal. Our function can only know about what is immutable or explicitly passed to it as an argument.\nTo fix this, we could also take the old log as argument and return the new log. Our new function takes and returns a tuple with an integer and a log.\nNOTE:\nIn Haskell, you can prepend an element to a string using the cons operator : but to append, you must use the list concatenation operator ++ and append a singleton list. That\u0026rsquo;s why the string below is in square brackets.\nWe also convert integers to strings using the show operator.\ndata Log = [String] inc :: (Int, Log) -\u0026gt; (Int, Log) inc (a, oldLog) = (a + 1, oldLog ++ [\u0026#34;Incremented \u0026#34; ++ show a]) At first glance, this looks fine, right? Now our function is completely pure again!\nBut there\u0026rsquo;s a subtle problem with this approach: Why does our simple arithmetic function know about list concatenation?\nWe\u0026rsquo;re mixing concerns here, since we are both incrementing integers and adding a new log string to the existing logs.\nIf we had a bunch of functions with added logging, but realised later that we wanted a different data structure for our logs and redefined the Log data type, we would also have to change the list concatenation operator ++ in every single function definition implementing logging.\nLater, we\u0026rsquo;ll see how we can return just the string that we\u0026rsquo;d like to add to the logs. Then the concrete data structure and the operation used to accumulate the logs becomes opaque to the inc function.\nBut for now, let\u0026rsquo;s stick with the singleton list, because it will make our types a little clearer.\ninc\u0026#39; :: Int -\u0026gt; (Int, Log) inc\u0026#39; a = (a + 1, [\u0026#34;Incremented \u0026#34; ++ show a]) Nice, now we can write functions that just deal with values.\nBut now we have a new problem.\nWe can run our computations the way we want, but we need to write a new function. Let\u0026rsquo;s call it runComputations.\nIt needs to take the result from each function call and thread/pipe it to the next computation and also accumulates the log fragments. We can do this by binding each intermediary result in a let-binding.\ndata Log = [String] inc :: Int -\u0026gt; (Int, Log) inc a = (a + 1, [\u0026#34;Incremented \u0026#34; ++ show a]) sqr :: Int -\u0026gt; (Int, Log) sqr a = (a * a, [\u0026#34;Squared \u0026#34; ++ show a]) runComputations :: (Int, Log) runComputations = let (result1, log1) = inc 5 in let (result2, log2) = inc result1 in let (result3, log3) = sqr result2 in let (result4, log4) = inc result3 in (result4, log1 ++ log2 ++ log3 ++ log4) In the Haskell REPL, called GHCi, we can now run our computations and get the desired result:\nghci\u0026gt; runComputations (50, [\u0026#34;Incremented 5\u0026#34;, \u0026#34;Incremented 6\u0026#34;, \u0026#34;Squared 7\u0026#34;, \u0026#34;Incremented 49\u0026#34;]) Well, it\u0026rsquo;s pure and cleanly separates concerns, but\u0026hellip; It\u0026rsquo;s ugly and verbose. We\u0026rsquo;re binding a series of temporary variables that are only really used to thread the values to the next computations. And worse, adding a new computation in the middle of the chain requires several changes to the code.\nrunComputations :: (Int, Log) runComputations = let (result1, log1) = inc 5 in let (result2, log2) = sqr result1 in -- Add this line -- Change all temp vars in the following lines: let (result3, log3) = inc result2 in let (result4, log4) = sqr result3 in let (result5, log5) = inc result4 in -- Add an extra log fragment to the result: (result5, log1 ++ log2 ++ log3 ++ log4 ++ log5) So in essence, we\u0026rsquo;d like to compose our modified functions.\nComposing Kleisli Arrows Let\u0026rsquo;s take a cue from category theory and go abstract. Our two functions, inc and sqr are functions that originally took an integer and returned an integer. Now, we\u0026rsquo;ve proposed two modified functions, that each take an integer and return an integer plus a log string. Let\u0026rsquo;s mark the new ones with an apostrophe.\n-- Old definitions: inc :: Int -\u0026gt; Int sqr :: Int -\u0026gt; Int -- New definitions: inc\u0026#39; :: Int -\u0026gt; (Int, Log) sqr\u0026#39; :: Int -\u0026gt; (Int, Log) This kind of function, which take a type and return a type plus something extra, is an example of Kleisli arrows. An arrow is a generalisation of function-like things.\nNow, we\u0026rsquo;d like to compose these functions.\nWith the original, simple arithmetic functions, this is easy. They take and return integers, so they are trivially composable.\nBut our Kleisli arrows are harder to work with. To compose these functions, we can essentially do what we did before with the let-bindings. Instead of composing the functions themselves, we can can take the result of one function and use the next function on it.\nWe\u0026rsquo;ll take the number from the result of the previous computation and pipe it into the next computation. Then we want to bind the result of that computation to a temporary variable so that we can access the number and log string in the new result. The final result should have the new number and the concatenation of the old log strings and the new one.\nFor no particular reason, let\u0026rsquo;s use the weird symbol \u0026gt;\u0026gt;= for this operation. It\u0026rsquo;s called \u0026ldquo;bind\u0026rdquo;, and I imagine it\u0026rsquo;s because we bind the intermediary result in a temporary variable \u0026ndash; but that\u0026rsquo;s just my guess.\n(\u0026gt;\u0026gt;=) :: (Int, Log) -\u0026gt; (Int -\u0026gt; (Int, Log)) -\u0026gt; (Int, Log) (a, oldLog) \u0026gt;\u0026gt;= f = let (b, newLog) = f a in -- where f is a function like inc\u0026#39; or sqr\u0026#39; (b, oldLog ++ newLog) Sweet! Now the let-binding only exists inside this function and we can write a much nicer version of the code above where we previously had a ton of let-bindings:\nrunComputations :: (Int, Log) runComputations = inc 5 \u0026gt;\u0026gt;= sqr \u0026gt;\u0026gt;= inc \u0026gt;\u0026gt;= sqr \u0026gt;\u0026gt;= inc If we have a function that does something more, we might want to create a way for a function to return a result of the type (Int, Log) so it can be chained together with the rest of our functions.\nThis function is called \u0026ldquo;return\u0026rdquo;. Its only job is to take an integer and create a result with no new log string. When chained together with other functions with \u0026gt;\u0026gt;=, it shouldn\u0026rsquo;t change the logs and since \u0026gt;\u0026gt;= combines the old log with the new by concatenating them, our only choice is the empty list []. Concatenating a list with the empty list returns the original list, making it the identity element of lists under concatenation.\nreturn :: Int -\u0026gt; (Int, Log) return a = (a, []) Now we can create new functions that also return (Int, Log) without updating the logs.\ndouble :: Int -\u0026gt; Int double a = a * 2 plus :: Int -\u0026gt; Int -\u0026gt; Int plus a b = a + b foo :: Int -\u0026gt; (Int, Log) foo a = return (double (plus a 5)) And we can use foo in our chain of computations.\nrunComputations :: (Int, Log) runComputations = inc 5 \u0026gt;\u0026gt;= sqr \u0026gt;\u0026gt;= inc \u0026gt;\u0026gt;= sqr \u0026gt;\u0026gt;= inc \u0026gt;\u0026gt;= foo \u0026gt;\u0026gt;= -- This works now! inc A pretty good improvement.\nBut of course, we\u0026rsquo;re working with a typed language and so we\u0026rsquo;d like to create a type for all of this!\nWhat is the point of creating a type, though, when this works so well?\nAdvantages of Monads One advantage is that we can see statically that a function performs side effects and we can see this:\nIn the type signature In the definition At all its call sites Another is that with a type, we can create a strict interface of functions that interact with our log to ensure that only permitted reads and writes are possible.\nAnd finally, when something looks kind of like a monad, we benefit from actually implementing it as such, because it means that all the properties that apply to monads also apply to our type.\nDefining the LogWriter Monad Previously, we had functions that took an Int and returned a (Int, Log). Now, we\u0026rsquo;d like to create a type for the result where the \u0026ldquo;bind\u0026rdquo; and \u0026ldquo;return\u0026rdquo; functions are built into the type.\nA monad is not exactly a type, though. It\u0026rsquo;s a transformation that takes a type and creates a new type. In other words, it\u0026rsquo;s a parametrised type or a type constructor.\nIn our case, the logs are our \u0026ldquo;side-effecting\u0026rdquo; stuff and the fact that we\u0026rsquo;re doing arithmetic is incidental. Therefore, our log writing mechanisms are what constitutes our monad and Int is the type that it takes for us.\nLet\u0026rsquo;s call our monad LogWriter and let it take a type as its parameter.\nnewtype LogWriter a = ... Now, the type constructor also needs a concrete value constructor. By convention, the two use the same name. In our case, both would be LogWriter. But for the sake of clarity, let\u0026rsquo;s call the value constructor LogContainer.\nTo create a value of the type LogWriter Int, we use the LogContainer constructor to wrap a value like (5, [\u0026quot;Squared 2\u0026quot;, \u0026quot;Incremented 4\u0026quot;]). This distinguishes values of this type from just regular tuples of integers and logs.\ndata Log = [String] newtype LogWriter a = LogContainer (a, Log) newtype is a special way of creating new data types that only have one constructor and one field. Our type only has the one constructor LogWriter and a field to hold the value that\u0026rsquo;s in it. This is why we use it instead of data, which can create types with one or more constructors, each with an arbitrary number of fields.\nWe also need a way to \u0026ldquo;unwrap\u0026rdquo; our tuple from our constructor LogContainer and return the tuple it holds. In Haskell, if you have a data type with fields, you can use the special \u0026ldquo;record syntax\u0026rdquo; to name each field and automatically create getter functions for them.\nFor example, instead of defining shapes and pattern matching on them or creating getters by hand,\ndata Shape = Rectangle Float Float | Circle Float foo :: Shape -\u0026gt; Whatever foo (Rectangle height width) = ... foo (Circle radius) = ... you can instead define the type using record syntax and use the automatically created getters.\ndata Shape = Rectangle { height :: Fload, width :: Float } | Circle { radius :: Float } -- Which automatically creates these functions: height :: Shape -\u0026gt; Float height (Rectangle x _) = x width :: Shape -\u0026gt; Float height (Rectangle _ x) = x radius :: Shape -\u0026gt; Float radius (Circle x) = x We can do the same for our constructor LogContainer and create a field. It will create a function of the same name that takes a LogWriter a and returns a value of type (a, Log).\nBecause the LogWriter a input represents a whole monadic computation, we can call this field run to get a function that \u0026ldquo;runs\u0026rdquo; our computation, just like our runComputations function from earlier.\ndata Log = [String] newtype LogWriter a = LogContainer { run :: (a, Log) } Now we have a type! Next, we want to implement the functions return and \u0026gt;\u0026gt;= (bind) to make it a monad. Of course, Haskell has a typeclass for that.\nMake LogWriter Instance of the Monad Typeclass A typeclass is like an interface for types. It declares some functions that any type must implement in order to become an instance of that typeclass. For monads, these are just return and \u0026gt;\u0026gt;=.\nWe\u0026rsquo;ve already implemented those, so this should be easy peasy. Let\u0026rsquo;s just update our type signatures to use our new monad.\ninstance Monad LogWriter where return :: a -\u0026gt; LogWriter a (\u0026gt;\u0026gt;=) :: LogWriter a -\u0026gt; (a -\u0026gt; LogWriter b) -\u0026gt; (LogWriter b) return still returns a tuple with the input and an empty \u0026ldquo;log\u0026rdquo;, i.e., an empty list. The only difference now is that it also needs to use our new constructor.\ninstance Monad LogWriter where -- return :: a -\u0026gt; LogWriter a return a = LogContainer (a, []) \u0026gt;\u0026gt;= now needs to return a LogContainer-wrapped value. It also needs to unwrap the intermediary results from the LogContainer constructor to access the number and log inside. In the input, we can use pattern matching.\ninstance Monad LogWriter where -- return :: a -\u0026gt; LogWriter a return a = LogContainer (a, []) -- (\u0026gt;\u0026gt;=) :: LogWriter a -\u0026gt; (a -\u0026gt; LogWriter b) -\u0026gt; (LogWriter b) (LogContainer (a, oldLog)) \u0026gt;\u0026gt;= f = ... In the body of the function we need to bind the intermediary result of applying f to a as well. We can go about it two ways.\nEither, we can use a let-binding and pattern matching:\ninstance Monad LogWriter where -- return :: a -\u0026gt; LogWriter a return a = LogContainer (a, []) -- (\u0026gt;\u0026gt;=) :: LogWriter a -\u0026gt; (a -\u0026gt; LogWriter b) -\u0026gt; (LogWriter b) (LogContainer (a, oldLog)) \u0026gt;\u0026gt;= f = let (LogContainer (b, newLog)) = f a in LogContainer (b, oldLog ++ newLog) Or, we can use a let-binding and our run function to remove the LogContainer constructor altogether:\ninstance Monad LogWriter where -- return :: a -\u0026gt; LogWriter a return a = LogContainer (a, []) -- (\u0026gt;\u0026gt;=) :: LogWriter a -\u0026gt; (a -\u0026gt; LogWriter b) -\u0026gt; (LogWriter b) (LogContainer (a, oldLog)) \u0026gt;\u0026gt;= f = let (b, newLog) = run (f a) in LogContainer (b, oldLog ++ newLog) Next, a monad is a special case of an applicative functor. Therefore, it also needs to implement the Applicative and Functor typeclasses.\nMake LogWriter Instance of the Functor Typeclass Make LogWriter Instance of the Applicative Typeclass Using LogWriter! Different Kinds of State ","permalink":"http://localhost:1313/posts/demystifying-monads-2/","summary":"\u003cp\u003eIn the previous entry of this blog post series, we covered some of the theory of monads and motivated their use in the general case. This time, we\u0026rsquo;ll take a crack at a practical example.\u003c/p\u003e\n\u003cp\u003eWe\u0026rsquo;ll implement our own, specialised version of the Writer monad. My explanation takes lots of inspiration from the videos \u0026hellip; and \u0026hellip;, both available on YouTube.\u003c/p\u003e\n\u003cp\u003eWe\u0026rsquo;ll start with a practical example and incrementally work our way to a complete monad. Once we\u0026rsquo;ve seen how one monad works, I want to show how we can generalise the monad pattern to solve different problems. But that deserves its own blog post, so we\u0026rsquo;ll save it for Part 3 of this series.\u003c/p\u003e","title":"Demystifying Monads - Part 2/3"}]