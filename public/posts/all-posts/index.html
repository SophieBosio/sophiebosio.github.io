<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Sophie Bosio</title>
<meta name="keywords" content="">
<meta name="description" content="DONE Static Site Generation with Hugo emacs
This website is built with Hugo and ox-hugo, an exporting engine that lets me
write my posts in Org mode and then put it online easily.
Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using ox-hugo to write our blogs
(besides staying in the comfort of a well-known format and editing flow).">
<meta name="author" content="Sophie Adeline Solheim Bosio">
<link rel="canonical" href="http://localhost:1313/posts/all-posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css" integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/static/img/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/static/img/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/static/img/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/static/img/favicon.png">
<link rel="mask-icon" href="http://localhost:1313/static/img/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/all-posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="DONE Static Site Generation with Hugo emacs
This website is built with Hugo and ox-hugo, an exporting engine that lets me
write my posts in Org mode and then put it online easily.
Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using ox-hugo to write our blogs
(besides staying in the comfort of a well-known format and editing flow)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/posts/all-posts/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="DONE Static Site Generation with Hugo emacs
This website is built with Hugo and ox-hugo, an exporting engine that lets me
write my posts in Org mode and then put it online easily.
Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using ox-hugo to write our blogs
(besides staying in the comfort of a well-known format and editing flow)."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "http://localhost:1313/posts/all-posts/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "DONE Static Site Generation with Hugo emacs This website is built with Hugo and ox-hugo, an exporting engine that lets me write my posts in Org mode and then put it online easily.\nOrg mode is a really clever and powerful plain text format that works great for note taking, text editing, and TODO lists/agendas. Moreover, there are a lot of convenient features for us Emacs users when using ox-hugo to write our blogs (besides staying in the comfort of a well-known format and editing flow).\n",
  "keywords": [
    
  ],
  "articleBody": "DONE Static Site Generation with Hugo emacs This website is built with Hugo and ox-hugo, an exporting engine that lets me write my posts in Org mode and then put it online easily.\nOrg mode is a really clever and powerful plain text format that works great for note taking, text editing, and TODO lists/agendas. Moreover, there are a lot of convenient features for us Emacs users when using ox-hugo to write our blogs (besides staying in the comfort of a well-known format and editing flow).\nFor example, I can use this code snippet from ox-hugo’s blog as a template to create a new blog post and bind it to a key combination in my Emacs configuration:\n(with-eval-after-load 'org-capture (defun org-hugo-new-subtree-post-capture-template () \"Returns `org-capture' template string for new Hugo post. See `org-capture-templates' for more information.\" (let* ((title (read-from-minibuffer \"Post Title: \")) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #'identity `( ,(concat \"* TODO \" title) \":PROPERTIES:\" ,(concat \":EXPORT_FILE_NAME: \" fname) \":END:\" \"%?\\n\") ;Place the cursor here finally \"\\n\"))) (add-to-list 'org-capture-templates '(\"h\" ;`org-capture' binding + h \"Hugo post\" entry (file \"~/path/to/your/all-posts.org\") (function org-hugo-new-subtree-post-capture-template)))) DONE Prettifying Emacs Org Mode emacs In my opinion, the power of Emacs is that you’re able to program your own working environment. Other editors may be just as, or possibly more, efficient to use, but I haven’t come across any that give you control over as many aspects of your editor as Emacs does. Customising and tweaking your configuration may be an endless endeavour, but it’s also a highly rewarding one.\nAll that being said, I was inspired to tweak the look of my Org Mode setup, especially after reading the blog post Beautifying Org Mode in Emacs. Below you can find screenshots and code. I hope there’s something in here that you might want to steal for your own config! In case I change these settings later, my most recently updated config is always available on my GitHub.\nTheme The easiest and quickest way to change the look of vanilla Emacs is to load a colour theme. I’m using the doom-nord theme, which is part of the doom-themes package. I find both it and several of the other themes from that pack to be excellent.\nYou can find an updated list of themes on emacsthemes.com where they have screenshots. From spending time on the Emacs subreddit, I also know that people are very fond of Prot’s Modus and Ef themes, as well as the built-in leuven theme. Feel free to play around!\nFonts Next up is setting up variable-pitch and fixed-pitch fonts. I love Roboto Mono and I use a ligaturised version of it for programming, from the a-better-ligaturizer project. Here, I’ll add that a package such as ligature.el is required to display the ligatures.\nFor variable-pitch (regular) text, I want to use Source Sans Pro.\nIn my Emacs config, I have set these fonts outside the Org section, under “Interaction, Look \u0026 Feel”.\n(when (member \"Roboto Mono\" (font-family-list)) (set-face-attribute 'default nil :font \"Roboto Mono\" :height 108) (set-face-attribute 'fixed-pitch nil :family \"Roboto Mono\")) (when (member \"Source Sans Pro\" (font-family-list)) (set-face-attribute 'variable-pitch nil :family \"Source Sans Pro\" :height 1.18)) Then, back in the Org-specific part of the config, I resize the Org headings and choose Source Sans Pro to be the header font.\n;; Resize Org headings (dolist (face '((org-level-1 . 1.35) (org-level-2 . 1.3) (org-level-3 . 1.2) (org-level-4 . 1.1) (org-level-5 . 1.1) (org-level-6 . 1.1) (org-level-7 . 1.1) (org-level-8 . 1.1))) (set-face-attribute (car face) nil :font \"Source Sans Pro\" :weight 'bold :height (cdr face))) ;; Make the document title a bit bigger (set-face-attribute 'org-document-title nil :font \"Source Sans Pro\" :weight 'bold :height 1.8) In order to avoid line spacing issues when a line of text contains both variable- and fixed-pitch text, we need to make sure that the org-indent face inherits from fixed-pitch.\n(require 'org-indent) (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch)) And then, we want to make sure that some parts of the Org document always use fixed-pitch even when variable-pitch-mode is on.\n(set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch :height 0.85) (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch) :height 0.85) (set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch) :height 0.85) (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch) :height 0.85) (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch)) (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch)) (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch) For this all to come together, we need to make sure that variable-pitch-mode is always active in Org buffers.\n(add-hook 'org-mode-hook 'variable-pitch-mode) Also, if you’re having troubles with the size of LaTeX-previews like I did, you can increase the size like so.\n(plist-put org-format-latex-options :scale 2) Decluttering We’ll use “pretty entities”, which allow us to insert special characters LaTeX-style by using a leading backslash (e.g., \\alpha to write the greek letter alpha). org-ellipsis is the symbol displayed after an Org-heading that is collapsed - I prefer a simple dot.\n(setq org-adapt-indentation t org-hide-leading-stars t org-pretty-entities t org-ellipsis \" ·\") For source code blocks specifically, I want Org to display the contents using the major mode of the relevant language. I also want TAB to behave inside the source code block like it normally would when writing code in that language.\n(setq org-src-fontify-natively t org-src-tab-acts-natively t org-edit-src-content-indentation 0) It’s common to hide emphasis markers (e.g., /.../ for italics, *...* for bold, etc.) to have a cleaner visual look, but this makes it harder to edit the text. org-appear is the solution to all my troubles. It displays the markers when the cursor is within them and hides them otherwise, making edits easy while looking pretty.\n(use-package org-appear :commands (org-appear-mode) :hook (org-mode . org-appear-mode) :config (setq org-hide-emphasis-markers t) ; Must be activated for org-appear to work (setq org-appear-autoemphasis t ; Show bold, italics, verbatim, etc. org-appear-autolinks t ; Show links org-appear-autosubmarkers t)) ; Show sub- and superscripts And finally, I have some Org options to deal with headers and TODO’s nicely.\n(setq org-log-done t org-auto-align-tags t org-tags-column -80 org-fold-catch-invisible-edits 'show-and-error org-special-ctrl-a/e t org-insert-heading-respect-content t) LaTeX Previews The LaTeX previews in Org mode are pretty small by default, so I’ll increase their size a little.\n(plist-put org-format-latex-options :scale 1.35) org-fragtog works like org-appear, but for LaTeX fragments: It toggles LaTeX previews on and off automatically, depending on the cursor position. If you move the cursor to a preview, it’s toggled off so you can edit the LaTeX snippet. When you move the cursor away, the preview is turned on again.\n(use-package org-fragtog :hook (org-mode-hook . org-fragtog-mode)) Centring \u0026 Line Breaks I want the text to fill the screen adaptively, so that long lines of text adapt to the size of the window. It also breaks lines instead of truncating them.\n(add-hook 'org-mode-hook 'visual-line-mode) I prefer having my Org buffer centred. I think it looks prettier when I only have one buffer open, and it’s barely noticeable when several are open because the width of the margins adapt. For this, I use Olivetti, which I think is a great package for this purpose.\n(add-hook 'org-mode-hook 'olivetti-mode) As you can see in the below screenshot, the Org document fills up the left side of the screen comfortably even when olivetti-mode is on.\nTask \u0026 Time Tracking Org mode is also a really powerful tool for tracking tasks and time usage. However, the default colours don’t go too well with our new look.\nOf course, you should change the keywords and the number of priorities to suit your tastes. I have lifted my colours straight from the official Nord theme pallette so that they go well with my preferred theme.\nLet’s set the number of task priorities and specify the colour for each priority.\n(setq org-lowest-priority ?F) ;; Gives us priorities A through F (setq org-default-priority ?E) ;; If an item has no priority, it is considered [#E]. (setq org-priority-faces '((65 . \"#BF616A\") (66 . \"#EBCB8B\") (67 . \"#B48EAD\") (68 . \"#81A1C1\") (69 . \"#5E81AC\") (70 . \"#4C566A\"))) And then the custom keywords.\n(setq org-todo-keywords '((sequence \"TODO(t)\" \"WAIT(w)\" \"READ(r)\" \"PROG(p)\" ; Needs further action \"|\" \"DONE(d)\"))) ; Needs no action currently I don’t set the colours of each TODO state individually anymore, but if you wanted to, you could set the org-todo-keyword-faces variable like this:\n(setq org-todo-keyword-faces '((\"TODO(t)\" :inherit (org-todo region) :foreground \"#A3BE8C\" :weight bold) ...)) Bullets org-superstar styles some of my UI elements, such as bullets and special checkboxes for TODOs. It can style a lot more, so I recommend checking the package out!\n(use-package org-superstar :config (setq org-superstar-leading-bullet \" \") (setq org-superstar-headline-bullets-list '(\"◉\" \"○\" \"⚬\" \"◈\" \"◇\")) (setq org-superstar-special-todo-items t) ;; Makes TODO header bullets into boxes (setq org-superstar-todo-bullet-alist '((\"TODO\" . 9744) (\"WAIT\" . 9744) (\"READ\" . 9744) (\"PROG\" . 9744) (\"DONE\" . 9745))) :hook (org-mode . org-superstar-mode)) SVG Elements I use svg-tag-mode to replace progress bars, task priorities, dates, and citations with nice SVG graphics. This package can also style many more elements and I’d encourage you to read the documentation to find other things you might want to style with this.\n(use-package svg-tag-mode :config (defconst date-re \"[0-9]\\\\{4\\\\}-[0-9]\\\\{2\\\\}-[0-9]\\\\{2\\\\}\") (defconst time-re \"[0-9]\\\\{2\\\\}:[0-9]\\\\{2\\\\}\") (defconst day-re \"[A-Za-z]\\\\{3\\\\}\") (defconst day-time-re (format \"\\\\(%s\\\\)? ?\\\\(%s\\\\)?\" day-re time-re)) (defun svg-progress-percent (value) (svg-image (svg-lib-concat (svg-lib-progress-bar (/ (string-to-number value) 100.0) nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11) (svg-lib-tag (concat value \"%\") nil :stroke 0 :margin 0)) :ascent 'center)) (defun svg-progress-count (value) (let* ((seq (mapcar #'string-to-number (split-string value \"/\"))) (count (float (car seq))) (total (float (cadr seq)))) (svg-image (svg-lib-concat (svg-lib-progress-bar (/ count total) nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11) (svg-lib-tag value nil :stroke 0 :margin 0)) :ascent 'center))) (setq svg-tag-tags `( ;; Task priority (\"\\\\[#[A-Z]\\\\]\" . ( (lambda (tag) (svg-tag-make tag :face 'org-priority :beg 2 :end -1 :margin 0)))) ;; Progress (\"\\\\(\\\\[[0-9]\\\\{1,3\\\\}%\\\\]\\\\)\" . ((lambda (tag) (svg-progress-percent (substring tag 1 -2))))) (\"\\\\(\\\\[[0-9]+/[0-9]+\\\\]\\\\)\" . ((lambda (tag) (svg-progress-count (substring tag 1 -1))))) ;; Citation of the form [cite:@Knuth:1984] (\"\\\\(\\\\[cite:@[A-Za-z]+:\\\\)\" . ((lambda (tag) (svg-tag-make tag :inverse t :beg 7 :end -1 :crop-right t)))) (\"\\\\[cite:@[A-Za-z]+:\\\\([0-9]+\\\\]\\\\)\" . ((lambda (tag) (svg-tag-make tag :end -1 :crop-left t)))) ;; Active date (with or without day name, with or without time) (,(format \"\\\\(\u003c%s\u003e\\\\)\" date-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1 :margin 0)))) (,(format \"\\\\(\u003c%s \\\\)%s\u003e\" date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0)))) (,(format \"\u003c%s \\\\(%s\u003e\\\\)\" date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0)))) ;; Inactive date (with or without day name, with or without time) (,(format \"\\\\(\\\\[%s\\\\]\\\\)\" date-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date)))) (,(format \"\\\\(\\\\[%s \\\\)%s\\\\]\" date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-date)))) (,(format \"\\\\[%s \\\\(%s\\\\]\\\\)\" date-re day-time-re) . ((lambda (tag) (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-date))))))) (add-hook 'org-mode-hook 'svg-tag-mode) Prettify Tags \u0026 Keywords I have a custom function to prettify tags and other elements, lifted from Jake B’s Emacs setup.\n(defun my/prettify-symbols-setup () ;; Checkboxes (push '(\"[ ]\" . \"\") prettify-symbols-alist) (push '(\"[X]\" . \"\") prettify-symbols-alist) (push '(\"[-]\" . \"\" ) prettify-symbols-alist) ;; org-abel (push '(\"#+BEGIN_SRC\" . ?≫) prettify-symbols-alist) (push '(\"#+END_SRC\" . ?≫) prettify-symbols-alist) (push '(\"#+begin_src\" . ?≫) prettify-symbols-alist) (push '(\"#+end_src\" . ?≫) prettify-symbols-alist) (push '(\"#+BEGIN_QUOTE\" . ?❝) prettify-symbols-alist) (push '(\"#+END_QUOTE\" . ?❞) prettify-symbols-alist) ;; Drawers (push '(\":PROPERTIES:\" . \"\") prettify-symbols-alist) ;; Tags (push '(\":projects:\" . \"\") prettify-symbols-alist) (push '(\":work:\" . \"\") prettify-symbols-alist) (push '(\":inbox:\" . \"\") prettify-symbols-alist) (push '(\":task:\" . \"\") prettify-symbols-alist) (push '(\":thesis:\" . \"\") prettify-symbols-alist) (push '(\":uio:\" . \"\") prettify-symbols-alist) (push '(\":emacs:\" . \"\") prettify-symbols-alist) (push '(\":learn:\" . \"\") prettify-symbols-alist) (push '(\":code:\" . \"\") prettify-symbols-alist) (prettify-symbols-mode)) (add-hook 'org-mode-hook #'my/prettify-symbols-setup) (add-hook 'org-agenda-mode-hook #'my/prettify-symbols-setup) After all this prettification, TODOs, code blocks, and lists look like screenshot below.\nConclusion There it is, that’s pretty much all of the visual Org-specific code in my config. If you’re interested in other aspects of my config, you’re of course welcome to check it out. I’m just starting out, so I’d also really appreciate constructive criticism or tips!\nScrapped: Implementing a Small Interpreter in Haskell :functional:programming:haskell:monads One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.\nWe’d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here’s how we approached it and some of my reflections when looking back at it.\nI’ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it’s easier to see how monads work when seeing the implementation. The parser, on the other hand, uses the monad combinator library Parsec, which is both more complicated and more well-documented elsewhere.\nI’ll assume you’re familiar with monads and their operations, but this is also a great project to try your hand at if you’re still getting the hang of using them.\nThe code is available in its entirety on my GitHub, and I would encourage you to follow along!\nThe Boa Language The Boa language is a small subset of Python. It looks pretty familiar to anyone who has programmed in Python before, and if you’re interested in a more thorough explanation of the language, you can check out the ./docs folder in the repo.\nThe most important aspects of the language, for our interpreter, is that it has global state. In our purely functional implementation language, computations are normally not stateful. So, we have to make use of a monad to model the program environment and interpret terms with respect to the existing bindings.\nThankfully, Boa computations can make do with read-only access to the environment. Therefore, we can use a neat and (as far as monads go) pretty intuitive monad, namely the Reader monad. We’ll implement it ourselves, but you could also just import the above package in your project.\nSpoiler Alert! Syntax File Below, you can find the finished Syntax.hs file. If you want to implement the language yourself, you might want to try your hand at writing this file, too, before seeing this suggestion.\nSyntax.hs module Syntax where data Value = None | Boolean Bool | Number Integer | Text String | List [Value] deriving (Eq, Show, Read) data Expression = Constant Value | Variable VariableName | Operation OperationSymbol Expression Expression | Not Expression | Call FunctionName FunctionInput | ListExpression [Expression] | ListComprehension Expression [Clause] deriving (Eq, Show, Read) type VariableName = String type FunctionName = String type FunctionInput = [Expression] type FunctionArguments = [Value] data OperationSymbol = Plus | Minus | Times | Div | Mod | Eq | Less | Greater | In deriving (Eq, Show, Read) data Clause = For VariableName Expression | If Expression deriving (Eq, Show, Read) type Program = [Statement] data Statement = Define VariableName Expression | Execute Expression deriving (Eq, Show, Read) Monad Implementation Executing a Boa program means evaluating all the program statements, starting from the empty environment and populating it as we go. If we encounter any runtime errors underway, we’ll stop execution and print an error message. If all is well, we’ll continue until there are no more statements, and then print the output of the program.\nLet’s use the following abbreviations.\ntype Output = [String] type ErrorMessage = String data RuntimeError = UnboundVariable VariableName | BadFunction FunctionName | BadArgument ErrorMessage deriving (Eq, Show) type Environment = [(VariableName, Value)] type Runtime a = Environment -\u003e (Either RuntimeError a, Output) An environment is a mapping from variable names to values. What we want is a monad that allows us to keep track of the variable bindings in the environment. When we want to perform a computation, we need a runtime where we can read from the environment and either raise a runtime error or return a value, and append the output from the computation so we can print it later. This is essentially what we would want to use the Reader monad for! Let’s implement a simple version.\nThe Boa Monad Every monad is an applicative functor and every applicative functor is a functor. Those are interesting to read about in their own right, but for now, we just need to know that if we implement the monad correctly, we get these two for free. For these freebies, we need to import Control.Monad. We’ll also need a newtype Boa a, whose “run” action will have the type Runtime a.\nimport Control.Monad newtype Boa a = Boa {run :: Runtime a} instance Functor Boa where fmap = liftM instace Applicative Boa where pure = return (\u003c$\u003e) = ap Nice! Now, we need to define two functions for our monad, namely return and \u003e\u003e=, and we have a fully fledged monad instance!\nFor a quick refresher, let’s look at their type signatures.\nreturn :: Monad m =\u003e a -\u003e m a (\u003e\u003e=) :: Monad m =\u003e m a -\u003e (a -\u003e m b) -\u003e m b In the case of return, we just want to take a value and put it inside the monad. What’s the simplest way we can do that? Well, our monad lets us read from the environment and we’re supposed to return either an error message or a value a, and then the output we want to print after the computation is done. The simplest way, then, is to not read anything from the environment, just put in the value, and not add anything to the output.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u003e\u003e= f = undefined Essentially, this says “I don’t care about the environment, just give me the tuple with a and no output in it, then put it all inside the Boa monad for me”. The following notation is semantically equivalent, but the syntax may be easier to read depending on what you’re used to.\nreturn a = Boa (\\_ -\u003e (Right a, [])) Then what do we want to do for \u003e\u003e=, is define a way to take a value out of the monad, apply a function to it, and then put the result back into the monad. To unwrap the value a from ba, we can simply use our monad’s run function. We have to take in an environment so that we can run the monad in the environment and look at the result. If it’s an error, then we just return the error. But if we get a value a out and some output, then we want to run the function f on a. What we’re gonna return, is the result of f a and the output of that computation appended to all the previous output. Finally, we put it all back into the Boa monad.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u003e\u003e= f = Boa $ \\env -\u003e case run ba env of (Left re, out) -\u003e (Left re, out) -- just return the error (Right a, out) -\u003e let (result, out') = run (f a) env -- run f a in the environment in (result, out ++ out') -- append the new output to the old Sweet! Now let’s define some operations that let us interact with the monad in a more ergonomic way.\nMonad Operations Now we have the monad itself, but it’s nice to abstract away some details and instead work with more intuitive function names. Let’s write some functions with more easily understood names.\nabort :: RuntimeError -\u003e Boa a look :: VariableName -\u003e Boa Value bind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a) output :: String -\u003e Boa () abort should just accept a runtime error and put it into the Boa monad.\nabort :: RuntimeError -\u003e Boa a abort re = Boa $ const (Left re, []) -- or equivalently, abort re = Boa (\\_ -\u003e (Left re, [])) look should accept a variable name and look to see if it is in the environment. if it is, return the value inside the monad. If it isn’t, return an “unbound variable” runtime error inside the monad. In either case, no output is necessary.\nlook :: VariableName -\u003e Boa Value look x = Boa $ \\env -\u003e case lookup x env of Just a -\u003e (Right a, []) Nothing -\u003e (Left (UnboundVariable x), []) bind takes a variable name and a value. What it should do, is run the monad with that name-value binding prepended to the old environment, and then put the value of that computation back into the monad. It needs to be prepended and not appended because when we perform a lookup, we want to find the most recent bindings first.\nbind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a) bind x v ba = Boa $ \\env -\u003e run ba $ (x,v) : env -- or equivalently, bind x v ba = Boa (\\env -\u003e run ba ( [(x,v)] ++ env )) output should take an string and put it into the monad as output.\noutput :: String -\u003e Boa () output s = Boa $ const (Right (), [s]) Interpreter Functions Finally, we need the main operations of the interpreter. To execute a Boa program, we want to take a program and return a tuple with the output of the program and possibly a runtime error.\nexecute :: Program -\u003e (Output, Maybe Runtime Error) execute p = undefined Since a Program is made up of Define and Execute statements, we can write a helper function exec that pattern matches on the type of statement.\nexec :: Program -\u003e Boa () exec [] = undefined exec ((Define x e) : s) = undefined exec ((Execute e) : s) = undefined And finally, we’ll need a helper function eval that’s responsible for evaluating a single expression and putting the resulting value into the Boa monad for us. This is what we’ll focus on for now.\neval :: Expression -\u003e Boa Value Since they’re not the most interesting part of the interpreter, I’m omitting quite a few other helper functions, notably operate :: OperationSymbol -\u003e Value -\u003e Value -\u003e Either ErrorMessage Value and apply :: FunctionName -\u003e FunctionArguments -\u003e Boa Value. They’re of course in the repo, and I’d encourage you to try implementing them yourself.\neval needs to pattern match on each expression. There are the following types of Expression:\nConstant Variable VariableName Not Expression Operation OperationSymbol Expression Expression Call FunctionName FunctionInput ListExpression [Expression] ListComprehension Expression [Clause] Constant Let’s start with Constant.\neval (Constant v) = return v It’s already a value, so we can just take it and put it directly in the monad. Easy!\nVariable What about a variable? Well, either it’s bound in the environment or it’s not and should return an error. look seems like a perfect fit for the job. It even returns an error message for us if x is not present in the environment.\neval (Variable x) = look x Not If we meet a Not expression, we should evaluate the sub-expression to a Boolean value, then take the opposite value, cast it as a Boolean and put it in the Boa monad. Actually, we can do all of this by fmap-ing (Boolean . not . truthy) onto the evaluated expression. That unwraps the expression, applies the three functions above, and then wraps it back up in the monad.\nNote that \u003c$\u003e is just an infix version of fmap, and truthy is a helper function that evaluates a Value to a Boolean value.\neval (Not e) = Boolean . not . truthy \u003c$\u003e eval e Operation An Operation is performed by evaluating each of its arguments, extracting the Value from each, using operate on them to get the result Value, and wrapping that result back in the monad. In this case, do-notation makes our code much more readable.\neval (Operation o e1 e2) = do v1 \u003c- eval e1 v2 \u003c- eval e2 case operate o v1 v2 of Right v -\u003e return v Left re -\u003e abort $ BadArgument re Call Recall that Call takes a function name f and a list of expressions es, which is the function input. What we want to do, is to evaluate all the function arguments, and then send all those values to our helper function apply, which will apply f to the evaluated es and put the result into the Boa monad.\nWith the help of mapM, we can write the function for Call expressions very succinctly. Its type signature is\nmapM :: (Traversable t, Monad m) ==\u003e (a -\u003e m b) -\u003e t a -\u003e m (t b).\nIn our case, the traversable structure is a list and the monad is the Boa monad. In our case, we can rewrite it as\nmapM :: (Expression -\u003e Boa Value) -\u003e [Expression] -\u003e Boa ([Value]).\neval, of course has the type Expression -\u003e Boa Value and the function input has type [Expression].\nGreat! So if we do mapM eval es, we’ll get a Boa [Value], where each Value is an evaluated function argument. Then we just want to take this list of values out of the monad and send it to the apply f function.\neval (Call f es) = mapM eval es \u003e\u003e= apply f List Expression We can do something similar for ListExpression, except this case is much easier! We want to evaluate all the expressions, as above, but then all we need is to put the results in a List and wrap it in the monad. Then we can just fmap List onto the evaluated expressions.\neval (ListExpression es) = List \u003c$\u003e mapM eval es List Comprehension Now, the ListComprehension is probably the trickiest case to write. Once way is to write two mutually recursive functions, the eval case for ListComprehension and a helper function comprehension.\nThe eval case for list comprehension, does more or less the same as the ListExpression does: It takes the result of evaluating the contents, and puts the resulting List into the Boa monad. Then, comprehension is the function that actually computes the result.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension = undefined comprehension takes in a list of clauses, and a Clause is either an if-statement on the form If Expression or a for-statement on the form For VariableName Expression=.\nTherefore, comprehension pattern matches on three cases: The empty list, a for-statement and more clauses, or an if-statement and more clauses.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = undefined comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined In the case of the empty list, we have a list comprehension that is really just a list expression, on the form ListComprehension Expression []. So in that case, comprehension can just evaluate e1 and return the list containing that one value, inside the Boa monad.\nOnce again, there’s a very handy function we can use, to write this code in a single, short line, namely \u003c\u0026\u003e. It’s implemented as flip fmap and has the type signature\n(\u003c\u0026\u003e) :: Functor f ==\u003e f a -\u003e (a -\u003e b) -\u003e f b.\nIn our case, we’re applying it like this,\n(\u003c\u0026\u003e) :: Boa Value -\u003e (Value -\u003e [Value]) -\u003e Boa [Value].\nThe return we’re using here is the return of the list monad. Basically, we’re saying “evaluate e1, which gives us a Boa Value. Then, take that value out of the Boa monad, put it into the list monad with return, and finally put that list with the value back in the Boa monad”.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined Recall that the result of evaluating a list comprehension should be on the form Boa (List [Value]), which (because List [Value] is itself a Value) is just a Boa Value. When we return from comprehension to eval, we can fmap the constructor List onto the Boa [Value], which accomplishes exactly this: It turns the result Boa [Value] into Boa (List [Value]).\nWhen we encounter an If-expression, the syntax corresponds to e1 if e2 . So we know that the expression e2 should be a Boolean value. Luckily, in Boa as in Python, non-Boolean values correspond to a Boolean value. E.g., 1==True is true and 0==True is false.The first thing we can do, then, is to evaluate e2 and find the corresponding Boolean value with truthy.\nBy fmap-ing truthy onto the evaluated expression, we get a Boa Bool, i.e., a normal Haskell Boolean inside the Boa monad. By using do-notation, then, we can give b the unwrapped Boolean and we can use it directly in an if-statement. If the condition b holds, then evaluate the rest of the list comprehension. Else, there’s no more to evaluate.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = undefined The case for For statements is probably the hardest to read, but it’s not that bad now that we’re more familiar with \u003c$\u003e and mapM.\nThe corresponding syntax is e1 for x in e2 so we know that e2 is the list where we should bind the variable name x to an element, for each iteration.\nWe evaluate e2 to v2. If v2 is not iterable, then it’s not possible to use it in a for-statement and we should throw an error. If it’s a list, then we want to bind each value in xs to x inside the rest of the comprehension, c2.\nRecall the following function types.\ncomprehension :: [Clause] -\u003e Boa [Value]\nbind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a)\nmapM :: (a -\u003e m b) -\u003e [a] -\u003e m ([b])\nWe want to do bind x v (comprehension c2), where v is each of the values from xs. We already have the variable name x and the comprehension c2, but bind needs a single value v, whereas xs is a list of values. Time for some mapM magic.\nSince xs has the type [Value], we can rewrite mapM as\nmapM :: (Value -\u003e Boa Value) -\u003e [Value] -\u003e Boa [Value]\nThen xs can be the second argument! In order for bind to be the first argument, we can write an anonymous function (\\v -\u003e bind x v (comprehension c2)) :: Value -\u003e Boa Value.\nNow mapM (\\v -\u003e bind x v (comprehension c2)) xs does exactly what we wanted it to do! Except that we’re mapping a function that returns a list, over a list, so the result is a Boa [[Value]]. To fix this, we can simply fmap the function concat over the result to turn it into a single, flat list and put it inside the Boa monad. And then, we’re all done with eval!\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = do v2 \u003c- eval e2 case v2 of (List xs) -\u003e concat \u003c$\u003e mapM (\\v -\u003e bind x v (comprehension c2)) xs _ -\u003e abort $ BadArgument $ \"Argument \" ++ showValue v2 ++ \" is not iterable\" If eval and comprehension look completely crazy to you - especially if you’re wondering how we can use e1 inside of comprehension - I’d recommend reading about closures and mutually recursive functions. It’s really powerful stuff, but I was definitely confused the first time I saw it!\nPutting It All Together Now we have the following eval function.\neval :: Expression -\u003e Boa Value eval (Constant v) = return v eval (Variable x) = look x eval (Operation o e1 e2) = do v1 \u003c- eval e1 v2 \u003c- eval e2 case operate o v1 v2 of Right v -\u003e return v Left re -\u003e abort $ BadArgument re eval (Not e) = Boolean . not . truthy \u003c$\u003e eval e eval (Call f es) = mapM eval es \u003e\u003e= apply f eval (ListExpression es) = List \u003c$\u003e mapM eval es eval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (For x e2 : c2) = do v2 \u003c- eval e2 case v2 of (List xs) -\u003e concat \u003c$\u003e mapM (\\v -\u003e bind x v (comprehension c2)) xs _ -\u003e abort $ BadArgument $ \"Argument \" ++ showValue v2 ++ \" is not iterable\" comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] At this point, all we need is to write exec and execute!\nexec should just perform the computations in order and collect the output. It doesn’t need to keep track of which value was just computed, so the return type of exec is just Boa ().\nWe decided earlier that it should pattern match on Define and Execute statements. If it’s a definition, then we should evaluate the expression and bind the variable name to the result in the environment.\nexec :: Program -\u003e Boa () exec [] = return () exec ((Define x e) : s) = do v \u003c- eval e bind x v (exec s) exec ((Execute e) : s) = undefined If it’s an execution statement, then we should just evaluate the expression and keep executing the rest of the program.\nexec :: Program -\u003e Boa () exec [] = return () exec ((Define x e) : s) = do v \u003c- eval e bind x v (exec s) exec ((Execute e) : s) = eval e \u003e\u003e exec s And… That’s it! All our hard work when writing eval and its helper functions is finally paying off. This code it short, easy to read, and (relatively) easy to understand.\nThen execute is just the function that runs exec program in the empty environment.\nexecute :: Program -\u003e (Output, Maybe RuntimeError) execute p = case run (exec p) [] of (Right _, out) -\u003e (out, Nothing) (Left re, out) -\u003e (out, Just re) Then we’re all done! After writing a driver program (like Main.hs in the repo), you can install this boa executable by typing stack install in the directory. Now you can interpret Boa ASTs!\nContact I appreciate any feedback, comments, corrections, etc. you may have. If that’s the case, you can reach me via my GitHub or my email at sophie.bosio@outlook.com. Happy coding!\nTODO Monads in Haskell functionalprogramminghaskellmonads Monads are extremely useful and notoriously hard to wrap your head around the first time around. The formal definition, “a monoid in the category of endofunctors”, doesn’t really help the average person much.\nA monad is essentially a way to perform a computation with some added context in a functional way. Personally, I had the most luck starting with how to use monads in functional programming, and as I got better at using them, I would re-read the definitions and slowly feel like I started to understand them.\nFirst, I’ll give a brief introduction to monads, using the List monad as an example.\nThen, to explain why we might want to use monads, I’ll reproduce a famous example: Using the Writer monad to perform logging. I’ll be borrowing heavily this intro to monads by Studying With Alex on YouTube.\nAnd finally, to cover more of the theory behind monads, we’ll have a look at the Maybe monad in Haskell.\nWait, List is a Monad? Yes! Remember that a monad is a structure that lets us perform a computation with some added context. For a list, that context is what elements are in the list (including duplicates) and their order.\nLet’s say you want to map a function f over a list xs. All well and great, but you can’t just do it any way you like: You have to map the function over all the elements and preserve their order! So somehow, the context of the list carries over into the next computation you want to do on it.\nIn general, I find it useful to think of monads as “containers” or boxes around values. In this case, the list [...] is a container and the elements are the values.\nIf you take a normal integer, that value isn’t a (singleton) list by itself. E.g., wrapping 5 isn’t a list, but [5] is. To take an integer like 5 and make it into a singleton list, we have to “wrap it” in square brackets. In general this function is called return.\nThe containers, like [], also prevent us from accessing the values directly, so we have to “unwrap” them somehow. E.g., I can’t do [5] + 3 because I’m trying to add a list of integers to an integer, but I can do map (+ 3) [5], because now I’m adding an integer to another integer. This function is called bind and is written in Haskell with the symbol \u003e\u003e=.\nNote that when we are “extracting” a value in this way, we must pass it to a function that promises to put it back in to the monad. There are other ways to just take out the value and use it normally, but then we also lose the context. I.e., if I do ([5, 6, 7] !! 0) + 3, I can extract 5 without any additional context. Then I can add it to 3 and get 8 and that’s fine, but now the rest of the list is “gone” and I have no way of putting 8 into the list instead of 5.\nSo, monads allow us to perform computations with context in a functional way. What’s so special about that? Well, the number of elements and ordering of the list, depends on the list itself! So, it’s almost like the list has a state. But we normally can’t do stateful computations in a functional language, right? And yet, it’s still functional, because all the computations on lists return the same results each time they are called in the same context, i.e., on the same list.\nFor later, remember that a monad needs a way to put a normal value into the monad, and a way to extract a normal value out of the monad to pipe it to another function, that must eventually put it back into the monad.\nNormal values can be “put inside” a monad by wrapping them with some extra context. In a way, then, return is the function that takes a normal value a and returns that value with some extra context m and gives us the new value (a, m). Now we can’t just access a directly anymore, we need to first take it out of this context wrapper and then bind it to a function that puts it back.\nWriter Monad to the Rescue! Now we’ll have a look at the Writer monad, a commonly used monad that will hopefully illustrate the concepts more clearly.\nPlease note: This example is common, but my particular implementation borrows heavily from this intro to monads by Studying With Alex on YouTube, and I would recommend that video!\nThe Writer monad is often used for logging.\nLet’s say you have a function that adds two ints and a function that squares ints. Then you want to add a log statement for each computation, so that you can review the log later.\nIn an imperative language, you might add a global variable, but then all your functions depend on this one variable. You could pass the list as argument and return it as output, but then your add function suddenly also takes a weird, extra log argument. Instead, you could return a tuple, containing first the result of the computation and then the log so far. We could do that in Haskell as well. Let’s define a new type LoggedInt that contains an integer and a list of strings, which will be our log. Then add and square can return this type!\ntype LoggedInt = (Int, [String]) add :: Int -\u003e Int -\u003e LoggedInt add n m = (n + m, [\"Added \" ++ show n ++ \" to \" ++ show m]) square :: Int -\u003e LoggedInt square n = (n^2, [\"Squared \" ++ show n]) But now, you can’t really chain these together, because both functions take normal ints and return these weird LoggedInt values.\nghci\u003e square(add 2 4) :11:8: error: • Couldn't match type ‘(Int, [String])’ with ‘Int’ Expected: Int Actual: LoggedInt • In the first argument of ‘square’, namely ‘(add 2 4)’ In the expression: square (add 2 4) In an equation for ‘it’: it = square (add 2 4) Also, there is no way to access and extend the previous log, since each computation just returns the singleton list with their log statement.\nghci\u003e add 2 4 (6,[\"Added 2 to 4\"]) ghci\u003e square(2) (4,[\"Squared 2\"]) Of course, we could make both the functions take LoggedInt values. But that’s pretty much equivalent to passing the list as argument and returning it as output.\ntype LoggedInt = (Int, [String]) add :: LoggedInt -\u003e LoggedInt -\u003e LoggedInt add (n, log1) (m, log2) = (n + m, log1 ++ log2 ++ [\"Added \" ++ show n ++ \" to \" ++ show m]) square :: LoggedInt -\u003e LoggedInt square (n, log) = (n^2, log ++ [\"Squared \" ++ show n]) What to do? Well, if we squint, we can see that we have another context (the previously logged material) that we want to use in our computation, and we want to return a result that has the updated context (the old logs plus the new log statement)!\nThis is exactly the kind of thing monads are built for! Let’s implement the Writer monad from scratch together.\nThe type of monad we want, is basically an instance of the Writer monad in Haskell. Let’s call ours LogWriter.\nThe results of our computations are going to be inside the LogWriter monad from now on. Right off the bat, we want a way to take a computation wrapped in the monad and unwrap it. That’s usually called running the monad, so let’s define LogWriter with a function called run that just unwraps the computation and gives us the result and the log as a pair.\nnewtype LogWriter l a = LogWriter { run :: (a, l) } l is the type of the logs and a is the type of the result of the computation. Since we want to be able to concatenate (possibly empty) logs, l must be a member of the Monoid type class.\nLet’s take the old versions of our functions, that take normal integers and return integers with logs, and rewrite them so return values inside the LogWriter monad. The LogWriter contains the list of strings (logs) and an integer (result).\nnewtype LogWriter l a = LogWriter { run :: (a, l) } add :: Int -\u003e Int -\u003e LogWriter [String] Int add n m = undefined square :: Int -\u003e LogWriter [String] Int square n = undefined Like we saw earlier, a monad needs a way of putting a normal value (here, an int) into the container (here, an int with a log). In Haskell, this is called return. We want to find the “simplest”, most straightforward way of taking a normal value and putting into the monad.\nIn our case, that would be returning the value and the empty list. But since we specified that l should be a monoid, and not a list in particular, we can’t use [] for the empty list. Instead, we can use mempty which corresponds to the empty list, but works for all monoids!\ninstance (Monoid l) =\u003e Monad (LogWriter l) where return a = LogWriter (a, mempty) Then we need a way to extract a value out of the monad, so that we can use it to perform computations (such as squaring it) and then putting it back into the monad. Unwrapping, computing, and wrapping! This is called the “bind” operator and in Haskell, it is written as \u003e\u003e=.\nNote that it takes a wrapped value m a and a function that takes a normal value and returns a wrapped value again (a -\u003e m b). So we can’t just take any normal function a -\u003e b and bring it into monad-land using the bind operator - but we’ll see later that there is a function that does exactly that, called fmap!\nOf course, what we want to do is to apply f to the value a inside the monad, and return the result of that computation. Additionally, we want to take any new output and append it to the existing logs, and return that as well.\ninstance (Monoid l) =\u003e Monad (LogWriter l) where return a = LogWriter (a, mempty) (LogWriter (a, logs)) \u003e\u003e= f = let (LogWriter (result, output)) = f a in LogWriter (result, logs \u003c\u003e output) Finally, every monad is an applicative functor, and in turn a normal functor. Therefore, we need to make our monad an instance of those typeclasses as well. We’ll cover how this works in the section about Maybe, but for now, you can copy these instance declarations to make GHC happy and accept our LogWriter into the monad family.\nimport Control.Monad instance (Monoid l) =\u003e Applicative (LogWriter l) where pure = return (\u003c*\u003e) = ap instance (Monoid l) =\u003e Functor (LogWriter l) where fmap = liftM Now we can rewrite add and square to return values inside the LogWriter monad!\nimport Control.Monad newtype LogWriter l a = LogWriter { run :: (a, l) } instance (Monoid l) =\u003e Monad (LogWriter l) where return a = LogWriter (a, mempty) (LogWriter (a, logs)) \u003e\u003e= f = let (LogWriter (result, output)) = f a in LogWriter (result, logs \u003c\u003e output) instance (Monoid l) =\u003e Applicative (LogWriter l) where pure = return (\u003c*\u003e) = ap instance (Monoid l) =\u003e Functor (LogWriter l) where fmap = liftM add :: Int -\u003e Int -\u003e LogWriter [String] Int add n m = LogWriter (n + m, [\"Added \" ++ show n ++ \" to \" ++ show m]) square :: Int -\u003e LogWriter [String] Int square n = LogWriter (n^2, [\"Squared \" ++ show n]) And finally, perform monadic operation that keep track of the log the whole way! Since the result of add and square is now values within the LogWriter, we have to remember to run the monad so we get a nice, printable result. run gives us the final output with the context, after all the computations are done.\nghci\u003e add 5 3 # Gives us values INSIDE the monad! :126:1: error: • No instance for (Show (LogWriter [String] Int)) arising from a use of ‘print’ • In a stmt of an interactive GHCi command: print it ghci\u003e run (add 5 3) (8,[\"Added 5 to 3\"]) ghci\u003e run (square 2) (4,[\"Squared 2\"]) We can even chain computations using the \u003e\u003e operator, which lets us perform an operation, ignore the result, and perform the next operation. In these two examples, we see the result of the last computation in the chain, add 4 5, and the total log.\nghci\u003e run $ add 6 3 \u003e\u003e square 2 \u003e\u003e add 4 5 (9,[\"Added 6 to 3\",\"Squared 2\",\"Added 4 to 5\"]) ghci\u003e run $ add 5 10 \u003e\u003e square (fst $ run $ add 3 2) \u003e\u003e square 2 \u003e\u003e add 4 5 (9,[\"Added 5 to 10\",\"Squared 5\",\"Squared 2\",\"Added 4 to 5\"]) Now, we have a normal function like + between normal values and a “stateful” function like add from normal values to wrapped values. As an example, we can picture run $ add 4 5 \u003e\u003e​= square like this:\nMaybe We’ll Get A Value Time for some theory! Hopefully, with the context of the previous examples, this will feel mostly familiar.\nAs mentioned, we’ll be looking at applicatives and functors. Let’s look at some definitions and introduce some terminology:\nEvery monad is an applicative functor, and every applicative functor is a normal functor.\nSo, just like a square is a special rectangle, a monad is a special applicative, which in turn is a special functor.\nLet’s start at the lowest level, functors, and work our way up.\nFunctors Formally, a functor is a transformation that maps all the objects (values) in a category to objects in another, and all the morphisms (functions) in a category to morphisms in another.\nFor example, the Maybe functor applied the type Int maps regular integers like 5 to Just 5 or Nothing, and maps functions that work on Int s to functions that work on Maybe Int s.\nIn Haskell, I usually think of values as wrapped or unwrapped values.\nAn unwrapped value, is just the value as we typically think of them. E.g., 5. A wrapped value, has a “container” that prevents us from using them as normal. E.g., Just 5.\nThen we need to do something special to use the functions on the wrapped values. For functors, this is fmap. It “lifts” a normal function up to functor territory so we can apply them to values. Or, if you like, it unwraps the value, applies the function, and wraps it back up.\nHere’s how a functor is defined in Haskell.\nclass Functor f where fmap :: (a -\u003e b) -\u003e f a -\u003e f b So all we need to do to make something an instance of the Functor typeclass, is define a way to lift a function f to apply it to the wrapped values!\nHere’s the Maybe functor instance in Haskell:\ninstance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x) I.e., applying a function f to a Nothing value, will always give you Nothing. Applying a function f to Just x, is the same as applying f to x, and then putting the result back into Just.\nTrying to use a normal function directly on a wrapped value, results in an error. But it works just as you might expect when you fmap the function onto the value.\nghci\u003e (+2) (Just 5) :1:1: error: • Non type-variable argument in the constraint: Num (Maybe a) (Use FlexibleContexts to permit this) • When checking the inferred type it :: forall {a}. (Num a, Num (Maybe a)) =\u003e Maybe a ghci\u003e fmap (+2) (Just 5) Just 7 These are the two functor laws, which hopefully make sense. They state that fmap-ing a the identity function is just the identity function, and that fmap-ing two composed functions is the same as fmap-ing each function and then composing them.\nfmap id = id -- Identity fmap (g . f) = fmap g . fmap f -- Composition Note that you can use fmap in its infix form, which is \u003c$\u003e.\n(+2) \u003c$\u003e (Just 5) -- ==\u003e (Just 7)\nSince it’s a mapping from objects to objects and functions to functions, all instance of the Functor typeclass in Haskell are data structures that can be mapped over, such as lists, trees, Maybe and Either. Some of them you can find below:\nMore functors for the interested! Lists are probably the most commonly used Functor instance.\ninstance Functor [] where fmap = map Trees can be mapped over by applying f to each node recursively.\ninstance Functor Tree where fmap f Leaf = Leaf fmap f (Node x left right) = Node (f x) (fmap f left) (fmap f right) Either is defined in a curried way, because it takes two arguments.\ninstance Functor (Either a) where fmap f (Right x) = Right (f x) fmap f (Left x) = Left x The IO monad, since it’s also a functor, has an fmap defined this way.\ninstance Functor IO where fmap f action = do result \u003c- action -- perform an IO action and save the result return (f result) -- apply f to the result of the IO action, -- which is itself an IO action And functions are actually also functors! fmap on the function arrow -\u003e looks a little strange, but it does all make sense.\ninstance Functor ((-\u003e) r) where fmap f g = (\\x -\u003e f (g x)) But notice how the type of this function, if you replace all the f s in the type of fmap with r -\u003e, gives us fmap :: (a -\u003e b) -\u003e (r -\u003e a) -\u003e (r -\u003e b).Notice also how we now have a function r -\u003e a and a function a -\u003e b and we end up with a function r -\u003e b. So this is actually just function composition!\ninstance Functor ((-\u003e) r) where fmap = (.) Applicatives An applicative functor has more structure than a regular functor, but less than a monad.\nIt lets us unwrap both a function and a parameter. For normal functors, we could only unwrap the parameter, but needed a normal function.\nIn Haskell, the Applicative typeclass is defined like this.\nclass (Functor f) =\u003e Applicative f where pure :: a -\u003e f a (\u003c*\u003e) :: f (a -\u003e b) -\u003e f a -\u003e f b pure is similar to the return function: It takes a value and wraps it in the applicative functor.\nThe \u003c*\u003e (“application”) operator allows us to unwrap both the function a -\u003e b and the parameter a, and finally wrap the result up to get f b.\nBasically, an Applicative functor allows us to take in a function and a parameter in a given context (f) and perform the function application while preserving that context (f b).\nNote that the following three lines are equivalent.\n```haskell pure f \u003c*\u003e x \u003c*\u003e y \u003c*\u003e ... fmap f x \u003c*\u003e y \u003c*\u003e ... f \u003c$\u003e x \u003c*\u003e y \u003c*\u003e ... These are the laws for applicative functors.\npure id \u003c*\u003e v = v -- Identity pure f \u003c*\u003e pure x = pure (f x) -- Homomorphism u \u003c*\u003e pure y = pure ($ y) \u003c*\u003e u -- Interchange pure (.) \u003c*\u003e u \u003c*\u003e v \u003c*\u003e w = u \u003c*\u003e (v \u003c*\u003e w) -- Composition Lists, Maybe, IO, functions, and a bunch of other functors are also applicative functors.\nMore applicative functors. instance Applicative Maybe where pure = Just Nothing \u003c*\u003e _ = Nothing (Just f) \u003c*\u003e something = fmap f something instance Applicative [] where pure x = [x] fs \u003c*\u003e xs = [f x | f \u003c- fs, x \u003c- xs] instance Applicative IO where pure = return a \u003c*\u003e b = do f \u003c- a x \u003c- b return (f x) instance Applicative ((-\u003e) r) where pure x = (\\_ -\u003e x) f \u003c*\u003e g = \\x -\u003e f x (g x) instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs \u003c*\u003e ZipList xs = ZipList (zipWith (\\f x -\u003e f x) fs xs) Monads Finally, we get to monads! At this point, remember that you can use all the same functions on monads as you could on functors and applicative functions.\nFunctors allow us to lift functions from one context to another, and applicative functors allow us to lift both functions and an argument while preserving a context. But the functions were always normal functions without any context. Monads also allow us to preserve context, but also allow us to use functions that take a value without context and return a value with context.\nA monad has the following operations. A minimal complete definition requires us to write return and bind ourselves.\nclass Monad m where return :: a -\u003e m a -- return, or unit (\u003e\u003e=) :: m a -\u003e (a -\u003e m b) -\u003e m b -- bind (\u003e\u003e) :: m a -\u003e m b -\u003e m b x \u003e\u003e y = x \u003e\u003e= \\_ -\u003e y fail :: String -\u003e m a fail msg = error msg The most interesting function we need for a monad is the bind operator, \u003e\u003e=.\nCompare this to fmap and \u003c*\u003e:\nfmap :: (Functor f) =\u003e (a -\u003e b) -\u003e f a -\u003e f b (\u003c*\u003e) :: (Applicative f) =\u003e f (a -\u003e b) -\u003e f a -\u003e f b (\u003e\u003e=) :: (Monad m) =\u003e m a -\u003e (a -\u003e m b) -\u003e m b Notice that the second argument to the bind operator, is a function from a normal value a to a value with context m b.\nI think the relationship between the different functions is especially clear when we look at the flipped version of the bind operator, =\u003c\u003c.\n(\u003c$\u003e) :: Functor f =\u003e (a -\u003e b) -\u003e f a -\u003e f b (\u003c*\u003e) :: Applicative f =\u003e f (a -\u003e b) -\u003e f a -\u003e f b (=\u003c\u003c) :: Monad m =\u003e (a -\u003e m b) -\u003e m a -\u003e m b To see how we might use the bind operator, though, we can write a function that works on Maybe Int values, which halves the integer value inside it.\nhalve :: Int -\u003e Maybe Int halve x = if evel x then Just (x `div` 2) else Nothing Then we can pass it an Int value, but if we want to pass it a Maybe Int we have to use the bind operator.\nghci\u003e halve 4 Just 2 ghci\u003e halve (Just 4) :1:1: error: • Non type-variable argument in the constraint: Integral (Maybe a) (Use FlexibleContexts to permit this) • When checking the inferred type it :: forall {a}. (Integral (Maybe a), Num a) =\u003e Maybe (Maybe a) ghci\u003e (Just 4) \u003e\u003e= halve Just 2 My thesis supervisor taught me this great trick for remembering how the bind operator works. It’s like a toilet plunger (and it looks a little like it, too)! It extracts the value out of the monad, but then the function you pass it to has to be responsible for putting it back into the monad.\nThere are a bunch of functions from the Functor and Applicative typeclasses that have equivalent Monad functions.\npure :: (Applicative f) =\u003e a -\u003e f a return :: (Monad m) =\u003e a -\u003e m a (\u003c*\u003e) :: (Applicative f) =\u003e f (a -\u003e b) -\u003e f a -\u003e f b ap :: (Monad m) =\u003e m (a -\u003e b) -\u003e m a -\u003e m b fmap :: (Functor f) =\u003e (a -\u003e b) -\u003e f a -\u003e f b liftM :: (Monad m) =\u003e (a -\u003e b) -\u003e m a -\u003e m b And many more! But what’s nice about this, is that if we import Control.Monad in our file, we can define a Monad instance quite easily by setting the Applicative and Functor functions to be equal to these monadic functions. For example, we can implement the list monad like this.\nimport Control.Monad instance Monad [] where return a = [a] xs \u003e\u003e= f = concat $ map f xs instance Applicative [] where pure = return (\u003c*\u003e) = ap instance Functor [] where fmap = liftM Finally, monads also have to obey the monad laws.\n(return x) \u003e\u003e= f == f x -- 'return' is left-identity wrt. '\u003e\u003e=' m \u003e\u003e= return == m -- 'return' is right-identity wrt. '\u003e\u003e=' (m \u003e\u003e= f) \u003e\u003e= g == m \u003e\u003e= (\\x -\u003e f x \u003e\u003e= g) -- '\u003e\u003e=' is associative Picturing A Monad Conclusion \u0026 Further Reading That’s it for the crash course in monads!\nIt’s also really interesting to read about the Monoidal typeclass, and how you can implement a monad using either (\u003e=\u003e) or join instead of the bind operator. Bartosz Milewski has a really great lecture on YouTube about monads where he explains this.\nThere are several cool functions on monads and friends, that let you chain together computations in a really neat, clean way. For example, my life got easier when I started using \u003c\u0026\u003e, \u003c$, \u003c* and similar functions. Not to mention do-notation!\nAnd finally, all this learning and reading about monads really becomes useful when you use them in projects. To get started, check out the Reader, Writer and Reader Writer State monads.\nI’ve had a lot of fun learning how to use monads to write parsers and interpreters.\nI’d appreciate any feedback, comments, corrections, etc. that you might have! Happy coding!\nDONE Building Your First Emacs Config emacs Emacs is a wonderful piece of software. It’s easily my favourite program of all time. It can also be a little overwhelming to configure for the first time.\nOne of the many things that make Emacs great, though, is its dedicated and helpful user base. I hope to add a small contribution to that community with this post, going over what I would have told my past self as I was just starting out using Emacs and trying to write my first Emacs configuration file.\nI’ll assume you know the basics of editing with Emacs and won’t cover general concepts like major modes or how to save files in Emacs. I’ll primarily be focusing on how you can get started personalising it.\nBefore we get into it, I’d like to cover three things: (1) Emacs is a Lisp interpreter at heart, (2) there are great places to get help, and (3) you should try out pieces of other people’s configs.\nPreamble A Primer in Emacs and Elisp Emacs is often thought of as a text editor. While it is built around text editing and has many great packages to do so, I’d argue it’s more useful to think of it as an (Emacs) Lisp interpreter.\nYour configuration file is a program of Emacs Lisp (or “elisp” for short) code that modifies the behaviour of Emacs itself. Most of the behaviours of vanilla Emacs are written in Elisp, and the rest in C. Therefore, almost everything that Emacs does, you can change! You can, of course, add and create new functionality as well.\nThe power to build your ideal editor is right at your fingertips! As long as you’re willing to learn a little bit of a Lisp dialect.\nThankfully, Elisp is a pretty readable language and as long as you watch your parentheses, you’ll be fine.\nGet Help The Emacs community is very friendly and are often keep to help out. I hang out a lot on the r/emacs subreddit and have gotten tons of tips and troubleshooting help from there. r/planetemacs is also great — they focus mostly on packages and blog posts/article links.\nEmacs also has a pretty good documentation and help system. You can take the Emacs tutorial using C-h t. Ask Emacs for help using:\nC-h v to see the documentation for a variable C-h f to see the documentation for a function C-h k to see what a keybinding does C-h m to show help for the current major and minor modes Or read on the Emacs Wiki.\nConfig Inspo This brings me to my first and (I think) most helpful tip: Get inspired by other people’s configurations.\nI’ll talk a little later about the basics of using Elisp for your config file, and that might be useful to help you read and understand the configs, but I think it’s good to have a starting point and to start experimenting early.\nIf you’re only just starting out, I invite you to check out my config and send me any questions you might have by email. (If you’re experienced, I invite you to send me any corrections or improvements!)\nHere are some of the configurations I have stolen a lot of my configuration from and can heartily recommend checking out.\nLars Tveito Jake Boxerman, with accompanying video Protesilaos Stavrou David Wilson (System Crafters) Nicolas Rougier Check out the configs piece by piece by copying something into your own config and testing it out for a while. This is probably what has been the most helpful to me.\nYou could also get a lot of useful tips and tricks from checking out some curated, “sane defaults” builds of Emacs. These are designed to be minimal and extensible, just configuring some settings to make the initial switch to Emacs a little smoother and give you a solid foundation for writing your own config. Most of them don’t include too many extra packages, either. Some of these include:\nPrelude Crafted Emacs Purcell’s Emacs config Nano Emacs Basics: Setting Variables Your configuration file is an Emacs Lisp file called init.el, located in your Emacs home directory. Usually, this is at ~/.emacs.d/init.el. This is where you’ll add your code, and Emacs will load this file at startup.\nEmacs can be configured either by modifying default behaviour or by installing and configuring community packages. You’ll probably want to do both.\nThere are quite a few blog posts and configurations that cover how to set “sane defaults” — i.e., modify the default behaviour of Emacs in a way most people would agree with. Check out the “early init” files or startup sections of the configs above. You might also want to check out sensible-defaults, which contains a lot of useful and, yes, sensible functions you can use in your config.\nIn general, you set the value of a variable using setq. Specify the name of the variable or the mode, then set it to an accepted value. Often variables will use t / nil and modes will use 1 / 0.\n(setq enabled-option t disabled-option nil enabled-mode 1 disabled-mode 0) Installing Packages After you’re done tweaking Emacs’ default behaviours, you’ll probably need some packages.\nYou can install a package from a package source or load an installed package in your load path using the require keyword.\n(require 'package-name) This is the easiest way to get started. Add the require-line to your init.el file and use setq to configure the package.\nIn fact, at the top of your init.el file, you should (require 'package). package.el is the default package manager for Emacs.\nMany Emacs packages are available at MELPA, a package archive with generally high-quality packages. You might also want to add some other package sources. Here’s an example from my config, where I add quite a few sources and tell Emacs which places to check first.\n(setq package-archives '((\"GNU ELPA\" . \"https://elpa.gnu.org/packages/\") (\"MELPA\" . \"https://melpa.org/packages/\") (\"ORG\" . \"https://orgmode.org/elpa/\") (\"MELPA Stable\" . \"https://stable.melpa.org/packages/\") (\"nongnu\" . \"https://elpa.nongnu.org/nongnu/\")) package-archive-priorities '((\"GNU ELPA\" . 20) (\"MELPA\" . 15) (\"ORG\" . 10) (\"MELPA Stable\" . 5) (\"nongnu\" . 0))) (package-initialize) After setting up your package sources, you can add (require 'package-name) to your init.el and Emacs will automatically search, download, and install that package from the source. Remember to evaluate your init.el file for this to happen, either by using the command eval-buffer on init.el or by restarting Emacs.\nSome packages are not available on MELPA \u0026 Co., in which case you might want to download it and save it on your computer manually. Or maybe you want to use a package you’ve written yourself.\nIn that case, you can also point Emacs to look for .el files on your computer. It’s practical to put all these files in the same place and add all of them to your “load path” so Emacs knows where to look for them. Here’s a setup for loading files from the ~/.emacs.d/local-lisp directory and sub-directories.\n(defvar local-lisp \"~/.emacs.d/local-lisp/\") (add-to-list 'load-path local-lisp) (let ((default-directory local-lisp)) (normal-top-level-add-subdirs-to-load-path)) A note on package management Using require and setting all your variables with setq statements can lead to a long and hard-to-read config when you add many packages.\nThat’s why some people prefer using other systems or wrappers around package.el, for example use-package, quelpa, or straight. You’ll see this a lot in the installation instructions for packages. Personally, I use use-package because it’s so prevalent and because it’s quite convenient.\nBut don’t get too caught up in this, you don’t need to use any of these, and it’s not very hard to refactor your code incrementally if you decide you want to try later.\nHere’s a (simple) example of how to remove some visual elements from vanilla Emacs:\n(setq tool-bar-mode 0 ;; Remove toolbar scroll-bar-mode 0 ;; Remove scollbars menu-bar-mode 0 ;; Remove menu bar blink-cursor-mode 0) ;; Solid cursor, not blinking And here’s an example of setting up the Olivetti package:\n(require 'olivetti) ;; Make sure Olivetti is installed (setq olivetti-style t) ;; Set the 'olivetti-style' variable to true Some Package Suggestions I still think you should use bits and pieces of other people’s configurations to figure out what look and feel you prefer for your Emacs experience, but below I have gathered some packages I like and some alternatives to them.\nCompletion Systems The really big one is your completion system. By default, some things in Emacs can feel a little clunky, such as entering commands, searching documents, and finding files. Thankfully, there are packages that give you a nice prompt with auto-completions, search tools, suggestions, prettification, etc. For example, they can auto-fill directory and file names when opening a file with C-x C-f.\nThese packages are usually combined with other supplementary packages, but there are a few common ones that people use as the core of their systems. They include:\nVertico Helm Ido As mentioned, there are many, many packages people pair with these systems. Ido comes built-in with Emacs, so you might want to start there. I personally use Vertico and have been very happy with that. I tried Helm, but found it a little overwhelming and felt I wasn’t using it to its full potential. People do love it though.\nPlay around with them a little, and if you like one, I’d say stick to it. Jumping around with these is kind of confusing, so I would only consider switching if I had a problem with the one I was using, or if another one had some very attractive feature.\nTerminal Emulators You can emulate a terminal inside Emacs. I.e., you never have to leave Emacs!\nThere’s a built-in terminal emulator, but it’s not particularly nice. Instead, I would suggest checking out either vterm or Eat.\nText Editing Some packages just make text editing easier.\nTake for example auto-completion packages such as the built-in dabbrev-mode, or corfu and company-mode.\nDepending on your use, you might find multiple-cursors useful.\nDe Facto Standards Magit is the best Git interface I’ve ever used.\nSpell- and syntax-checking is usually done with Flyspell and Flycheck, respectively. These are pretty great.\nHelpful gives you better help buffers.\nWhen you start a keybinding combination, which-key shows a popup with suggestions for possible continuations of the sequence.\nMore Packages For suggestions on more packages to check out, awesome-emacs is a curated and oft-updated package list. I also love browsing the top posts on the Emacs subreddits mentioned above.\nAesthetics: Fonts \u0026 Themes The quickest way to make your Emacs experience feel more personalised!\nThere are many different ways to set fonts in Emacs. You can also set different fonts for the Emacs UI, for programming (monospaced or “fixed pitch” fonts) and for prose editing (regular or “variable pitch” fonts).\nHere’s how I set my fonts. I use Roboto Mono for the UI and for programming, and I use Source Sans Pro for my other documents. I check that the relevant font is installed, and then set their size using the :height property.\n(when (member \"Roboto Mono\" (font-family-list)) (set-face-attribute 'default nil :font \"Roboto Mono\" :height 108) (set-face-attribute 'fixed-pitch nil :family \"Roboto Mono\")) (when (member \"Source Sans Pro\" (font-family-list)) (set-face-attribute 'variable-pitch nil :family \"Source Sans Pro\" :height 1.18)) Note that I don’t set the height of the programming (fixed pitch) font. It simply uses the same height as the default font. I do set the size of the prose (variable pitch) font, though, and I do that by giving a relative size – it’s relative to the size of the default font.\nWhen it comes to themes, I’d recommend starting with a pack so you can explore many different options quickly, without needing to install a bunch of theme packages by hand. A great place to get started, is Doom Emacs’ theme pack called doom-themes. I particularly like the doom-nord theme. You can install and enable it like this:\n(require' doom-themes) ;; Make sure doom-themes are installed (load-theme 'doom-nord t) ;; Load the doom-nord theme I also really like the Modus themes, the Ef themes and the Nano themes. You can find many more on emacsthemes.com.\nProgramming Eglot (Emacs polyGLOT) is an LSP server client for Emacs that comes pre-installed from Emacs 29. You can install it manually in Emacs \u003e26.3.\nYou can also build Emacs with tree-sitter support. It’s available for Emacs \u003e25.1.\nBesides this, there are tons of major modes for various languages, usually called -mode. These will often give you basic syntax highlighting and commands.\nFor example, here’s a simple way to get basic Python 3.11 support:\n(require 'python-mode) (setq python-shell-interpreter \"python3.11\") Here’s my current setup for Haskell (except I’ve rewritten it to use require instead of use-package) using the Stack tool to build my Haskell projects:\n(require 'haskell-mode) (add-hook 'haskell-mode 'haskell-doc-mode) (setq haskell-hoogle-command \"hoogle\" haskell-compile-stack-build-command \"stack build\" haskell-compile-stack-build-alt-command \"stack build --pedantic\") (define-key haskell-mode-map (kbd \"C-c h\") 'haskell-hoogle) (define-key haskell-mode-map (kbd \"C-c C-c\") 'haskell-compile) Hooks In the Haskell example above, we briefly saw how to add a hook. A hook lets you run a function each time a specific thing happens. Most of the time, this is used to execute some function or activate/deactivate a mode when a certain mode is activated.\nFor example, in my Haskell config, I want to activate haskell-doc-mode each time I activate haskell-mode, so that I always have documentation on hand while I’m programming in Haskell.\nMaybe you want to activate line numbers each time you start programming. To do that, you can add a hook to prog-mode like so:\n;; Activate 'display-line-numbers-mode' when programming (add-hook 'prog-mode-hook 'display-line-numbers-mode) Note the apostrophe before the names of the functions (here, the names of the modes)!\nYou can do so many more things with hooks and get really creative! I mostly use them to set up my modes the way I like them. E.g., I always center my text buffers (Org mode, LaTeX, etc.) with Olivetti and I hide the line numbers.\nBinding Keys We can get pretty deep on the subject of keybindings, so I’ll try to keep it brief.\nMost major modes with have a dedicated “mode map” of all the keybindings you can use while in that mode. Remember that you can always check out the currently available keybindings with C-h m, which describes the current major and minor modes.\nThis separation is very useful, as it allows you to bind the same keys to similar commands in different settings. E.g., you can bind C-c C-c to the relevant compilation command in all your programming languages if you like, even if the actual compilation command is different for each. You can also define your own custom keymaps and dictate when they should be used (another thing you can use hooks for!)\nIn general, you can bind a key globally, locally, or in a specific keymap like so:\n(global-set-key KEY COMMAND) (local-set-key KEY COMMAND) (define-key KEYMAP KEY COMMAND) Note that the KEY must be given in a way Emacs understands. You can use the kbd macro and then provide your keystrokes as a string, e.g., (kbd \"C-c C-c\"). Navigation keys and the function keys must be surrounded by \u003c\u003e, e.g., and .\nAgain from the Haskell config, I set keybindings for haskell-compile and haskell-hoogle commands in the haskell-mode-map.\n(define-key haskell-mode-map (kbd \"C-c h\") 'haskell-hoogle) (define-key haskell-mode-map (kbd \"C-c C-c\") 'haskell-compile) You can define keybindings for any command in Emacs. People even build personalised mnemonic systems. If you want to dive deep into keybindings, I would recommend checking out the package Hydra.\nConclusion Tinkering with my Emacs config is probably my favourite past-time, but even I will admit it was a bit of a headache in the very, very beginning. I hope this post has put a small dent in that frustration for you, or maybe given you some pointers to where you might want to take your WIP config.\nI welcome corrections, feedback, and questions by email. Happy hacking!\nDONE Setting Up Emacs LSP-Mode For Clojure emacs I use Clojure on the backend where I work. I think it’s really fun, especially in combination with Emacs, since Emacs is built with Emacs Lisp and Clojure is a Lisp dialect. So many of Emacs’ default keybindings started clicking for me once I started working with a language in the same tradition, editing structurally and by semantic units rather than line-by-line or character-by-character. I’m not alone in loving both and there’s clearly a lot of overlap between the two communities, which is evident from the number of Clojure packages for Emacs.\nThe probably most famous and popular among these is the excellent package CIDER, which provides a full-fledged development environment for Emacs with support for interactive development. CIDER has a ton of features for evaluating, debugging, and testing your code. However, you might want to supplement CIDER with other packages for things such as peeking function argument lists, navigating your code, and finding references/implementations. Emacs has some built-in documentation (eldoc), project management (project) and reference-finding capabilities (xref). But when you need more, clojure-lsp is your friend and the LSP client for Emacs lsp-mode integrates pretty well with the aforementioned built-ins.\nBasic Setup With clojure-lsp installed, you can use your preferred package manager to get the Emacs package lsp-mode. I use use-package. lsp-mode is pretty good at integrating with the built-in Emacs features, so I’ll let it autoconfigure, which it does by default. I’ll defer the package loading to shave off some precious milliseconds at Emacs’ startup.\n(use-package lsp-mode :defer t) Let’s add some hooks to start up lsp-mode when I’m programming in Clojure. I’ll also enable the which-key integration.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration))) Custom Bindings Next, I’ll bind some keys. The LSP server can suggest code actions and to execute these quickly, I’ll bind the command lsp-execute-code-action to M-. xref works pretty well in Clojure and lets you jump to the definition of a symbol with M-. (and jump back by popping the ref off the stack with M-,), so to find references instead of the implementation, I’ll bind lsp-find-references to C-M-..\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\"C-M-.\" . lsp-find-references) (\"C-c r\" . lsp-rename) (\"M-\" . lsp-execute-code-action))) Then, C-M-. pops up an xref buffer where I can see all references to a function, in which I can select an entry and jump to the call site.\nI can also press C-c r to rename a symbol as you’d expect.\nM- gives me a minibuffer with available code actions.\nAs a quick note, the code actions show up in a regular minibuffer. I just use vertico with vertico-posframe, which gives me a nice childframe for mine.\nIn case you’re interested, you can get rounded corners (on Mac OS) and fringes (Mac OS \u0026 Linux) by setting the variable vertico-posframe-paramters with the following settings:\n(setq vertico-posframe-parameters '((left-fringe . 12) (right-fringe . 12) (undecorated . nil))) Diagnostics LSP mode automatically tries to figure out which diagnostics tool you’re using, but I ran into some strange problem with the :auto setting when using Flycheck, so I set it to use Flycheck manually.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\"C-M-.\" . lsp-find-references) (\"C-c r\" . lsp-rename) (\"M-\" . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck)) This gives me the regular Flycheck indicators (the arrows) that something’s wrong, but also information in the echo area and in a popup childframe on mouse hover.\nCustomisation From this point onwards, the LSP server works really well on my machine for Clojure. However, lsp-mode comes with a few more bells and whistles than I’d like, so I’ll finish by deactivating some features. A tour of on-by-default features and guide on how to disable them can be found here.\n(use-package lsp-mode :defer t :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\"C-M-.\" . lsp-find-references) (\"C-c r\" . lsp-rename) (\"M-\" . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck) ;; Disable visual features (setq lsp-headerline-breadcrumb-enable nil ;; No breadcrumbs lsp-ui-sideline-enable nil ;; No sideline lsp-lens-enable nil ;; No lenses ;; Disable all mode line features, since I use a custom mode line lsp-modeline-code-actions-enable nil lsp-modeline-diagnostics-enable nil ;; Limit raising of the echo area to show docs lsp-signature-doc-lines 3)) With all this, I get a lot of nice LSP features. In conjunction with CIDER, this is starting to feel really smooth.\nFor example, the function’s docstring in the echo area when it’s at point.\nLSP-mode also plays nicely with my completion system, here using corfu.\nPerformance Improvements And finally, LSP-mode works a little bit faster if we set it to use plists for serialisation. We can set this in the :init-block of the use-package declaration.\n:init (setq lsp-use-plists t) Note that if you want to do this, you also need to add (setenv \"LSP_USE_PLISTS\" \"true\") to your early-init.el. See the performance part of the lsp-mode documentation for more information.\nFinal Configuration \u0026 Further Reading And here’s the final configuration that I’m using for Clojure as of September 2024.\n(use-package lsp-mode :defer t :init (setq lsp-use-plists t) :hook ((clojure-mode . lsp) (clojurec-mode . lsp) (lsp-mode . lsp-enable-which-key-integration)) :bind (:map lsp-mode-map (\"C-M-.\" . lsp-find-references) (\"C-c r\" . lsp-rename) (\"M-\" . lsp-execute-code-action)) :config (setq lsp-diagnostics-provider :flycheck) ;; Disable visual features (setq lsp-headerline-breadcrumb-enable nil ;; No breadcrumbs lsp-ui-sideline-enable nil ;; No sideline lsp-lens-enable nil ;; No lenses ;; Disable all mode line features, since I use a custom mode line lsp-modeline-code-actions-enable nil lsp-modeline-diagnostics-enable nil ;; Limit raising of the echo area to show docs lsp-signature-doc-lines 3)) The next thing I would consider to enhance my Clojure coding experience even further, is incorporating structural editing. Clojure, being a LISP dialect and therefore pretty close to an abstract syntax tree, is especially well-suited to structural editing. paredit is the classic and what I’ve used previously. Now, I use a combination of paredit and lispy, which has many more functions than paredit, with paredit-style keybindings. Smartparens is a paredit-alternative. puni is the most language-agnostic alternative, as far as I can tell.\nThanks for reading! I welcome feedback, comments, or questions. You can reach me via email or GitHub.\nTODO A Pragmatic View on Monads - Part 1/3 This is a rather long and opinionated introduction to monads. I hope you find it useful, or at least interesting.\nThis is part 1 out of 3.\nIt aims to give you some theoretical foundations before we jump into the practical example. I hope it makes you feel not only that the example is easier to follow and better motivated, but also like you have a jumping off point to learn more about monads if the topic interests you.\nFeel free to skip it if you’re familiar with monads as a concept.\nPart 2 is a practical example and the meat of the series, while part 3 consists of monad examples and further reading.\nI loved reading Elements of Clojure by Zachary Tellmann and I really appreciated his effort to make explicit knowledge that for most programmers is tacit. Tacit knowledge is all the innate/explicit/subconscious knowledge we have and rely on for other things. As an example, he explains that speaking requires tacit knowledge of how to articulate all the sounds in a given language. This does not mean we know how to explain the process of articulating or to teach it to a beginner. Rather, we tend to teach through demonstration, leading to trial and error for the student. Most people need practice in order to become good educators.\nIn general, I think failing or neglecting to communicate tacit knowledge is what makes a new topic seem mystical or opaque. If we try to learn something without naming and separating the building blocks its made up of, I think we often become frustrated and whole topic becomes solidified as a “difficult topic”. I feel this is the case for monads. It’s a rich subject, but in my opinion, we should be able to teach the principal applications of monads in computer science without inducing headaches.\nOn that note, we can outline some key questions that a decent explanation should try to answer:\nWhat? What is a monad, technically speaking? Why? Why are we interested in using monads in programming? But… WHY? What are the benefits of using monads over other methods? How? How can we implement a monad from scratch and how is it used? Okay, so… What are some common monads? Cool! What can I search for to learn more? In part 1, we’ll cover questions 1-3. Part 2 covers 4, and part 3 covers 5 and 6.\n1 - What? A Lightly Theoretical Introduction So, what are monads?\nMonads are a concept from a formalism called category theory. Just like set theory and logical theories, it overlaps with both mathematics and computer science. Loosely, category theory is the study of mathematical structures. Informally speaking, the category theorist asks:\nIf a lot of concepts seem to have similarities, is there a generalised structure that is common to all of these? What properties does this generalised structure have? How do different structures relate to one another? Turns out knowing that concept X is actually just a specific case of the general structure Y can be very useful. “Ah, but X is a Y, so therefore I can do all these things with it!” Monads are one of these general structures and we actually them all the time in computer science. For example, lists are monads! Therefore, all properties of monads are also properties of lists. Knowing a few examples of common monads and the properties of a monad can therefore be valuable in and of itself.\nTypically, somebody familiar with monads are tempted to use terminology, convention, shorthand, and notation from category theory or math without explaining them properly. They are very nice once you’ve become comfortable with these, because they’re very precise, but it’s easy to get lost in the definition sauce if you’re just starting out. I think it’s important to focus on why we are interested in using them in the first place and how you can begin applying this knowledge yourself.\nIn this post, I’ll therefore first give you a (not the) rationale for using monads in functional programming and computer science more broadly. It’ll include a brief and utilitarian introduction to the category theoretical concepts involved so that if you do feel compelled to read more about them, you’ll have hooks to hang your knowledge on. And if you forget something, you’ll have a name that you can look up.\nPart 2 will contain the practical example. The code examples will be in Python and Haskell, mainly because (1) I am familiar with them and (2) their syntaxes are relatively minimal, in my opinion making the patterns easier to see.\n2 - Why? Pure Functions \u0026 Stateful Computations So, what is the point of learning monads? Essentially, it’s a way for us to write stateful computations in a purely functional way. Let me elaborate.\nIn purely functional programming languages, we cannot normally have stateful computations, because all our functions are pure. Pure functions are functions in the mathematical sense: They take some input and they return some output - nothing more. The function always returns the same output for a given input. Because of this property, we can replace a function called on a particular value with the final value without losing anything. I.e., 3 + 5 can be replaced with 8 and nothing breaks or changes because of this replacement. This is called “referential transparency”.\nA pure function cannot access mutable state. It cannot read from or write to some variable that may change and use it to determine its output. Reading from or writing to some variable is what we would call a side-effect. Pure functions are free of side-effects, and instead the output is solely dependent on the input.\nRecall that for a particular input, a pure function will always return the same output. Because of this property, it is safe for pure functions to call other pure functions in their definition. So maybe I lied when I said they only depend on the input, but just like replacing a function call on a concrete with its output, we can replace the call to the external function with the code of the function losslessly. So splitting or code up into smaller functions mainly helps us reuse and read code.\nThe minute a function calls an impure function, therefore, the original function becomes impure as well. In purely functional languages like Haskell, impure functions are disallowed. In languages like Python and JavaScript, we can write purely functional functions and compose them into other pure functions by being mindful of only composing pure functions.\nAll this may sound restrictive, but these properties mean we can be pretty confident about what will happen when we compose functions, since the result of one is simply piped/threaded into the next, with no chance of side-effects doing something expected. No external state can change between this call and the next, at least in an asynchronous context. Testing small, pure functions is simpler for this reason, as well. If all the small functions are correct, then any large functions (composed of the right small functions) will be correct, too.\nAt the same time, a lot of what we want our computers to do for us, does require state. State is good sometimes! For example, in order to print to the terminal, our program needs to know the current state of the terminal (what has already been printed) and add to it (a new line of text, for example).\nMonads allow us to write and execute stateful computations in a purely functional and restricted way. The restriction is key. Monads require us to specify exactly how we are allowed to interact with the state, which makes for safer state mutation than we normally have in imperative, impure contexts.\n3 - But… WHY? The Case for Monads I just said earlier that pure functions are mappings from inputs to outputs. How can this be used to model state? To convince you that this is possible before we see some practical examples, I’ll ask you to consider the Turing machine.\nThe Turing machine is a computational model that can (given enough space and time) perform all the same computations that our modern computers can. Any program written on a regular computer, can be translated to an equivalent Turing machine program and executed on it, in theory.\nThe lambda calculus is another model of computation. In its simplest form, it consists of three elements:\nVariables Function abstraction Function application Note that the relevant function abstractions are pure.\nAlonzo Church, Alan Turing, and Stephen Kleene proved that the lambda calculus is equivalent to Turing machines (and in turn to general recursive functions). In other words, even the nastiest, most stateful imperative program can be translated to an equivalent program consisting only of pure functions. Thus, there must be a way to represent stateful computations in a purely functional context as well.\nIf you can write your program either in an imperative, stateful style or in the functional style, why would you choose the one that forces you to learn about monads to do something as simple as print to the terminal?\nThere are two arguments that I find compelling.\nThe first is that you can determine statically and on the type-level whether a function is pure or whether it may have potential side-effects. This is more interesting in strongly typed languages.\nThe second, and I think stronger, argument is that monads force you to define an interface to access state.\nIn imperative, mutable, stateful code, you give every function access to your state as default, and then you must restrict that access via encapsulation. In purely functional, immutable code, you give no one access to change state by default and then you define a specific interface to some state by defining a monad, whose operations determine how you can access the state.\nFor this reason, I think a monad is a useful design pattern/abstraction even in languages with mutable state, when the allowed actions on the state are well-defined, narrow in scope, and unlikely to change.\nSome Category Theory \u0026 A Teaser for Part 2 In category theory, a category is just a collection of things that relate to each other, together with those relations. The things are called “objects” and we treat them like black boxes with names. However, we can tell a lot about them by the way they relate to one another. These relations are called “morphisms”. This is the root of many important words in mathematics, in particular “isomorphism”, which you may have encountered before. A morphism is a generalisation of functions, mappings, pairs, and anything else that relates two objects. We represent them with arrows from one object to another.\nCategories have two important properties. The first is that each object has an identity morphism - i.e., a looping arrow that points from the object and back to the same object. The second is that morphisms can be composed if the target of one is the source of another, and this composition is associative. Associativity just means that when composing three morphisms \\(f, g, h\\) with the composition operator \\(\\circ\\), the final result doesn’t change based on which we choose to compose first, as long as the composition is valid. So \\(h \\circ (g \\circ f)\\) produces the same composite morphism as \\((h \\circ g) \\circ f\\), similar to how \\(5 + (3 + 1) = (5 + 3) + 1\\).\nA monad is a transformation that takes an object (or a morphism) and gives it a way to:\nAccess (read from or add to) state Thread the result from one stateful computation into the next to create a chain of stateful computations Resolve the chain of computations to get the final result and the accumulated state In particular, this transformation is a functor. A functor is like a super function: It can take objects (values) like a regular function and map it to another object, but it can also take whole morphisms (functions) and map them to other morphisms. This mapping must preserve the source and target of each morphism so that the original morphism and its mapped version correspond, and composition is preserved.\nTODO: Insert picture here\nNormally a functor maps objects and morphisms (functions) from one one category (“domain”) to another, but monads are functors that map from one category to within the same category. This mapping imbues regular objects and morphisms with the state and the operations on it. I hope to make this notion a bit clearer with the example in part 2.\nFeedback and corrections are very much welcome. Please direct them to me by email or by opening an issue on the blog’s GitHub repo.\nTODO A Pragmatic View on Monads - Part 2/3 Finally, it’s time to look at some code!\nThis is part 2 out of 3.\nPart 1 was a high-level introduction to monads and gave the motivation for using monads in (functional) programming. It answered questions 1-3 in the following list:\nWhat is a monad, technically speaking? Why are we interested in using monads in programming? What are the benefits of using monads over other methods? How can we implement a monad from scratch? What are some common monads? What can I search for to learn more? Here in part 2, we’ll cover question 4 by an example implementation.\nPart 3 covers questions 5 and 6.\nRecall from part 1 that a monad is a transformation that takes an input and gives it a way to:\nAccess (read from or add to) state Thread the result from one stateful computation into the next to create a chain of stateful computations Resolve the chain of computations to get the final result and the accumulated state Let’s make this clearer with an example.\nThis following example is well-known and not my invention.\nIntroducing Our Running Example Say you have two functions, inc and sqr, which take an integer and increments it and squares it, respectively. Below is a Python implementation.\ndef inc (x : int) -\u003e int: return n + 1 def sqr (x : int) -\u003e int: return n ** 2 These functions are nice and pure.\nNow let’s say you want to add logging to these functions. The logs are a list of strings and each function should add the string \"Incremented/Squared x\" for a number x to the logs.\nIn Python, we could simply use a global variable, initialised to the empty list, and add to it for each function call.\nlogs = [] def inc (x : int) -\u003e int: logs.append(f\"Incremented {x}\") return n + 1 def sqr (x : int) -\u003e int: logs.append(f\"Squared {x}\") return n ** 2 But now, these functions are no longer pure and it’s harder to tell which functions might modify the logs.\nTo fix this, we could instead take and return a tuple, each containing a number and the corresponding log string. It takes the input number and the old logs, and it returns the result number and the updated logs. Since each input corresponds to exactly one output and there are no side effects, these functions are pure!\ndef inc (x : int, logs : list[str]) -\u003e tuple[int, list[str]]: return (x + 1, logs.append(f\"Incremented {x}\")) def sqr (x : int, logs : list[str]) -\u003e tuple[int, list[str]]: return (x**2, logs.append(f\"Squared {x}\")) However, there’s a subtle problem with this approach: Why does our simple arithmetic functions know about list concatenation?\nIt’s a muddying of responsibilities and we can imagine a data structure that is updated in a more cumbersome way than lists.\nInstead, we can take just the number as the argument and return the tuple with the resulting number and the part of the logs that we wish to add to the total state. Now, our function is just dealing with values.\ndef inc (x : int) -\u003e tuple[int, list[str]]: return (x + 1, [f\"Incremented {x}\"]) def sqr (x : int) -\u003e tuple[int, list[str]]: return (x**2, [f\"Squared {x}\"]) Now we have a new problem. If we want to perform several computations and pipe the result from one to the next, we need to manually extract the number from the previous result and accumulate the logs to get the final list.\ndef inc (x : int) -\u003e tuple[int, list[str]]: return (x + 1, [f\"Incremented {x}\"]) def sqr (x : int) -\u003e tuple[int, list[str]]: return (x**2, [f\"Squared {x}\"]) def runComputations (): (result1, log1) = inc (1) (result2, log2) = sqr (result1) (result3, log3) = inc (result3) finalLog = log1 + log2 + log3 return (result3, finalLog) Then, we would get the desired result:\n\u003e\u003e\u003e runComputations () (5, [\"Incremented 1\", \"Squared 2\", \"Incremented 4\"]) But at what cost? All this manual collection and concatenation is pretty cumbersome, and if we want to add a computation in the middle, we have to change the code.\ndef inc (x : int) -\u003e tuple[int, list[str]]: return (x + 1, [f\"Incremented {x}\"]) def sqr (x : int) -\u003e tuple[int, list[str]]: return (x**2, [f\"Squared {x}\"]) def runComputations (): (result1, log1) = inc (1) (result2, log2) = sqr (result1) (result3, log3) = sqr (result2) # added computational step (result4, log4) = inc (result4) # changed this line finalLog = log1 + log2 + log3 + log4 # changed this line return (result4, finalLog) # changed this line As a segue, here’s the previous program rewritten in Haskell.\ninc :: Int -\u003e (Int, [String]) inc x = (x + 1, [\"Incremented \" ++ show x]) sqr :: Int -\u003e (Int, [String]) sqr x = (x ** 2, [\"Squared \" ++ show x]) runComputations :: (Int, [String]) runComputations = let (result1, log1) = inc 1 in let (result2, log2) = sqr result1 in let (result3, log3) = sqr result2 in let (result4, log4) = inc result4 in let finalLog = log1 ++ log2 ++ log3 ++ log4 in (result4, finalLog) Embellished Functions (Kleisli Arrows) The type of function that we saw above, that returns the result of a computation (the computed number) and some update to the state (the logstring for that function call), is a special kind of function.\nWe can say that the function is “embellished” with an new addition to the state - or “context” - for that computation, that can be added to the “global” state by a defined “update” function.\nIn our case, the state addition is a list with a single string and the update function is list concatenation.\nThe general, category theoretical term for this type of function is a Kleisli arrow.\nKleisli arrows are actually a fantastic starting point for defining our monad, so let’s use the functions we already have.\nLet’s call the normal, non-logging versions of our functions by their old names and the new, Kleisli arrow versions inc' and sqr'.\n-- Normal functions inc :: Int -\u003e Int inc x = x + 1 sqr :: Int -\u003e Int sqr x = x ** 2 -- Kleisli arrow versions inc' :: Int -\u003e (Int, [String]) inc' x = (x + 1, [\"Incremented \" ++ show x]) sqr' :: Int -\u003e (Int, [String]) sqr' x = (x ** 2, [\"Squared \" ++ show x]) Then we can draw a picture to represent them like this. Here, a, b, c are arbitrary numbers, related as expected by the functions.\nTODO: Insert picture here.\nNow the problem we want to tackle is exactly the same as we saw before. Can we somehow abstract away the threading of results and accumulation of state? After calling inc' , we want to pass b from the result (b, logs1) into sqr' and then combine logs2 and logs1.\nIn a sense, we want to define a function that can compose two Kleisli arrows.\nThis is where monads come in. A monad m is a transformation that takes a regular object (like our b) and transforms it into an object m(b) that has an implicit state update - in this case, logs1. This is often written m b in Haskell, without parentheses.\nThe transformation (monad) m implements two functions of particular note: return and \u003e\u003e= (“bind”).\nreturn takes a regular value and embellishes it with the “empty” or neutral state addition, called the “identity element” for that kind of state. For lists, this is the empty list, [].\nBind (\u003e\u003e= in Haskell) is the function that threads results from one computation to the next and combines their states using the “update” function. For lists, the update function is list concatenation, ++. I think the bind function in particular is easier to understand in the context of an example implementation, so I’ll leave it at that for now.\nSo, if the transformed object m b can represent the combination of b and logs1 and it has these two handy functions, we can replace (b, logs1) with m b, and by the same token change (c, logs2) to m c.\nTODO: Insert picture here.\nThese new versions of the functions inc' and sqr' are still Kleisli arrows, because they still embellish the original computational result with additional context.\nNow, since each function returns a computation result and an addition to the existing state, we must always start our chain of monadic computations with an initial state. In our case, the natural initial state is the empty list, [].\nThe result of running the (now monadic) computations, should be the final number and the final logs as we saw before, which has the type (Int, [String]).\nTODO: Insert picture here.\nAt this point, I think we’re ready to jump into the code.\n4 - How? LogWriter Implementation We never want to delete anything from our logs and our functions don’t need to read the logs, so we’re content with defining one operation for modifying the state, namely adding to the logs. A monad is well-suited to manage this kind of state. Our state will be a write-only list of strings representing our logs and we’ll only ever write to it. Let’s therefore call our monad the LogWriter.\nThe LogWriter is actually a specific case of the general monad pattern Writer, that is defined in the standard monad library mtl (“Monad Transformer Library”) for Haskell.\nThe Writer monad is quite a lot more powerful than what we’re defining here and does not provide a write-only state, so I would recommend reading through its documentation after this post.\nFirst, we need to define a new type for our monad. Remember that a monad takes a regular object as input and creates a transformed object. Let’s call this input a, where a represents the type of the computation result (in our case, Int for both our functions).\nnewtype LogWriter a = ? The first thing we’ll define at the type level, is a constructor for the type. By convention, the constructor has the same name as the type.\nnewtype LogWriter a = LogWriter ? The final thing we need at this stage, is to define the function that we’ll use to run computations in the LogWriter monad. Let’s call it run. The following Haskell record syntax is kind of funky, but essentially states that run is a function defined for LogWriter-transformed objects that returns a (a, [String]). The actual implementation is generically derivable in Haskell, so at this point, we’re done with the type declaration.\nnewtype LogWriter a = LogWriter { run :: (a, [String]) } Next, we’ll need to declare LogWriter as a monad. In Haskell, this means making LogWriter an instance of the Monad typeclass. The Monad typeclass just requires us to define the two functions mentioned earlier, return and bind.\nnewtype LogWriter a = LogWriter { run :: (a, [String]) } instance Monad LogWriter where return = undefined (\u003e\u003e=) = undefined The return function is relatively straightforward to implement for our [String] state. As mentioned, the identity element of lists under concatenation, ++, is the empty list, []. This represents the “emtpy” state addition - i.e., an addition that doesn’t change the existing state.\nreturn has the type signature return :: Monad m ==\u003e a -\u003e m a, because it takes a regular object a and turns it into a monadic object m a. In our case, m is LogWriter. And we just need to wrap the result and the empty state in our custom LogWriter constructor and we’re done. Easy!\nnewtype LogWriter a = LogWriter { run :: (a, [String]) } instance Monad LogWriter where return :: a -\u003e LogWriter a return a = LogWriter (a, []) (\u003e\u003e=) = undefined Now, the bind operator \u003e\u003e= is a little particular. Recall that what we want to do is to take an embellished result from a previous computation – m b, where b is the result of the computation – and pipe the b to the next computation – something that takes a regular, non-embellished b and returns a new embellished result m c – and combines them.\nTODO: Insert image here\nThe type signature of bind is (\u003e\u003e) :: Monad m =\u003e m b -\u003e (b -\u003e m c) -\u003e m c. We’re starting with an embellished result, which is a LogWriter object that contains a tuple (b, oldLogs) where b is a number that we want to pipe to the next computation. Then we’re taking the next computation that we want to run, which we’ll call f. The result of calling f on b is another embellished result, which is a LogWriter wrapper around a tuple (c, newLogs). We can bind these names in a let-statement for easy access to the values. Finally, we want to return a new LogWriter which contains c and the combined logs.\nnewtype LogWriter a = LogWriter { run :: (a, [String]) } instance Monad LogWriter where return :: a -\u003e LogWriter a return a = LogWriter (a, []) (\u003e\u003e=) :: LogWriter b -\u003e (b -\u003e LogWriter c) -\u003e LogWriter c (LogWriter (b, oldLog)) \u003e\u003e= f = let (LogWriter (c, newLog)) = f b in (LogWriter (c, oldLog ++ newLog)) And that does it for the Monad typeclass part!\nHowever, we’re not quite done yet. There’s something I’ve neglected to mention. The experienced among you will have read that a monad is “a monoid in the category of endofunctors”, and it’s finally time to dig into that statement a little further. At the end of the next section, we’ll complete our monad definition and in the following section, I’ll show you some examples of our monad in action. Hang tight!\nFunctors At this point, we need to hop back to category theory briefly. Recall how a category is a collection of objects and morphisms between objects, with identity morphisms and an associative composition operator. In part 1, we also touched briefly on the concept of functors and endofunctors, stating that\nThe LogWriter In Action Review TODO A Pragmatic View on Monads - Part 3/3 Okay, so… Common Monads A Deeper Dive Into Kleisli Arrow Composition This operator is called the Kleisli composition operator. In Haskell, it’s also called the “fish operator” because it looks like this: \u003e=\u003e.\nThe Kleisli composition operator should take two Kleisli arrows and combine them into one.\nCool! Further Reading TODO Demystifying Monads - Part 1/3 functionalprogramminghaskellmonads Zachary Tellman opens his book Elements of Clojure by explaining the concept of tacit knowledge. Paraphrasing, it’s all the innate/implicit/subconscious knowledge that we have acquired through experience and, because we didn’t learn it in a straightforward manner ourselves, often struggle to explain clearly to others. The result is that others, too, have to go through a frustrating and non-linear process to learn it.\nI think this is what often happens with monads, which mystify and confuse a lot of people. If they’re like me, it’s because they’re ambushed by it while checking out a purely functional language like Haskell for the first time.\nMaybe they get curious about it, but Googling the topic leaves them just as confused – many of the explanations found are either terminology-heavy or overly simplified. Typically definitions range between “a monad is a monoid in the category of endofunctors” on one end and “a burrito!” on the other. Neither is particularly helpful the first time around.\nI think this happens because people who understand monads struggle to communicate their tacit knowledge, which leads to people trying to learn becoming frustrated!\nBut that’s a shame. I think we should be able to teach and learn about monads without this much pain. I won’t pretend I understand monads completely (for example, I haven’t looked into their applications in mathematics), but the way we tend to use monads in computer science isn’t all that crazy. So in this blog series, we’ll have a closer look at the humble monad.\nI personally feel a need to know where a concept came from and why I should bother with it. So in this first part, I’ll cover some of the theory behind monads. In Part 2, we’ll roll up our shirt sleeves, iteratively implement our own monad, and finally see that theory in action. Finally, in Part 3, we’ll implement a couple of famous monads for fun and I’ll provide some resources for further reading.\nIf you’re just interested in the application of monads or you’re already familiar with the theory, then you have my blessing to jump right to Part 2. Otherwise, let’s dive in!\nWhat is a Monad? The monad is a concept from a formalism called category theory.\nJust like set theory, category theory has applications in both mathematics and computer science. Category theory is the study of mathematical structures. Informally speaking, the category theorist wants to know:\nIf different mathematical concepts have similarities, what are their commonalities? Can we make out the general, shared structure? What properties does this generalised structure have? How are different generalised structures related to one another? This all sounds abstract because it is. Category theory is sometimes referred to as the “mathematics of mathematics”. But here, we’ll just dip our toes into the stuff I think is useful to us right now, and the rest you can read about later if you’re interested.\nNow, when we prove a property of a generalised structure, that property holds true for all the specific cases, too. Turns out this is really useful! And a lot of the mathematical concepts we use in programming are specific cases like these.\nAs you might already have guessed, monads are one of these general structures that we actually use all the time. For example, lists are monads! Consider that a teaser for Part 3.\nOkay, now we’ve covered some theoretical grounds. Before we jump into more theory, I think now is a good time to explain why we’re even interested in monads in the first place. They’re not just a source of factoids about things we already know how to use, like lists, but a pretty neat design pattern that we can use to structure our code.\nPure Functions (Or, Why Use Monads?) The need for monads (or some alternative) is mostly in purely functional programming languages. This being said, monads are language agnostic and can be used to great effect regardless. A monad in Haskell is the same as a monad in Typescript.\nBut back to our motivation.\nA purely functional programming language only allows you to write pure functions. There are many equivalent ways of defining pure functions. I find it useful to think of it as a mapping between outputs and inputs: Each input is mapped to one and only one output, and the function does nothing else. The function is defined entirely by its definition – nothing else can affect what the function does.\nThe fact that calling a function on a given input returns the same output every time you call it, is called referential transparency. It means that anywhere in your code, you can replace a given function call with its result and vice versa without changing the semantics of your code.\n-- This program \"I'm \" ++ show (99 + 1) ++ \" years old!\" -- is exactly equivalent to this program \"I'm \" ++ show 100 ++ \" years old!\" But, borrowing an example from Tellman, if we have a strange definition of + that first sends out an email and then adds our two numbers together, the two programs above aren’t equivalent anymore!\nPure functions therefore cannot perform side-effects, such as sending emails or generally, reading from or writing to a mutable variable/state/context.\nI cannot call a function on Monday and get one result, then call it on Tuesday and get a different result because a variable changed in the meantime.\n-- 'punctuation' is a variable defined elsewhere ageInfo age = \"I'm \" ++ age ++ \" years old\" ++ punctuation -- On Monday: ghci\u003e ageInfo 100 \"I'm 100 years old!\" -- On Tuesday: ghci\u003e ageInfo 100 \"I'm 100 years old???\" Another way to say this, is that a pure function cannot have any side effects. These include things like updating a mutable variable, but also reading from and writing to the terminal.\nA read from the terminal is a function call that receives some of its input at runtime and the exact same program may return different results. The definition of the function does therefore not define its behaviour completely – it also depends on non-deterministic user input. Just like reading from a mutable variable, this breaks the rules.\ngreet = do name \u003c- getLine -- Read a line of input, save in the variable 'name' putStrLn \"Hello, \" ++ name -- Print greeting with supplied 'name' -- Alice is using the computer: ghci\u003e greet Alice -- User inputs \"Alice\" Hello, Alice -- Bella is using the computer: ghci\u003e greet \"Bella\" Bella -- User inputs \"Bella\" Hello, Bella A write to the terminal appends line(s) of text to the bottom of whatever text was there before. Therefore, writing to the terminal is like updating an existing, mutable variable. Therefore, its behaviour depends on the current state of the terminal output and will change between calls. Also illegal!\nJust like a function call that returns a value can be replaced with that value, a pure function definition can be replaced with its definition. In other words, pure functions are immutable declarations that we can safely use in and compose with other pure functions. Therefore, a pure function can use other pure functions. The programs below are equivalent.\ncompute x = ((2 * x) + 40) -- is equivalent to double x = (2 * x) compute x = (double x) + 40 -- is equivalent to double x = (2 * x) plusForty x = x + 40 compute = plusForty . double -- Read \"plusForty\" after \"double\" But the second we use an impure function in our chain of pure functions, the whole thing becomes impure.\nAll this function purity may sound a bit restrictive, but it makes it super easy to reason about our code and to test it. Because each small function is a simple mapping from input to output, we can compose functions with confidence and quickly experiment or write tests to check that our function actually does what we expect. Composition is the core of functional programming!\nWe prefer to use pure functions as much as possible. The “meat” of our program should preferably consist of concise, pure functions that we compose to get bigger and more complex, pure functions. But at some point, we need to deal with stateful computation. Either because of the domain we’re dealing with or simply because we want to print to the terminal!\nThis is where monads come in: We can use monads to model stateful computations in a purely functional way!\nThe Case For Monads For now, you can think of a monad as a strict interface that defines how you can read from/write to state in your computations. The monad defines what operations are permissible and how to chain together stateful computations.\nNow, if we can use monads to perform stateful computations, then we can break the guarantees that functional programming gives us (confidence and composability) so why not just use an imperative language with mutable variables?\nMonads deal with immutable data structures and define explicitly wh\nA Taste of Category Theory TODO Demystifying Monads - Part 2/3 functionalprogramminghaskellmonads In the previous entry of this blog post series, we covered some of the theory of monads and motivated their use in the general case. This time, we’ll take a crack at a practical example.\nThis post is largely my take on explaining a famous example. I don’t know where it originates, but I’ve seen others explaining the same thing, for example in the YouTube video (TODO insert reference) and this article and my lecturers and Bartosz Milewski.\nWe’ll add some mutable state to a series of simple computations by implementing a monad from scratch. Throughout, I’ll refer back to some of the theory from Part 1 and I’ll be clear about what parts of our implementation are core concepts relating directly to monads and what depend on our specific case. Once we’ve seen how one monad works, I want to show how this stuff generalises, but that deserves its own blog post - that will be Part 3 of this series.\nI’ll be using Haskell in the code examples below, but I’ll try my best to explain concepts underway so you can follow along even if you haven’t used Haskell before.\nA Running Example Say you have two pure functions, inc and sqr, that increments and squares a number, respectively. It takes an Int and returns an Int. In Haskell, this is what it would look like:\ninc :: Int -\u003e Int -- Type signature inc x = x + 1 -- Implementation sqr :: Int -\u003e Int sqr x = x * x Now say we want to add logging to each function so that we can run a computation like this:\nIncrement 5 Increment the previous result Square the previous result Increment the previous result Let our log be a list of strings.\ndata Log = [String] The final result should give us both the number and the following log:\n[\"Incremented 5\", \"Incremented 6\", \"Squared 7\", \"Incremented 49\"] If we pretend Haskell is an imperative language, we could imagine that we had a mutable variable log that we could append to. Let’s just take the case of inc, since the procedure would be the same for sqr.\nlog :: [String] log = [] inc :: Int -\u003e Int inc x = log += \"Incremented \" ++ show x return (x + 1) This function would no longer be pure and it would be impossible from the call site to see that it modified the log.\nIn Haskell, it is also illegal. Our function can only know about what is immutable or explicitly passed to it as an argument.\nTo fix this, we could also take the old log as argument and return the new log. Our new function takes and returns a tuple with an integer and a log.\nNOTE:\nIn Haskell, you can prepend an element to a string using the cons operator : but to append, you must use the list concatenation operator ++ and append a singleton list. That’s why the string below is in square brackets.\nWe also convert integers to strings using the show operator.\ndata Log = [String] inc :: (Int, Log) -\u003e (Int, Log) inc (x, oldLog) = (x + 1, oldLog ++ [\"Incremented \" ++ show x]) At first glance, this looks fine, right? Now our function is completely pure again!\nBut there’s a subtle problem with this approach: Why does our simple arithmetic function know about list concatenation?\nWe’re mixing concerns here, both incrementing integers and implementing our logging mechanism.\nIf we had a bunch of functions with added logging, but realised later that we wanted a different data structure for our logs and redefined the Log data type, we would also have to change the list concatenation operator ++ in every single function definition implementing logging.\nInstead, we could return just the string that we’d like to add to the logs. Then the concrete data structure and the operation used to accumulate the logs becomes opaque to the inc function.\ninc' :: Int -\u003e (Int, String) inc' x = (x + 1, (\"Incremented \" ++ show x)) Nice, now we can write functions that just deal with values.\nBut now we have a new problem.\nWe can run our computations the way we want, but we need to write a new function. Let’s call it runComputations.\nIt needs to take the result from each function call and thread/pipe it to the next computation and also accumulates the log fragments. We can do this by binding each intermediary result in a let-binding.\ndata Log = [String] inc :: Int -\u003e (Int, String) inc x = (x + 1, (\"Incremented \" ++ show x)) sqr :: Int -\u003e (Int, String) sqr x = (x * x, (\"Squared \" ++ show x)) runComputations :: (Int, Log) runComputations = let (result1, log1) = inc 5 in let (result2, log2) = inc result1 in let (result3, log3) = sqr result2 in let (result4, log4) = inc result3 in (result4, [log1] ++ [log2] ++ [log3] ++ [log4]) In the Haskell REPL, called GHCi, we can now run our computations and get the desired result:\nghci\u003e runComputations (50, [\"Incremented 5\", \"Incremented 6\", \"Squared 7\", \"Incremented 49\"]) Well, it’s pure and cleanly separates concerns, but… It’s ugly and verbose. We’re binding a series of temporary variables that are only really used to thread the values to the next computations. And worse, adding a new computation in the middle of the chain requires several changes to the code.\nrunComputations :: (Int, Log) runComputations = let (result1, log1) = inc 5 in let (result2, log2) = sqr result1 in -- Add this line -- Change all temp vars in the following lines: let (result3, log3) = inc result2 in let (result4, log4) = sqr result3 in let (result5, log5) = inc result4 in -- Add an extra log fragment to the result: (result5, [log1] ++ [log2] ++ [log3] ++ [log4] ++ [log5]) Enter: Monads!\nBy implementing the above code with monads, we’ll be able to rewrite the above function in a seemingly imperative style. This is a teaser for (one version) of what we could do with a monad:\nrunComputations :: (Int, Log) runComputations = run $ inc 5 \u003e\u003e= sqr \u003e\u003e= inc \u003e\u003e= sqr \u003e\u003e= inc Bind Let’s take a cue from category theory and go abstract. Our two functions, inc and sqr are functions that originally took an integer and returned an integer. Now, we’ve proposed two modified functions, that each take an integer and return an integer plus a log string. Let’s mark the new ones with an apostrophe.\n-- Old definitions: inc :: Int -\u003e Int sqr :: Int -\u003e Int -- New definitions: inc' :: Int -\u003e (Int, String) sqr' :: Int -\u003e (Int, String) We can see that these have the same shape: Take an input, return the result of the computation plus a “log fragment”.\nWe can generalise the kind of function we’re interested in like this,\nf :: a -\u003e (b, x) g :: b -\u003e (c, y) where f, g, h, ... are functions, a, b, c, ... are input/output types of the computation and x, y, z, ... are the “state fragments” (log strings, in our case).\nFirst, we just had regular arithmetic functions.\nKleisli Arrows We just proposed a function inc :: Int -\u003e (Int, Log). In other words, a function that takes an integer and returns an integer and a log.\nThis kind of transformation, that takes a given type and returns the same type plus something extra, is called a Kleisli arrow.\nKleisli Composition The fish operator\nMonads Imperative style, or Clojure threading, but with the strange bind operator.\nMonad transformation: Change state, empty m () - Return result m a. Single state - put a pin in it for when we talk about monad transformers!\nReturn and bind\nRun\nDiagrams\nImplementing a LogWriter Monad Using LogWriter! Different Kinds of State TODO Demystifying Monads - Part 3/3 functionalprogramminghaskellmonads Common monads\nList Maybe Either State Writer Monad transformers\n",
  "wordCount" : "21134",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Sophie Adeline Solheim Bosio"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/posts/all-posts/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sophie Bosio",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/static/img/favicon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sophie Bosio (Alt + H)">Sophie Bosio</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/education" title="Education">
                    <span>Education</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/SophieBosio" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">100 min&nbsp;·&nbsp;Sophie Adeline Solheim Bosio

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#hugo" aria-label="DONE Static Site Generation with Hugo emacs">DONE Static Site Generation with Hugo emacs</a></li>
                <li>
                    <a href="#prettifying-emacs-org-mode" aria-label="DONE Prettifying Emacs Org Mode emacs">DONE Prettifying Emacs Org Mode emacs</a><ul>
                        
                <li>
                    <a href="#theme" aria-label="Theme">Theme</a></li>
                <li>
                    <a href="#fonts" aria-label="Fonts">Fonts</a></li>
                <li>
                    <a href="#decluttering" aria-label="Decluttering">Decluttering</a></li>
                <li>
                    <a href="#latex-previews" aria-label="LaTeX Previews">LaTeX Previews</a></li>
                <li>
                    <a href="#centring-and-line-breaks" aria-label="Centring &amp; Line Breaks">Centring &amp; Line Breaks</a></li>
                <li>
                    <a href="#task-and-time-tracking" aria-label="Task &amp; Time Tracking">Task &amp; Time Tracking</a></li>
                <li>
                    <a href="#bullets" aria-label="Bullets">Bullets</a></li>
                <li>
                    <a href="#svg-elements" aria-label="SVG Elements">SVG Elements</a></li>
                <li>
                    <a href="#prettify-tags-and-keywords" aria-label="Prettify Tags &amp; Keywords">Prettify Tags &amp; Keywords</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li></ul>
                </li>
                <li>
                    <a href="#boa-interpreter-haskell" aria-label="Scrapped: Implementing a Small Interpreter in Haskell :functional:programming:haskell:monads">Scrapped: Implementing a Small Interpreter in Haskell :functional:programming:haskell:monads</a><ul>
                        
                <li>
                    <a href="#the-boa-language" aria-label="The Boa Language">The Boa Language</a><ul>
                        
                <li>
                    <a href="#spoiler-alert-syntax-file" aria-label="Spoiler Alert! Syntax File">Spoiler Alert! Syntax File</a></li></ul>
                </li>
                <li>
                    <a href="#monad-implementation" aria-label="Monad Implementation">Monad Implementation</a><ul>
                        
                <li>
                    <a href="#the-boa-monad" aria-label="The Boa Monad">The Boa Monad</a></li>
                <li>
                    <a href="#monad-operations" aria-label="Monad Operations">Monad Operations</a></li></ul>
                </li>
                <li>
                    <a href="#interpreter-functions" aria-label="Interpreter Functions">Interpreter Functions</a><ul>
                        
                <li>
                    <a href="#constant" aria-label="Constant">Constant</a></li>
                <li>
                    <a href="#variable" aria-label="Variable">Variable</a></li>
                <li>
                    <a href="#not" aria-label="Not">Not</a></li>
                <li>
                    <a href="#operation" aria-label="Operation">Operation</a></li>
                <li>
                    <a href="#call" aria-label="Call">Call</a></li>
                <li>
                    <a href="#list-expression" aria-label="List Expression">List Expression</a></li>
                <li>
                    <a href="#list-comprehension" aria-label="List Comprehension">List Comprehension</a></li></ul>
                </li>
                <li>
                    <a href="#putting-it-all-together" aria-label="Putting It All Together">Putting It All Together</a></li>
                <li>
                    <a href="#contact" aria-label="Contact">Contact</a></li></ul>
                </li>
                <li>
                    <a href="#monads-haskell" aria-label="TODO Monads in Haskell functionalprogramminghaskellmonads">TODO Monads in Haskell functionalprogramminghaskellmonads</a><ul>
                        
                <li>
                    <a href="#wait-list-is-a-monad" aria-label="Wait, List is a Monad?">Wait, List is a Monad?</a></li>
                <li>
                    <a href="#writer-monad-to-the-rescue" aria-label="Writer Monad to the Rescue!">Writer Monad to the Rescue!</a></li>
                <li>
                    <a href="#maybe-we-ll-get-a-value" aria-label="Maybe We&rsquo;ll Get A Value">Maybe We&rsquo;ll Get A Value</a><ul>
                        
                <li>
                    <a href="#functors" aria-label="Functors">Functors</a></li>
                <li>
                    <a href="#applicatives" aria-label="Applicatives">Applicatives</a></li>
                <li>
                    <a href="#monads" aria-label="Monads">Monads</a></li></ul>
                </li>
                <li>
                    <a href="#picturing-a-monad" aria-label="Picturing A Monad">Picturing A Monad</a></li>
                <li>
                    <a href="#conclusion-and-further-reading" aria-label="Conclusion &amp; Further Reading">Conclusion &amp; Further Reading</a></li></ul>
                </li>
                <li>
                    <a href="#first-emacs-config" aria-label="DONE Building Your First Emacs Config emacs">DONE Building Your First Emacs Config emacs</a><ul>
                        
                <li>
                    <a href="#preamble" aria-label="Preamble">Preamble</a><ul>
                        
                <li>
                    <a href="#a-primer-in-emacs-and-elisp" aria-label="A Primer in Emacs and Elisp">A Primer in Emacs and Elisp</a></li>
                <li>
                    <a href="#get-help" aria-label="Get Help">Get Help</a></li>
                <li>
                    <a href="#config-inspo" aria-label="Config Inspo">Config Inspo</a></li></ul>
                </li>
                <li>
                    <a href="#basics-setting-variables" aria-label="Basics: Setting Variables">Basics: Setting Variables</a></li>
                <li>
                    <a href="#installing-packages" aria-label="Installing Packages">Installing Packages</a></li>
                <li>
                    <a href="#some-package-suggestions" aria-label="Some Package Suggestions">Some Package Suggestions</a><ul>
                        
                <li>
                    <a href="#completion-systems" aria-label="Completion Systems">Completion Systems</a></li>
                <li>
                    <a href="#terminal-emulators" aria-label="Terminal Emulators">Terminal Emulators</a></li>
                <li>
                    <a href="#text-editing" aria-label="Text Editing">Text Editing</a></li>
                <li>
                    <a href="#de-facto-standards" aria-label="De Facto Standards">De Facto Standards</a></li>
                <li>
                    <a href="#more-packages" aria-label="More Packages">More Packages</a></li></ul>
                </li>
                <li>
                    <a href="#aesthetics-fonts-and-themes" aria-label="Aesthetics: Fonts &amp; Themes">Aesthetics: Fonts &amp; Themes</a></li>
                <li>
                    <a href="#programming" aria-label="Programming">Programming</a></li>
                <li>
                    <a href="#hooks" aria-label="Hooks">Hooks</a></li>
                <li>
                    <a href="#binding-keys" aria-label="Binding Keys">Binding Keys</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li></ul>
                </li>
                <li>
                    <a href="#lsp-mode-for-clojure" aria-label="DONE Setting Up Emacs LSP-Mode For Clojure emacs">DONE Setting Up Emacs LSP-Mode For Clojure emacs</a><ul>
                        
                <li>
                    <a href="#basic-setup" aria-label="Basic Setup">Basic Setup</a></li>
                <li>
                    <a href="#custom-bindings" aria-label="Custom Bindings">Custom Bindings</a></li>
                <li>
                    <a href="#diagnostics" aria-label="Diagnostics">Diagnostics</a></li>
                <li>
                    <a href="#customisation" aria-label="Customisation">Customisation</a></li>
                <li>
                    <a href="#performance-improvements" aria-label="Performance Improvements">Performance Improvements</a></li>
                <li>
                    <a href="#final-configuration-and-further-reading" aria-label="Final Configuration &amp; Further Reading">Final Configuration &amp; Further Reading</a></li></ul>
                </li>
                <li>
                    <a href="#a-pragmatic-view-on-monads-part-1-3" aria-label="TODO A Pragmatic View on Monads - Part 1/3">TODO A Pragmatic View on Monads - Part 1/3</a><ul>
                        
                <li>
                    <a href="#1-what-a-lightly-theoretical-introduction" aria-label="1 - What? A Lightly Theoretical Introduction">1 - What? A Lightly Theoretical Introduction</a></li>
                <li>
                    <a href="#2-why-pure-functions-and-stateful-computations" aria-label="2 - Why? Pure Functions &amp; Stateful Computations">2 - Why? Pure Functions &amp; Stateful Computations</a></li>
                <li>
                    <a href="#3-but-dot-dot-dot-why-the-case-for-monads" aria-label="3 - But&hellip; WHY? The Case for Monads">3 - But&hellip; WHY? The Case for Monads</a></li>
                <li>
                    <a href="#some-category-theory-and-a-teaser-for-part-2" aria-label="Some Category Theory &amp; A Teaser for Part 2">Some Category Theory &amp; A Teaser for Part 2</a></li></ul>
                </li>
                <li>
                    <a href="#a-pragmatic-view-on-monads-part-2-3" aria-label="TODO A Pragmatic View on Monads - Part 2/3">TODO A Pragmatic View on Monads - Part 2/3</a><ul>
                        
                <li>
                    <a href="#introducing-our-running-example" aria-label="Introducing Our Running Example">Introducing Our Running Example</a></li>
                <li>
                    <a href="#embellished-functions--kleisli-arrows" aria-label="Embellished Functions (Kleisli Arrows)">Embellished Functions (Kleisli Arrows)</a></li>
                <li>
                    <a href="#4-how-logwriter-implementation" aria-label="4 - How? LogWriter Implementation">4 - How? LogWriter Implementation</a></li>
                <li>
                    <a href="#functors" aria-label="Functors">Functors</a></li>
                <li>
                    <a href="#the-logwriter-in-action" aria-label="The LogWriter In Action">The LogWriter In Action</a></li>
                <li>
                    <a href="#review" aria-label="Review">Review</a></li></ul>
                </li>
                <li>
                    <a href="#a-pragmatic-view-on-monads-part-3-3" aria-label="TODO A Pragmatic View on Monads - Part 3/3">TODO A Pragmatic View on Monads - Part 3/3</a><ul>
                        
                <li>
                    <a href="#okay-so-dot-dot-dot-common-monads" aria-label="Okay, so&hellip; Common Monads">Okay, so&hellip; Common Monads</a></li>
                <li>
                    <a href="#a-deeper-dive-into-kleisli-arrow-composition" aria-label="A Deeper Dive Into Kleisli Arrow Composition">A Deeper Dive Into Kleisli Arrow Composition</a></li>
                <li>
                    <a href="#cool-further-reading" aria-label="Cool! Further Reading">Cool! Further Reading</a></li></ul>
                </li>
                <li>
                    <a href="#demystifying-monads-1" aria-label="TODO Demystifying Monads - Part 1/3 functionalprogramminghaskellmonads">TODO Demystifying Monads - Part 1/3 functionalprogramminghaskellmonads</a><ul>
                        
                <li>
                    <a href="#what-is-a-monad" aria-label="What is a Monad?">What is a Monad?</a></li>
                <li>
                    <a href="#pure-functions--or-why-use-monads" aria-label="Pure Functions (Or, Why Use Monads?)">Pure Functions (Or, Why Use Monads?)</a></li>
                <li>
                    <a href="#the-case-for-monads" aria-label="The Case For Monads">The Case For Monads</a></li>
                <li>
                    <a href="#a-taste-of-category-theory" aria-label="A Taste of Category Theory">A Taste of Category Theory</a></li></ul>
                </li>
                <li>
                    <a href="#demystifying-monads-2" aria-label="TODO Demystifying Monads - Part 2/3 functionalprogramminghaskellmonads">TODO Demystifying Monads - Part 2/3 functionalprogramminghaskellmonads</a><ul>
                        
                <li>
                    <a href="#a-running-example" aria-label="A Running Example">A Running Example</a></li>
                <li>
                    <a href="#bind" aria-label="Bind">Bind</a></li>
                <li>
                    <a href="#kleisli-arrows" aria-label="Kleisli Arrows">Kleisli Arrows</a></li>
                <li>
                    <a href="#kleisli-composition" aria-label="Kleisli Composition">Kleisli Composition</a></li>
                <li>
                    <a href="#monads" aria-label="Monads">Monads</a></li>
                <li>
                    <a href="#implementing-a-logwriter-monad" aria-label="Implementing a LogWriter Monad">Implementing a LogWriter Monad</a></li>
                <li>
                    <a href="#using-logwriter" aria-label="Using LogWriter!">Using LogWriter!</a></li>
                <li>
                    <a href="#different-kinds-of-state" aria-label="Different Kinds of State">Different Kinds of State</a></li></ul>
                </li>
                <li>
                    <a href="#demystifying-monads-2" aria-label="TODO Demystifying Monads - Part 3/3 functionalprogramminghaskellmonads">TODO Demystifying Monads - Part 3/3 functionalprogramminghaskellmonads</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="hugo"><span class="org-todo done DONE">DONE</span> Static Site Generation with Hugo <span class="tag"><span class="emacs">emacs</span></span><a hidden class="anchor" aria-hidden="true" href="#hugo">#</a></h2>
<p>This website is built with <a href="https://gohugo.io/">Hugo</a> and <a href="https://ox-hugo.scripter.co/"><code>ox-hugo</code></a>, an exporting engine that lets me
write my posts in <a href="https://orgmode.org/">Org mode</a> and then put it online easily.</p>
<p>Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using <code>ox-hugo</code> to write our blogs
(besides staying in the comfort of a well-known format and editing flow).</p>
<p>For example, I can use this code snippet from <a href="https://ox-hugo.scripter.co/doc/org-capture-setup/">ox-hugo&rsquo;s blog</a> as a template to
create a new blog post and bind it to a key combination in my Emacs configuration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elisp" data-lang="elisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">with-eval-after-load</span> <span class="ss">&#39;org-capture</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">org-hugo-new-subtree-post-capture-template</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;Returns </span><span class="ss">`org-capture&#39;</span><span class="s"> template string for new Hugo post.
</span></span></span><span class="line"><span class="cl"><span class="s">See </span><span class="ss">`org-capture-templates&#39;</span><span class="s"> for more information.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">title</span> <span class="p">(</span><span class="nf">read-from-minibuffer</span> <span class="s">&#34;Post Title: &#34;</span><span class="p">))</span> <span class="c1">;Prompt to enter the post title</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="nv">fname</span> <span class="p">(</span><span class="nv">org-hugo-slug</span> <span class="nv">title</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="nf">mapconcat</span> <span class="nf">#&#39;identity</span>
</span></span><span class="line"><span class="cl">                 <span class="o">`</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                   <span class="o">,</span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;* TODO &#34;</span> <span class="nv">title</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;:PROPERTIES:&#34;</span>
</span></span><span class="line"><span class="cl">                   <span class="o">,</span><span class="p">(</span><span class="nf">concat</span> <span class="s">&#34;:EXPORT_FILE_NAME: &#34;</span> <span class="nv">fname</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;:END:&#34;</span>
</span></span><span class="line"><span class="cl">                   <span class="s">&#34;%?\n&#34;</span><span class="p">)</span>          <span class="c1">;Place the cursor here finally</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;\n&#34;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">&#39;org-capture-templates</span>
</span></span><span class="line"><span class="cl">               <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;h&#34;</span>                <span class="c1">;`org-capture&#39; binding + h</span>
</span></span><span class="line"><span class="cl">                 <span class="s">&#34;Hugo post&#34;</span>
</span></span><span class="line"><span class="cl">                 <span class="nv">entry</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="nv">file</span> <span class="s">&#34;~/path/to/your/all-posts.org&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                 <span class="p">(</span><span class="nb">function</span> <span class="nv">org-hugo-new-subtree-post-capture-template</span><span class="p">))))</span>
</span></span></code></pre></div><h2 id="prettifying-emacs-org-mode"><span class="org-todo done DONE">DONE</span> Prettifying Emacs Org Mode <span class="tag"><span class="emacs">emacs</span></span><a hidden class="anchor" aria-hidden="true" href="#prettifying-emacs-org-mode">#</a></h2>
<p>In my opinion, the power of Emacs is that you&rsquo;re able to program your own
working environment. Other editors may be just as, or possibly more, efficient
to use, but I haven&rsquo;t come across any that give you control over as many aspects
of your editor as Emacs does. Customising and tweaking your configuration may be an
endless endeavour, but it&rsquo;s also a highly rewarding one.</p>
<p>All that being said, I was inspired to tweak the look of my Org Mode setup,
especially after reading the blog post
<a href="https://zzamboni.org/post/beautifying-org-mode-in-emacs/">Beautifying
Org Mode in Emacs</a>. Below you can find screenshots and code. I
hope there&rsquo;s something in here that you might want to steal for your own config!
In case I change these settings later, my most recently updated config is always
available on my <a href="https://github.com/SophieBosio/.emacs.d">GitHub</a>.</p>
<figure><a href="/img/init-org-screenshot.png">
    <img loading="lazy" src="/img/init-org-screenshot.png"/> </a>
</figure>

<h3 id="theme">Theme<a hidden class="anchor" aria-hidden="true" href="#theme">#</a></h3>
<p>The easiest and quickest way to change the look of vanilla Emacs is to load a
colour theme. I&rsquo;m using the <code>doom-nord</code> theme, which is part of the <a href="https://github.com/doomemacs/themes"><code>doom-themes</code></a>
package. I find both it and several of the other themes from that pack to be
excellent.</p>
<p>You can find an updated list of themes on <a href="https://emacsthemes.com/">emacsthemes.com</a> where they
have screenshots. From spending time on the Emacs subreddit, I also know that
people are very fond of Prot&rsquo;s <a href="https://github.com/protesilaos/modus-themes">Modus</a> and <a href="https://github.com/protesilaos/ef-themes">Ef themes</a>, as well as the built-in
<code>leuven</code> theme. Feel free to play around!</p>
<h3 id="fonts">Fonts<a hidden class="anchor" aria-hidden="true" href="#fonts">#</a></h3>
<p>Next up is setting up variable-pitch and fixed-pitch fonts. I love Roboto Mono
and I use a ligaturised version of it for programming, from the
<a href="https://github.com/lemeb/a-better-ligaturizer">a-better-ligaturizer project</a>. Here, I&rsquo;ll add that a package such as <code>ligature.el</code>
is required to display the ligatures.</p>
<p>For variable-pitch (regular) text, I want to use <a href="https://fonts.adobe.com/fonts/source-sans">Source Sans Pro</a>.</p>
<p>In my Emacs config, I have set these fonts outside the Org section, under
&ldquo;Interaction, Look &amp; Feel&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">member</span> <span class="s">&#34;Roboto Mono&#34;</span> <span class="p">(</span><span class="nf">font-family-list</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;default</span> <span class="no">nil</span> <span class="nb">:font</span> <span class="s">&#34;Roboto Mono&#34;</span> <span class="nb">:height</span> <span class="mi">108</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;fixed-pitch</span> <span class="no">nil</span> <span class="nb">:family</span> <span class="s">&#34;Roboto Mono&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">member</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="p">(</span><span class="nf">font-family-list</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;variable-pitch</span> <span class="no">nil</span> <span class="nb">:family</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="nb">:height</span> <span class="mf">1.18</span><span class="p">))</span>
</span></span></code></pre></div><p>Then, back in the Org-specific part of the config, I resize the Org headings and choose Source Sans
Pro to be the header font.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="c1">;; Resize Org headings</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">face</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">org-level-1</span> <span class="o">.</span> <span class="mf">1.35</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-2</span> <span class="o">.</span> <span class="mf">1.3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-3</span> <span class="o">.</span> <span class="mf">1.2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-4</span> <span class="o">.</span> <span class="mf">1.1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-5</span> <span class="o">.</span> <span class="mf">1.1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-6</span> <span class="o">.</span> <span class="mf">1.1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-7</span> <span class="o">.</span> <span class="mf">1.1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="nv">org-level-8</span> <span class="o">.</span> <span class="mf">1.1</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">face</span><span class="p">)</span> <span class="no">nil</span> <span class="nb">:font</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="nb">:weight</span> <span class="ss">&#39;bold</span> <span class="nb">:height</span> <span class="p">(</span><span class="nf">cdr</span> <span class="nv">face</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">;; Make the document title a bit bigger</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-document-title</span> <span class="no">nil</span> <span class="nb">:font</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="nb">:weight</span>
</span></span><span class="line"><span class="cl"><span class="ss">&#39;bold</span> <span class="nb">:height</span> <span class="mf">1.8</span><span class="p">)</span>
</span></span></code></pre></div><p>In order to avoid line spacing issues when a line of text contains both
variable- and fixed-pitch text, we need to make sure that the <code>org-indent</code> face
inherits from <code>fixed-pitch</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;org-indent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-indent</span> <span class="no">nil</span> <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">org-hide</span> <span class="nv">fixed-pitch</span><span class="p">))</span>
</span></span></code></pre></div><p>And then, we want to make sure that some parts of the Org document
always use fixed-pitch even when <code>variable-pitch-mode</code> is on.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-block</span> <span class="no">nil</span>            <span class="nb">:foreground</span> <span class="no">nil</span> <span class="nb">:inherit</span>
</span></span><span class="line"><span class="cl"><span class="ss">&#39;fixed-pitch</span> <span class="nb">:height</span> <span class="mf">0.85</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-code</span> <span class="no">nil</span>             <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">shadow</span> <span class="nv">fixed-pitch</span><span class="p">)</span> <span class="nb">:height</span> <span class="mf">0.85</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-indent</span> <span class="no">nil</span>           <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">org-hide</span> <span class="nv">fixed-pitch</span><span class="p">)</span> <span class="nb">:height</span> <span class="mf">0.85</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-verbatim</span> <span class="no">nil</span>         <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">shadow</span> <span class="nv">fixed-pitch</span><span class="p">)</span> <span class="nb">:height</span> <span class="mf">0.85</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-special-keyword</span> <span class="no">nil</span>  <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">font-lock-comment-face</span>
</span></span><span class="line"><span class="cl"><span class="nv">fixed-pitch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-meta-line</span> <span class="no">nil</span>        <span class="nb">:inherit</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">font-lock-comment-face</span> <span class="nv">fixed-pitch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;org-checkbox</span> <span class="no">nil</span>         <span class="nb">:inherit</span> <span class="ss">&#39;fixed-pitch</span><span class="p">)</span>
</span></span></code></pre></div><p>For this all to come together, we need to make sure that  <code>variable-pitch-mode</code> is always active in Org buffers.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-mode-hook</span> <span class="ss">&#39;variable-pitch-mode</span><span class="p">)</span>
</span></span></code></pre></div><p>Also, if you&rsquo;re having troubles with the size of LaTeX-previews like I did, you
can increase the size like so.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">plist-put</span> <span class="nv">org-format-latex-options</span> <span class="nb">:scale</span> <span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="decluttering">Decluttering<a hidden class="anchor" aria-hidden="true" href="#decluttering">#</a></h3>
<p>We&rsquo;ll use <a href="https://orgmode.org/manual/Special-Symbols.html">&ldquo;pretty entities&rdquo;</a>, which allow us to
insert special characters LaTeX-style by using a leading backslash (e.g., <code>\alpha</code> to
write the greek letter alpha). <code>org-ellipsis</code> is the symbol displayed after an
Org-heading that is collapsed - I prefer a simple dot.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-adapt-indentation</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">      <span class="nv">org-hide-leading-stars</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">      <span class="nv">org-pretty-entities</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-ellipsis</span> <span class="s">&#34;  ·&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>For source code blocks specifically, I want Org to display the contents using
the major mode of the relevant language. I also want TAB to behave inside the
source code block like it normally would when writing code in that language.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-src-fontify-natively</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-src-tab-acts-natively</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">      <span class="nv">org-edit-src-content-indentation</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>It&rsquo;s common to hide emphasis markers (e.g., <code>/.../</code> for italics, <code>*...*</code> for bold,
etc.) to have a cleaner visual look, but this makes it harder to edit the text.
<a href="https://github.com/awth13/org-appear">org-appear</a> is the solution to all my troubles. It displays the markers when the
cursor is within them and hides them otherwise, making edits easy while looking
pretty.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">org-appear</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:commands</span> <span class="p">(</span><span class="nv">org-appear-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span>     <span class="p">(</span><span class="nv">org-mode</span> <span class="o">.</span> <span class="nv">org-appear-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-hide-emphasis-markers</span> <span class="no">t</span><span class="p">)</span>  <span class="c1">; Must be activated for org-appear to work</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-appear-autoemphasis</span>   <span class="no">t</span>   <span class="c1">; Show bold, italics, verbatim, etc.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">org-appear-autolinks</span>      <span class="no">t</span>   <span class="c1">; Show links</span>
</span></span><span class="line"><span class="cl">		<span class="nv">org-appear-autosubmarkers</span> <span class="no">t</span><span class="p">))</span> <span class="c1">; Show sub- and superscripts</span>
</span></span></code></pre></div><p>And finally, I have some Org options to deal with headers and TODO&rsquo;s nicely.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-log-done</span>                       <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-auto-align-tags</span>                <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-tags-column</span>                    <span class="mi">-80</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-fold-catch-invisible-edits</span>     <span class="ss">&#39;show-and-error</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-special-ctrl-a/e</span>               <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">org-insert-heading-respect-content</span> <span class="no">t</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="latex-previews">LaTeX Previews<a hidden class="anchor" aria-hidden="true" href="#latex-previews">#</a></h3>
<p>The LaTeX previews in Org mode are pretty small by default, so I&rsquo;ll increase
their size a little.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">plist-put</span> <span class="nv">org-format-latex-options</span> <span class="nb">:scale</span> <span class="mf">1.35</span><span class="p">)</span>
</span></span></code></pre></div><p><a href="https://github.com/io12/org-fragtog">org-fragtog</a> works like org-appear, but for LaTeX fragments: It toggles LaTeX
previews on and off automatically, depending on the cursor position. If you move the
cursor to a preview, it&rsquo;s toggled off so you can edit the LaTeX snippet. When
you move the cursor away, the preview is turned on again.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">org-fragtog</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">(</span><span class="nv">org-mode-hook</span> <span class="o">.</span> <span class="nv">org-fragtog-mode</span><span class="p">))</span>
</span></span></code></pre></div><h3 id="centring-and-line-breaks">Centring &amp; Line Breaks<a hidden class="anchor" aria-hidden="true" href="#centring-and-line-breaks">#</a></h3>
<p>I want the text to fill the screen adaptively, so that long lines of text adapt
to the size of the window. It also breaks lines instead of truncating them.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-mode-hook</span> <span class="ss">&#39;visual-line-mode</span><span class="p">)</span>
</span></span></code></pre></div><p>I prefer having my Org buffer centred. I think it looks prettier when I only
have one buffer open, and it&rsquo;s barely noticeable when several are open because
the width of the margins adapt. For this, I use <a href="https://github.com/rnkn/olivetti">Olivetti</a>, which I think is a
great package for this purpose.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-mode-hook</span> <span class="ss">&#39;olivetti-mode</span><span class="p">)</span>
</span></span></code></pre></div><p>As you can see in the below screenshot, the Org document fills up the left side
of the screen comfortably even when <code>olivetti-mode</code> is on.</p>
<figure><a href="/img/split-screen.png">
    <img loading="lazy" src="/img/split-screen.png"/> </a>
</figure>

<h3 id="task-and-time-tracking">Task &amp; Time Tracking<a hidden class="anchor" aria-hidden="true" href="#task-and-time-tracking">#</a></h3>
<p>Org mode is also a really powerful tool for tracking tasks and time usage.
However, the default colours don&rsquo;t go too well with our new look.</p>
<p>Of course, you
should change the keywords and the number of priorities to suit your tastes. I
have lifted my colours straight from the official <a href="https://www.nordtheme.com/docs/colors-and-palettes">Nord theme pallette</a> so that
they go well with my preferred theme.</p>
<p>Let&rsquo;s set the number of task priorities and specify the colour for each
priority.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-lowest-priority</span> <span class="sc">?F</span><span class="p">)</span>  <span class="c1">;; Gives us priorities A through F</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-default-priority</span> <span class="sc">?E</span><span class="p">)</span> <span class="c1">;; If an item has no priority, it is considered [#E].</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-priority-faces</span>
</span></span><span class="line"><span class="cl">      <span class="o">&#39;</span><span class="p">((</span><span class="mi">65</span> <span class="o">.</span> <span class="s">&#34;#BF616A&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mi">66</span> <span class="o">.</span> <span class="s">&#34;#EBCB8B&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mi">67</span> <span class="o">.</span> <span class="s">&#34;#B48EAD&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mi">68</span> <span class="o">.</span> <span class="s">&#34;#81A1C1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mi">69</span> <span class="o">.</span> <span class="s">&#34;#5E81AC&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="mi">70</span> <span class="o">.</span> <span class="s">&#34;#4C566A&#34;</span><span class="p">)))</span>
</span></span></code></pre></div><p>And then the custom keywords.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-todo-keywords</span>
</span></span><span class="line"><span class="cl">      <span class="o">&#39;</span><span class="p">((</span><span class="nv">sequence</span>
</span></span><span class="line"><span class="cl">		 <span class="s">&#34;TODO(t)&#34;</span> <span class="s">&#34;WAIT(w)&#34;</span> <span class="s">&#34;READ(r)&#34;</span> <span class="s">&#34;PROG(p)&#34;</span> <span class="c1">; Needs further action</span>
</span></span><span class="line"><span class="cl">		 <span class="s">&#34;|&#34;</span>
</span></span><span class="line"><span class="cl">		 <span class="s">&#34;DONE(d)&#34;</span><span class="p">)))</span>                            <span class="c1">; Needs no action currently</span>
</span></span></code></pre></div><p>I don&rsquo;t set the colours of each TODO state individually anymore, but if you
wanted to, you could set the <code>org-todo-keyword-faces</code> variable like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">org-todo-keyword-faces</span>
</span></span><span class="line"><span class="cl">      <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;TODO(t)&#34;</span>      <span class="nb">:inherit</span> <span class="p">(</span><span class="nv">org-todo</span> <span class="nv">region</span><span class="p">)</span> <span class="nb">:foreground</span> <span class="s">&#34;#A3BE8C&#34;</span> <span class="nb">:weight</span> <span class="nv">bold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span><span class="p">))</span>
</span></span></code></pre></div><h3 id="bullets">Bullets<a hidden class="anchor" aria-hidden="true" href="#bullets">#</a></h3>
<p><a href="https://github.com/integral-dw/org-superstar-mode">org-superstar</a>  styles some of my UI elements, such as bullets and special
checkboxes for TODOs. It can style a lot more, so I recommend checking the
package out!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">org-superstar</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-superstar-leading-bullet</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-superstar-headline-bullets-list</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;◉&#34;</span> <span class="s">&#34;○&#34;</span> <span class="s">&#34;⚬&#34;</span> <span class="s">&#34;◈&#34;</span> <span class="s">&#34;◇&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-superstar-special-todo-items</span> <span class="no">t</span><span class="p">)</span> <span class="c1">;; Makes TODO header bullets into boxes</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">org-superstar-todo-bullet-alist</span> <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;TODO&#34;</span>  <span class="o">.</span> <span class="mi">9744</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                          <span class="p">(</span><span class="s">&#34;WAIT&#34;</span>  <span class="o">.</span> <span class="mi">9744</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                          <span class="p">(</span><span class="s">&#34;READ&#34;</span>  <span class="o">.</span> <span class="mi">9744</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                          <span class="p">(</span><span class="s">&#34;PROG&#34;</span>  <span class="o">.</span> <span class="mi">9744</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">										  <span class="p">(</span><span class="s">&#34;DONE&#34;</span>  <span class="o">.</span> <span class="mi">9745</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">(</span><span class="nv">org-mode</span> <span class="o">.</span> <span class="nv">org-superstar-mode</span><span class="p">))</span>
</span></span></code></pre></div><h3 id="svg-elements">SVG Elements<a hidden class="anchor" aria-hidden="true" href="#svg-elements">#</a></h3>
<p>I use <a href="https://github.com/rougier/svg-tag-mode">svg-tag-mode</a> to replace progress bars, task priorities, dates, and citations with nice SVG
graphics. This package can also style many more elements and I&rsquo;d encourage you
to read the documentation to find other things you might want to style with
this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">svg-tag-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defconst</span> <span class="nv">date-re</span> <span class="s">&#34;[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defconst</span> <span class="nv">time-re</span> <span class="s">&#34;[0-9]\\{2\\}:[0-9]\\{2\\}&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defconst</span> <span class="nv">day-re</span> <span class="s">&#34;[A-Za-z]\\{3\\}&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defconst</span> <span class="nv">day-time-re</span> <span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\(%s\\)? ?\\(%s\\)?&#34;</span> <span class="nv">day-re</span> <span class="nv">time-re</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">svg-progress-percent</span> <span class="p">(</span><span class="nv">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nv">svg-image</span> <span class="p">(</span><span class="nv">svg-lib-concat</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nv">svg-lib-progress-bar</span> <span class="p">(</span><span class="nf">/</span> <span class="p">(</span><span class="nf">string-to-number</span> <span class="nv">value</span><span class="p">)</span> <span class="mf">100.0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			      <span class="no">nil</span> <span class="nb">:margin</span> <span class="mi">0</span> <span class="nb">:stroke</span> <span class="mi">2</span> <span class="nb">:radius</span> <span class="mi">3</span> <span class="nb">:padding</span> <span class="mi">2</span> <span class="nb">:width</span> <span class="mi">11</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">(</span><span class="nv">svg-lib-tag</span> <span class="p">(</span><span class="nf">concat</span> <span class="nv">value</span> <span class="s">&#34;%&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				  <span class="no">nil</span> <span class="nb">:stroke</span> <span class="mi">0</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))</span> <span class="nb">:ascent</span> <span class="ss">&#39;center</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">defun</span> <span class="nv">svg-progress-count</span> <span class="p">(</span><span class="nv">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="nb">let*</span> <span class="p">((</span><span class="nv">seq</span> <span class="p">(</span><span class="nf">mapcar</span> <span class="nf">#&#39;string-to-number</span> <span class="p">(</span><span class="nv">split-string</span> <span class="nv">value</span> <span class="s">&#34;/&#34;</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="nv">count</span> <span class="p">(</span><span class="nf">float</span> <span class="p">(</span><span class="nf">car</span> <span class="nv">seq</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="nv">total</span> <span class="p">(</span><span class="nf">float</span> <span class="p">(</span><span class="nv">cadr</span> <span class="nv">seq</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">	  <span class="p">(</span><span class="nv">svg-image</span> <span class="p">(</span><span class="nv">svg-lib-concat</span>
</span></span><span class="line"><span class="cl">				  <span class="p">(</span><span class="nv">svg-lib-progress-bar</span> <span class="p">(</span><span class="nf">/</span> <span class="nv">count</span> <span class="nv">total</span><span class="p">)</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">					<span class="nb">:margin</span> <span class="mi">0</span> <span class="nb">:stroke</span> <span class="mi">2</span> <span class="nb">:radius</span> <span class="mi">3</span> <span class="nb">:padding</span> <span class="mi">2</span> <span class="nb">:width</span> <span class="mi">11</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				  <span class="p">(</span><span class="nv">svg-lib-tag</span> <span class="nv">value</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">					<span class="nb">:stroke</span> <span class="mi">0</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))</span> <span class="nb">:ascent</span> <span class="ss">&#39;center</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">svg-tag-tags</span>
</span></span><span class="line"><span class="cl">      <span class="o">`</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="c1">;; Task priority</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="s">&#34;\\[#[A-Z]\\]&#34;</span> <span class="o">.</span> <span class="p">(</span> <span class="p">(</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                              <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:face</span> <span class="ss">&#39;org-priority</span>
</span></span><span class="line"><span class="cl">                                            <span class="nb">:beg</span> <span class="mi">2</span> <span class="nb">:end</span> <span class="mi">-1</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Progress</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="s">&#34;\\(\\[[0-9]\\{1,3\\}%\\]\\)&#34;</span> <span class="o">.</span> <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="nv">svg-progress-percent</span> <span class="p">(</span><span class="nf">substring</span> <span class="nv">tag</span> <span class="mi">1</span> <span class="mi">-2</span><span class="p">)))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="s">&#34;\\(\\[[0-9]+/[0-9]+\\]\\)&#34;</span> <span class="o">.</span> <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">          <span class="p">(</span><span class="nv">svg-progress-count</span> <span class="p">(</span><span class="nf">substring</span> <span class="nv">tag</span> <span class="mi">1</span> <span class="mi">-1</span><span class="p">)))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Citation of the form [cite:@Knuth:1984]</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="s">&#34;\\(\\[cite:@[A-Za-z]+:\\)&#34;</span> <span class="o">.</span> <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                          <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span>
</span></span><span class="line"><span class="cl">                                                        <span class="nb">:inverse</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">                                                        <span class="nb">:beg</span> <span class="mi">7</span> <span class="nb">:end</span> <span class="mi">-1</span>
</span></span><span class="line"><span class="cl">                                                        <span class="nb">:crop-right</span> <span class="no">t</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="s">&#34;\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)&#34;</span> <span class="o">.</span> <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span>
</span></span><span class="line"><span class="cl">                                                              <span class="nb">:end</span> <span class="mi">-1</span>
</span></span><span class="line"><span class="cl">                                                              <span class="nb">:crop-left</span> <span class="no">t</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Active date (with or without day name, with or without time)</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\(&lt;%s&gt;\\)&#34;</span> <span class="nv">date-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">         <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:beg</span> <span class="mi">1</span> <span class="nb">:end</span> <span class="mi">-1</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\(&lt;%s \\)%s&gt;&#34;</span> <span class="nv">date-re</span> <span class="nv">day-time-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">         <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:beg</span> <span class="mi">1</span> <span class="nb">:inverse</span> <span class="no">nil</span> <span class="nb">:crop-right</span> <span class="no">t</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;&lt;%s \\(%s&gt;\\)&#34;</span> <span class="nv">date-re</span> <span class="nv">day-time-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">         <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:end</span> <span class="mi">-1</span> <span class="nb">:inverse</span> <span class="no">t</span> <span class="nb">:crop-left</span> <span class="no">t</span> <span class="nb">:margin</span> <span class="mi">0</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Inactive date  (with or without day name, with or without time)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\(\\[%s\\]\\)&#34;</span> <span class="nv">date-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">          <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:beg</span> <span class="mi">1</span> <span class="nb">:end</span> <span class="mi">-1</span> <span class="nb">:margin</span> <span class="mi">0</span> <span class="nb">:face</span> <span class="ss">&#39;org-date</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\(\\[%s \\)%s\\]&#34;</span> <span class="nv">date-re</span> <span class="nv">day-time-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">          <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:beg</span> <span class="mi">1</span> <span class="nb">:inverse</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">						       <span class="nb">:crop-right</span> <span class="no">t</span> <span class="nb">:margin</span> <span class="mi">0</span> <span class="nb">:face</span> <span class="ss">&#39;org-date</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="o">,</span><span class="p">(</span><span class="nf">format</span> <span class="s">&#34;\\[%s \\(%s\\]\\)&#34;</span> <span class="nv">date-re</span> <span class="nv">day-time-re</span><span class="p">)</span> <span class="o">.</span>
</span></span><span class="line"><span class="cl">          <span class="p">((</span><span class="nb">lambda</span> <span class="p">(</span><span class="nv">tag</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">             <span class="p">(</span><span class="nv">svg-tag-make</span> <span class="nv">tag</span> <span class="nb">:end</span> <span class="mi">-1</span> <span class="nb">:inverse</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">						       <span class="nb">:crop-left</span> <span class="no">t</span> <span class="nb">:margin</span> <span class="mi">0</span> <span class="nb">:face</span> <span class="ss">&#39;org-date</span><span class="p">)))))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-mode-hook</span> <span class="ss">&#39;svg-tag-mode</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="prettify-tags-and-keywords">Prettify Tags &amp; Keywords<a hidden class="anchor" aria-hidden="true" href="#prettify-tags-and-keywords">#</a></h3>
<p>I have a custom function to prettify tags and other elements, lifted from <a href="https://github.com/jakebox/jake-emacs/blob/main/jake-emacs/jib-funcs.el">Jake
B&rsquo;s Emacs setup</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defun</span> <span class="nv">my/prettify-symbols-setup</span> <span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="c1">;; Checkboxes</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;[ ]&#34;</span> <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;[X]&#34;</span> <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;[-]&#34;</span> <span class="o">.</span> <span class="s">&#34;&#34;</span> <span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">;; org-abel</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+BEGIN_SRC&#34;</span> <span class="o">.</span> <span class="sc">?≫</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+END_SRC&#34;</span> <span class="o">.</span> <span class="sc">?≫</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+begin_src&#34;</span> <span class="o">.</span> <span class="sc">?≫</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+end_src&#34;</span> <span class="o">.</span> <span class="sc">?≫</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+BEGIN_QUOTE&#34;</span> <span class="o">.</span> <span class="sc">?❝</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;#+END_QUOTE&#34;</span> <span class="o">.</span> <span class="sc">?❞</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">;; Drawers</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:PROPERTIES:&#34;</span> <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">;; Tags</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:projects:&#34;</span> <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:work:&#34;</span>     <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:inbox:&#34;</span>    <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:task:&#34;</span>     <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:thesis:&#34;</span>   <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:uio:&#34;</span>      <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:emacs:&#34;</span>    <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:learn:&#34;</span>    <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">push</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&#34;:code:&#34;</span>     <span class="o">.</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="nv">prettify-symbols-alist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">prettify-symbols-mode</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-mode-hook</span>        <span class="nf">#&#39;</span><span class="nv">my/prettify-symbols-setup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;org-agenda-mode-hook</span> <span class="nf">#&#39;</span><span class="nv">my/prettify-symbols-setup</span><span class="p">)</span>
</span></span></code></pre></div><p>After all this prettification, TODOs, code blocks, and lists look like
screenshot below.</p>
<figure><a href="/img/todos.png">
    <img loading="lazy" src="/img/todos.png"/> </a>
</figure>

<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>There it is, that&rsquo;s pretty much all of the visual Org-specific code in my
config. If you&rsquo;re interested in other aspects of my config, you&rsquo;re of course
welcome to <a href="https://github.com/SophieBosio/.emacs.d">check it out</a>. I&rsquo;m just starting out, so I&rsquo;d also really appreciate constructive criticism or tips!</p>
<h2 id="boa-interpreter-haskell">Scrapped: Implementing a Small Interpreter in Haskell :functional:programming:haskell:monads<a hidden class="anchor" aria-hidden="true" href="#boa-interpreter-haskell">#</a></h2>
<p>One of my favourite assignments in my advanced functional programming course,
was implementing a parser and interpreter for a subset of Python, called Boa, in
Haskell.</p>
<p>We&rsquo;d just started getting a grasp of what monads are and how they work, and this
project is what really solidified it for me. Here&rsquo;s how we approached it and
some of my reflections when looking back at it.</p>
<p>I&rsquo;ll be focusing on the interpreter, because we implemented the monad for the
interpreter by hand, and I feel it&rsquo;s easier to see how monads work when seeing
the implementation. The parser, on the other hand, uses the monad combinator
library Parsec, which is both more complicated and more well-documented elsewhere.</p>
<p>I&rsquo;ll assume you&rsquo;re familiar with monads and their operations, but this is also a
great project to try your hand at if you&rsquo;re still getting the hang of using them.</p>
<p>The code is available in its entirety on my <a href="https://github.com/SophieBosio/boa">GitHub</a>, and I would encourage you to
follow along!</p>
<h3 id="the-boa-language">The Boa Language<a hidden class="anchor" aria-hidden="true" href="#the-boa-language">#</a></h3>
<p>The Boa language is a small subset of Python. It looks pretty familiar to anyone
who has programmed in Python before, and if you&rsquo;re interested in a more thorough
explanation of the language, you can check out the <code>./docs</code> folder in the repo.</p>
<p>The most important aspects of the language, for our interpreter, is that it has
global state. In our purely functional implementation language, computations are
normally <em>not</em> stateful. So, we have to make use of a monad to model the program
environment and interpret terms with respect to the existing bindings.</p>
<p>Thankfully, Boa computations can make do with read-only access to the
environment. Therefore, we can use a neat and (as far as monads go) pretty
intuitive monad, namely the <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html">Reader monad</a>. We&rsquo;ll implement it ourselves, but you
could also just import the above package in your project.</p>
<h4 id="spoiler-alert-syntax-file">Spoiler Alert! Syntax File<a hidden class="anchor" aria-hidden="true" href="#spoiler-alert-syntax-file">#</a></h4>
<p>Below, you can find the finished <code>Syntax.hs</code> file. If you want to implement the
language yourself, you might want to try your hand at writing this file, too,
before seeing this suggestion.</p>
<details>
<summary><code>Syntax.hs</code></summary>
<div class="details">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Syntax</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Value</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">None</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Boolean</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Number</span>  <span class="kt">Integer</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Text</span>    <span class="kt">String</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">List</span>    <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Expression</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Constant</span>  <span class="kt">Value</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Variable</span>  <span class="kt">VariableName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Operation</span> <span class="kt">OperationSymbol</span> <span class="kt">Expression</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Call</span> <span class="kt">FunctionName</span> <span class="kt">FunctionInput</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">ListExpression</span>    <span class="p">[</span><span class="kt">Expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">ListComprehension</span> <span class="kt">Expression</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">VariableName</span>      <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionName</span>      <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionInput</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">Expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionArguments</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">OperationSymbol</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Plus</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Minus</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Times</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Div</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Mod</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Eq</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Less</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Greater</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">In</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Clause</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">For</span> <span class="kt">VariableName</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">If</span>               <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Program</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Statement</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Statement</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Define</span>  <span class="kt">VariableName</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Execute</span>              <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span></code></pre></div></div>
</details>
<h3 id="monad-implementation">Monad Implementation<a hidden class="anchor" aria-hidden="true" href="#monad-implementation">#</a></h3>
<p>Executing a Boa program means evaluating all the program statements, starting
from the empty environment and populating it as we go. If we encounter any
runtime errors underway, we&rsquo;ll stop execution and print an error message. If all
is well, we&rsquo;ll continue until there are no more statements, and then print the output of the program.</p>
<p>Let&rsquo;s use the following abbreviations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Output</span>      <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">ErrorMessage</span> <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">RuntimeError</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">UnboundVariable</span> <span class="kt">VariableName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">BadFunction</span>     <span class="kt">FunctionName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">BadArgument</span>     <span class="kt">ErrorMessage</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Environment</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">VariableName</span><span class="p">,</span> <span class="kt">Value</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Runtime</span> <span class="n">a</span>   <span class="ow">=</span> <span class="kt">Environment</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">RuntimeError</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span>
</span></span></code></pre></div><p>An environment is a mapping from variable names to values. What we want is a
monad that allows us to keep track of the variable bindings in the environment.
When we want to perform a computation, we need a runtime where we can read from
the environment and either raise a runtime error or return a value, and append
the output from the computation so we can print it later.
This is essentially what we would want to use the Reader monad for! Let&rsquo;s
implement a simple version.</p>
<h4 id="the-boa-monad">The Boa Monad<a hidden class="anchor" aria-hidden="true" href="#the-boa-monad">#</a></h4>
<p>Every monad is an applicative functor and every applicative functor is a
functor. Those are interesting to read about in their own right, but for now, we
just need to know that if we implement the monad correctly, we get these two for
free. For these freebies, we need to import <code>Control.Monad</code>. We&rsquo;ll also need a
newtype <code>Boa a</code>, whose &ldquo;run&rdquo; action will have the type <code>Runtime a</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Boa</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">{</span><span class="n">run</span> <span class="ow">::</span> <span class="kt">Runtime</span> <span class="n">a</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">instace</span> <span class="kt">Applicative</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span>  <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</span></span></code></pre></div><p>Nice! Now, we need to define two functions for our monad, namely
<code>return</code> and <code>&gt;&gt;=</code>, and we have a fully fledged monad instance!</p>
<p>For a quick refresher, let&rsquo;s look at their type signatures.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">return</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span></code></pre></div><p>In the case of <code>return</code>, we just want to take a value and put it inside the monad.
What&rsquo;s the simplest way we can do that? Well, our monad lets us read from the
environment and we&rsquo;re supposed to
return either an error message or a value <code>a</code>, and then the output we want to
print after the computation is done. The simplest way, then, is to not read
anything from the environment, just put in the value, and not add anything to the
output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">ba</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Essentially, this says &ldquo;I don&rsquo;t care about the environment, just give me the
tuple with <code>a</code> and no output in it, then put it all inside the Boa monad for me&rdquo;.
The following notation is semantically equivalent, but the syntax may be easier
to read depending on what you&rsquo;re used to.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">))</span>
</span></span></code></pre></div><p>Then what do we want to do for <code>&gt;&gt;=</code>, is define a way to take a value out of the monad,
apply a function to it, and then put the result back into the monad. To unwrap
the value <code>a</code> from <code>ba</code>, we can simply use our monad&rsquo;s <code>run</code> function. We have to take
in an environment so that we can run the
monad in the environment and look at  the result. If it&rsquo;s an error, then we just
return the error. But if we get a value <code>a</code> out and some output, then we want to run
the function <code>f</code> on <code>a</code>. What we&rsquo;re gonna return, is the result of <code>f a</code> and the
output of that computation appended to all the previous output. Finally, we put
it all back into the Boa monad.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">ba</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">case</span> <span class="n">run</span> <span class="n">ba</span> <span class="n">env</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>      <span class="c1">-- just return the error</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">out&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">run</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">env</span>  <span class="c1">-- run f a in the environment</span>
</span></span><span class="line"><span class="cl">        <span class="kr">in</span>  <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">out</span> <span class="o">++</span> <span class="n">out&#39;</span><span class="p">)</span>           <span class="c1">-- append the new output to the old</span>
</span></span></code></pre></div><p>Sweet! Now let&rsquo;s define some operations that let us interact with the monad in a
more ergonomic way.</p>
<h4 id="monad-operations">Monad Operations<a hidden class="anchor" aria-hidden="true" href="#monad-operations">#</a></h4>
<p>Now we have the monad itself, but it&rsquo;s nice to abstract away some details and
instead work with more intuitive function names. Let&rsquo;s write some functions with
more easily understood names.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">abort</span>  <span class="ow">::</span> <span class="kt">RuntimeError</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">look</span>   <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span>   <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Boa</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">output</span> <span class="ow">::</span> <span class="kt">String</span>       <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span></code></pre></div><p><code>abort</code> should just accept a runtime error and put it into the Boa monad.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">abort</span> <span class="ow">::</span> <span class="kt">RuntimeError</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">abort</span> <span class="n">re</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- or equivalently,</span>
</span></span><span class="line"><span class="cl"><span class="nf">abort</span> <span class="n">re</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="kt">[]</span><span class="p">))</span>
</span></span></code></pre></div><p><code>look</code> should accept a variable name and look to see if it is in the environment.
if it is, return the value inside the monad. If it isn&rsquo;t, return an &ldquo;unbound
variable&rdquo; runtime error inside the monad. In either case, no output is
necessary.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">look</span> <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">look</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">env</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">a</span>  <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">UnboundVariable</span> <span class="n">x</span><span class="p">),</span> <span class="kt">[]</span><span class="p">)</span>
</span></span></code></pre></div><p><code>bind</code> takes a variable name and a value.  What it should do, is run the monad
with that name-value binding <em>prepended</em> to the old environment, and then put the
value of that computation back into the monad. It needs to be
prepended and not appended because when we perform a lookup, we want to find the
most recent bindings first.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">bind</span> <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Boa</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="n">ba</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span> <span class="n">run</span> <span class="n">ba</span> <span class="o">$</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="kt">:</span> <span class="n">env</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- or equivalently,</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="n">ba</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span> <span class="n">run</span> <span class="n">ba</span> <span class="p">(</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="o">++</span> <span class="n">env</span> <span class="p">))</span>
</span></span></code></pre></div><p><code>output</code> should take an string and put it into the monad as output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">output</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">output</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="nb">()</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
</span></span></code></pre></div><h3 id="interpreter-functions">Interpreter Functions<a hidden class="anchor" aria-hidden="true" href="#interpreter-functions">#</a></h3>
<p>Finally, we need the main operations of the interpreter. To execute a Boa
program, we want to take a program and return a tuple with the output of the
program and possibly a runtime error.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">execute</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Output</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">Runtime</span> <span class="kt">Error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">execute</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Since a <code>Program</code> is made up of <code>Define</code> and <code>Execute</code> statements, we can write a
helper function <code>exec</code> that pattern matches on the type of statement.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>And finally, we&rsquo;ll need a helper function <code>eval</code> that&rsquo;s responsible for evaluating
a single expression and putting the resulting value into the Boa monad for us.
This is what we&rsquo;ll focus on for now.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expression</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span></code></pre></div><p>Since they&rsquo;re not the most interesting part of the interpreter, I&rsquo;m omitting quite a few other helper functions, notably <code>operate :: OperationSymbol -&gt; Value -&gt; Value -&gt; Either ErrorMessage Value</code> and <code>apply :: FunctionName -&gt; FunctionArguments -&gt; Boa Value</code>. They&rsquo;re of course in the repo,
and I&rsquo;d encourage you to try implementing them yourself.</p>
<p><code>eval</code> needs to pattern match on each expression. There are the following types of
<code>Expression</code>:</p>
<ul>
<li><code>Constant</code></li>
<li><code>Variable VariableName</code></li>
<li><code>Not Expression</code></li>
<li><code>Operation OperationSymbol Expression Expression</code></li>
<li><code>Call FunctionName FunctionInput</code></li>
<li><code>ListExpression [Expression]</code></li>
<li><code>ListComprehension Expression [Clause]</code></li>
</ul>
<h4 id="constant">Constant<a hidden class="anchor" aria-hidden="true" href="#constant">#</a></h4>
<p>Let&rsquo;s start with <code>Constant</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Constant</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">v</span>
</span></span></code></pre></div><p>It&rsquo;s already a value, so we can just take it and put it directly in the
monad. Easy!</p>
<h4 id="variable">Variable<a hidden class="anchor" aria-hidden="true" href="#variable">#</a></h4>
<p>What about a variable? Well, either it&rsquo;s bound in the environment or it&rsquo;s not
and should return an error. <code>look</code> seems like a perfect fit for the job. It even
returns an error message for us if <code>x</code> is not present in the environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">look</span> <span class="n">x</span>
</span></span></code></pre></div><h4 id="not">Not<a hidden class="anchor" aria-hidden="true" href="#not">#</a></h4>
<p>If we meet a <code>Not</code> expression, we should evaluate the sub-expression to a Boolean
value, then take the opposite value, cast it as a <code>Boolean</code> and put it in the Boa
monad. Actually, we can do all of this by <code>fmap</code>-ing <code>(Boolean . not . truthy)</code> onto
the evaluated expression. That unwraps the expression, applies the three
functions above, and then wraps it back up in the monad.</p>
<p>Note that <code>&lt;$&gt;</code> is just an infix version of <code>fmap</code>, and <code>truthy</code> is a helper function that evaluates a <code>Value</code> to a Boolean value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Boolean</span> <span class="o">.</span> <span class="n">not</span> <span class="o">.</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e</span>
</span></span></code></pre></div><h4 id="operation">Operation<a hidden class="anchor" aria-hidden="true" href="#operation">#</a></h4>
<p>An <code>Operation</code> is performed by evaluating each of its arguments,
extracting the <code>Value</code> from each, using <code>operate</code> on them to get the result <code>Value</code>,
and wrapping that result back in the monad. In this case, <code>do</code>-notation makes our code much more readable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Operation</span> <span class="n">o</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v1</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e1</span>
</span></span><span class="line"><span class="cl">     <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">     <span class="kr">case</span> <span class="n">operate</span> <span class="n">o</span> <span class="n">v1</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Right</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Left</span> <span class="n">re</span> <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="n">re</span>
</span></span></code></pre></div><h4 id="call">Call<a hidden class="anchor" aria-hidden="true" href="#call">#</a></h4>
<p>Recall that <code>Call</code> takes a function name <code>f</code> and a list of expressions <code>es</code>, which is the
function input. What we want to do, is to evaluate all the function arguments,
and then send all those values to our helper function <code>apply</code>, which will apply <code>f</code>
to the evaluated <code>es</code> and put the result into the Boa monad.</p>
<p>With the help of <code>mapM</code>, we can write the function for <code>Call</code> expressions very
succinctly. Its type signature is</p>
<p><code>mapM :: (Traversable t, Monad m) ==&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</code>.</p>
<p>In our case, the traversable structure is a list and the
monad is the Boa monad. In our case, we can rewrite it as</p>
<p><code>mapM :: (Expression -&gt; Boa Value) -&gt; [Expression] -&gt; Boa ([Value])</code>.</p>
<p><code>eval</code>, of course has the type <code>Expression -&gt; Boa Value</code> and the function input has type <code>[Expression].</code></p>
<p>Great! So if we do <code>mapM eval es</code>, we&rsquo;ll get a <code>Boa [Value]</code>, where each <code>Value</code> is an
evaluated function argument. Then we just want to take this list of values out
of the monad and send it to the <code>apply f</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Call</span> <span class="n">f</span> <span class="n">es</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">f</span>
</span></span></code></pre></div><h4 id="list-expression">List Expression<a hidden class="anchor" aria-hidden="true" href="#list-expression">#</a></h4>
<p>We can do something similar for <code>ListExpression</code>, except this case is much easier!
We want to evaluate all the expressions, as above, but then all we need is to
put the results in a <code>List</code> and wrap it in the monad. Then we can just <code>fmap</code> <code>List</code>
onto the evaluated expressions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListExpression</span> <span class="n">es</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span>
</span></span></code></pre></div><h4 id="list-comprehension">List Comprehension<a hidden class="anchor" aria-hidden="true" href="#list-comprehension">#</a></h4>
<p>Now, the <code>ListComprehension</code> is probably the trickiest case to write. Once way is to write
two mutually recursive functions, the <code>eval</code> case for <code>ListComprehension</code> and a
helper function <code>comprehension</code>.</p>
<p>The <code>eval</code> case for list comprehension, does more or less the same as the
<code>ListExpression</code> does: It takes the result of evaluating the contents, and puts
the resulting <code>List</code> into the Boa monad. Then, <code>comprehension</code> is the function that
actually computes the result.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p><code>comprehension</code> takes in a list of clauses, and a <code>Clause</code> is either an if-statement
on the form <code>If Expression</code> or a for-statement
on the form <code>For VariableName Expression=</code>.</p>
<p>Therefore, <code>comprehension</code> pattern matches on three cases: The empty list, a
for-statement and more clauses, or an if-statement and more clauses.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span>    <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>In the case of the empty list, we have a list comprehension that is really just
a list expression, on the form <code>ListComprehension Expression []</code>. So in that case,
<code>comprehension</code> can just evaluate <code>e1</code> and return the list containing that one
value, inside the <code>Boa</code> monad.</p>
<p>Once again, there&rsquo;s a very handy function we can use, to write this code in a single, short
line, namely <code>&lt;&amp;&gt;</code>. It&rsquo;s implemented as <code>flip fmap</code> and has the type signature</p>
<p><code>(&lt;&amp;&gt;) :: Functor f ==&gt; f a -&gt; (a -&gt; b) -&gt; f b.</code></p>
<p>In our case, we&rsquo;re applying it like this,</p>
<p><code>(&lt;&amp;&gt;) :: Boa Value -&gt; (Value -&gt; [Value]) -&gt; Boa [Value]</code>.</p>
<p>The <code>return</code> we&rsquo;re using here is the <code>return</code> of the list monad. Basically, we&rsquo;re
saying &ldquo;evaluate <code>e1</code>, which gives us a <code>Boa Value</code>. Then, take that value out of
the <code>Boa</code> monad, put it into the list monad with <code>return</code>, and finally put that list
with the value back in the <code>Boa</code> monad&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span>    <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><blockquote>
<p>Recall that the result of evaluating a list comprehension should be on the form
<code>Boa (List [Value])</code>, which (because <code>List [Value]</code> is itself a <code>Value</code>) is just a <code>Boa Value</code>. When we return from <code>comprehension</code> to <code>eval</code>, we can <code>fmap</code> the constructor <code>List</code> onto
the <code>Boa [Value]</code>, which accomplishes exactly this: It turns the result <code>Boa [Value]</code> into
<code>Boa (List [Value])</code>.</p>
</blockquote>
<p>When we encounter an <code>If</code>-expression, the syntax corresponds to <code>e1 if e2</code> . So we
know that the expression <code>e2</code> should be a Boolean value. Luckily, in Boa as in
Python, non-Boolean values correspond to a Boolean value. E.g., <code>1==True</code> is true
and <code>0==True</code> is false.The first thing we can do, then, is to evaluate <code>e2</code> and find
the corresponding Boolean value with <code>truthy</code>.</p>
<p>By <code>fmap</code>-ing <code>truthy</code> onto the evaluated expression, we get a <code>Boa Bool</code>, i.e., a
normal Haskell Boolean inside the Boa monad. By using <code>do</code>-notation, then, we can
give <code>b</code> the unwrapped Boolean and we can use it directly in an if-statement. If the condition <code>b</code> holds,
then evaluate the rest of the list comprehension. Else, there&rsquo;s no more to evaluate.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>The case for <code>For</code> statements is probably the hardest to read, but it&rsquo;s not that
bad now that we&rsquo;re more familiar with <code>&lt;$&gt;</code> and <code>mapM</code>.</p>
<p>The corresponding syntax is <code>e1 for x in e2</code> so we know that <code>e2</code> is the list where
we should bind the variable name <code>x</code> to an element, for each iteration.</p>
<p>We evaluate <code>e2</code> to <code>v2</code>. If <code>v2</code> is not iterable, then it&rsquo;s
not possible to use it in a for-statement and we should throw an error. If it&rsquo;s
a list, then we want to
bind each value in <code>xs</code> to <code>x</code> inside the rest of the comprehension, <code>c2</code>.</p>
<p>Recall the following function types.</p>
<p><code>comprehension :: [Clause] -&gt; Boa [Value]</code></p>
<p><code>bind :: VariableName -&gt; Value -&gt; (Boa a -&gt; Boa a)</code></p>
<p><code>mapM :: (a -&gt; m b) -&gt; [a] -&gt; m ([b])</code></p>
<p>We want to do <code>bind x v (comprehension c2)</code>, where <code>v</code> is each of the values from <code>xs</code>. We
already have the variable name <code>x</code> and the comprehension <code>c2</code>, but <code>bind</code> needs a
single value <code>v</code>, whereas <code>xs</code> is a <em>list</em> of values. Time for some <code>mapM</code> magic.</p>
<p>Since <code>xs</code> has the type <code>[Value]</code>, we can rewrite <code>mapM</code> as</p>
<p><code>mapM :: (Value -&gt; Boa Value) -&gt; [Value] -&gt; Boa [Value]</code></p>
<p>Then <code>xs</code> can be the second argument! In order for <code>bind</code> to be the first argument,
we can write an anonymous function <code>(\v -&gt; bind x v (comprehension c2)) :: Value -&gt; Boa Value</code>.</p>
<p>Now <code>mapM (\v -&gt; bind x v (comprehension c2)) xs</code> does exactly what we wanted it
to do! Except that we&rsquo;re mapping a function that returns a list, over a list,
so the result is a <code>Boa [[Value]]</code>. To fix this, we can simply <code>fmap</code> the function
<code>concat</code> over the result to turn it into a single, flat list and put it inside
the Boa monad. And <strong>then</strong>, we&rsquo;re all done with <code>eval</code>!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">case</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="kt">List</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="p">(</span><span class="nf">\</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">comprehension</span> <span class="n">c2</span><span class="p">))</span> <span class="n">xs</span>
</span></span><span class="line"><span class="cl">           <span class="kr">_</span>         <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="o">$</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Argument &#34;</span> <span class="o">++</span> <span class="n">showValue</span> <span class="n">v2</span> <span class="o">++</span> <span class="s">&#34; is not iterable&#34;</span>
</span></span></code></pre></div><blockquote>
<p>If <code>eval</code> and <code>comprehension</code> look completely crazy to you - especially if you&rsquo;re
wondering how we can use <code>e1</code> inside of <code>comprehension</code> - I&rsquo;d recommend reading
about <em>closures</em> and <em>mutually recursive</em> functions. It&rsquo;s really powerful stuff, but
I was definitely confused the first time I saw it!</p>
</blockquote>
<h3 id="putting-it-all-together">Putting It All Together<a hidden class="anchor" aria-hidden="true" href="#putting-it-all-together">#</a></h3>
<p>Now we have the following <code>eval</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expression</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Constant</span> <span class="n">v</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">x</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">look</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Operation</span> <span class="n">o</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span>       <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v1</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e1</span>
</span></span><span class="line"><span class="cl">     <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">     <span class="kr">case</span> <span class="n">operate</span> <span class="n">o</span> <span class="n">v1</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Right</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Left</span> <span class="n">re</span> <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="n">re</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">e</span><span class="p">)</span>                   <span class="ow">=</span> <span class="kt">Boolean</span> <span class="o">.</span> <span class="n">not</span> <span class="o">.</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Call</span> <span class="n">f</span> <span class="n">es</span><span class="p">)</span>               <span class="ow">=</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">f</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListExpression</span> <span class="n">es</span><span class="p">)</span>       <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">case</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="kt">List</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="p">(</span><span class="nf">\</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">comprehension</span> <span class="n">c2</span><span class="p">))</span> <span class="n">xs</span>
</span></span><span class="line"><span class="cl">           <span class="kr">_</span>         <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="o">$</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Argument &#34;</span> <span class="o">++</span> <span class="n">showValue</span> <span class="n">v2</span> <span class="o">++</span> <span class="s">&#34; is not iterable&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span></code></pre></div><p>At this point, all we need is to write <code>exec</code> and <code>execute</code>!</p>
<p><code>exec</code> should just perform the computations in order and collect the output. It
doesn&rsquo;t need to keep track of which value was just computed, so the return type
of <code>exec</code> is just <code>Boa ()</code>.</p>
<p>We decided earlier that it should pattern match on
<code>Define</code> and <code>Execute</code> statements. If it&rsquo;s a definition, then we should evaluate the
expression and bind the variable name to the result in the environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl">     <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">exec</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>If it&rsquo;s an execution statement, then we should just evaluate the expression and
keep executing the rest of the program.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl">     <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">exec</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">e</span> <span class="o">&gt;&gt;</span> <span class="n">exec</span> <span class="n">s</span>
</span></span></code></pre></div><p>And&hellip; That&rsquo;s it! All our hard work when writing <code>eval</code> and its helper functions
is finally paying off. This code it short, easy to read, and (relatively) easy
to understand.</p>
<p>Then <code>execute</code> is just the function that runs <code>exec program</code> in the empty
environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">execute</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Output</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">RuntimeError</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">execute</span> <span class="n">p</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">run</span> <span class="p">(</span><span class="n">exec</span> <span class="n">p</span><span class="p">)</span> <span class="kt">[]</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Right</span> <span class="kr">_</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="kt">Just</span> <span class="n">re</span><span class="p">)</span>
</span></span></code></pre></div><p>Then we&rsquo;re all done! After writing a driver program (like <code>Main.hs</code> in the repo),
you can install this <code>boa</code> executable by typing <code>stack install</code> in the directory.
Now you can interpret Boa ASTs!</p>
<h3 id="contact">Contact<a hidden class="anchor" aria-hidden="true" href="#contact">#</a></h3>
<p>I appreciate any feedback, comments, corrections, etc. you may have. If that&rsquo;s
the case, you can reach me via my
<a href="https://github.com/SophieBosio">GitHub</a> or my email at <a href="mailto:sophie.bosio@outlook.com">sophie.bosio@outlook.com</a>. Happy coding!</p>
<h2 id="monads-haskell"><span class="org-todo todo TODO">TODO</span> Monads in Haskell <span class="tag"><span class="functional">functional</span><span class="programming">programming</span><span class="haskell">haskell</span><span class="monads">monads</span></span><a hidden class="anchor" aria-hidden="true" href="#monads-haskell">#</a></h2>
<p>Monads are extremely useful and notoriously hard to wrap your head around the
first time around. The formal definition, &ldquo;a monoid in the category of
endofunctors&rdquo;,  doesn&rsquo;t really help the average person much.</p>
<p>A monad is essentially a way to perform a computation with some added
<em>context</em> in a functional way. Personally, I had the most luck starting with <em>how</em>
to use monads in functional programming, and as I got better at using them, I
would re-read the definitions and slowly feel like I started to understand them.</p>
<p>First, I&rsquo;ll give a brief introduction to monads, using the <code>List</code> monad as an example.</p>
<p>Then, to explain why we might want to use monads, I&rsquo;ll reproduce a famous example:
Using the Writer monad to perform logging. I&rsquo;ll be borrowing heavily
<a href="https://www.youtube.com/watch?v=C2w45qRc3aU">this intro</a> to monads by Studying With Alex on YouTube.</p>
<p>And finally, to cover more of the theory behind monads, we&rsquo;ll have a look at the <code>Maybe</code>
monad in Haskell.</p>
<h3 id="wait-list-is-a-monad">Wait, List is a Monad?<a hidden class="anchor" aria-hidden="true" href="#wait-list-is-a-monad">#</a></h3>
<p>Yes! Remember that a monad is a structure that lets us perform a computation with some added
<em>context</em>. For a list, that context is what <em>elements</em> are in the list (including
duplicates) and their <em>order</em>.</p>
<p>Let&rsquo;s say you want to map a function <code>f</code> over a list <code>xs</code>. All well and great, but
you can&rsquo;t just do it any way you like: You have to map the function over <em>all</em> the
elements and preserve their order! So somehow, the context of the list carries
over into the next computation you want to do on it.</p>
<p>In general, I find it useful to think of monads as &ldquo;containers&rdquo; or boxes
around values. In this case, the list <code>[...]</code> is a container and the elements are
the values.</p>
<p>If you take a normal integer, that value isn&rsquo;t a (singleton) list by itself.
E.g., wrapping <code>5</code> isn&rsquo;t a list, but <code>[5]</code> is. To take an integer like <code>5</code> and make it
into a singleton list, we have to &ldquo;wrap it&rdquo; in square brackets. In general this
function is called <em>return</em>.</p>
<p>The containers, like <code>[]</code>, also prevent us from accessing the values directly, so
we have to &ldquo;unwrap&rdquo; them somehow. E.g., I can&rsquo;t do
<code>[5] + 3</code> because I&rsquo;m trying to add a list of integers to an integer, but I
<em>can</em> do <code>map (+ 3) [5]</code>, because now I&rsquo;m adding an integer to another integer. This
function is called <em>bind</em> and is written in Haskell with the symbol <code>&gt;&gt;=</code>.</p>
<p>Note that when we are &ldquo;extracting&rdquo; a value in this way, we <em>must</em> pass it to a
function that promises to put it back in to the monad. There are other ways to
just take out the value and use it normally, but then we also lose the context.
I.e., if I do <code>([5, 6, 7] !! 0) + 3</code>, I can extract <code>5</code> without any additional
context. Then I can add it to <code>3</code> and get <code>8</code> and that&rsquo;s fine, but now the rest of
the list is &ldquo;gone&rdquo; and I have no way of putting <code>8</code> into the list instead of <code>5</code>.</p>
<p>So, monads allow us to perform computations with context in a functional way.
What&rsquo;s so special about that? Well, the number of elements and ordering of the list, depends on the
list itself! So, it&rsquo;s almost like the list has a <em>state</em>. But we normally can&rsquo;t do <em>stateful</em> computations in a <em>functional</em> language, right?
And yet, it&rsquo;s still functional, because all the computations on lists return the same
results each time they are called <em>in the same context</em>, i.e., on the same list.</p>
<blockquote>
<p>For later, remember that a monad needs a way to put a normal value <em>into</em> the
monad, and a way to extract a normal value <em>out of</em> the monad to pipe it to
another function, that must eventually put it back into the monad.</p>
</blockquote>
<p>Normal values can be &ldquo;put inside&rdquo; a monad by wrapping them with some extra
context. In a way, then, <code>return</code> is the function that takes a normal value <code>a</code> and
returns that value with some extra context <code>m</code> and gives us the new value <code>(a, m)</code>.
Now we can&rsquo;t just access <code>a</code> directly anymore, we need to first take it out of
this context wrapper and then <em>bind</em> it to a function that puts it back.</p>
<figure><a href="/img/monad-1.png">
    <img loading="lazy" src="/img/monad-1.png"/> </a>
</figure>

<h3 id="writer-monad-to-the-rescue">Writer Monad to the Rescue!<a hidden class="anchor" aria-hidden="true" href="#writer-monad-to-the-rescue">#</a></h3>
<p>Now we&rsquo;ll have a look at the <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Writer.html">Writer</a> monad, a commonly used monad
that will hopefully illustrate the concepts more clearly.</p>
<p><strong>Please note:</strong> This example is common, but my particular implementation borrows heavily from
<a href="https://www.youtube.com/watch?v=C2w45qRc3aU">this intro</a> to monads by Studying With Alex on YouTube, and I would recommend
that video!</p>
<p>The <strong>Writer</strong> monad is often used for logging.</p>
<p>Let&rsquo;s say you have a function that adds two ints and a function that squares
ints. Then you want to add a log statement for each computation, so that you can
review the log later.</p>
<p>In an imperative language, you might add a global
variable, but then all your functions depend on this one variable. You could
pass the list as argument and return it as output, but then your <code>add</code> function
suddenly also takes a weird, extra log argument. Instead, you
could return a tuple, containing first the result of the computation and then
the log so far. We could do that in Haskell as well. Let&rsquo;s define a new type
<code>LoggedInt</code> that contains an integer and a list of strings, which will be our
log. Then <code>add</code> and <code>square</code> can return this type!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">LoggedInt</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LoggedInt</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Added &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&#34; to &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">m</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LoggedInt</span>
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="n">n</span> <span class="ow">=</span> <span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">])</span>
</span></span></code></pre></div><p>But now, you can&rsquo;t really chain these together, because both functions take
normal ints and return these weird <code>LoggedInt</code> values.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; square<span class="o">(</span>add <span class="m">2</span> 4<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;interactive&gt;:11:8: error:
</span></span><span class="line"><span class="cl">    • Couldn<span class="err">&#39;</span>t match <span class="nb">type</span> ‘<span class="o">(</span>Int, <span class="o">[</span>String<span class="o">])</span>’ with ‘Int’
</span></span><span class="line"><span class="cl">      Expected: Int
</span></span><span class="line"><span class="cl">        Actual: LoggedInt
</span></span><span class="line"><span class="cl">    • In the first argument of ‘square’, namely ‘<span class="o">(</span>add <span class="m">2</span> 4<span class="o">)</span>’
</span></span><span class="line"><span class="cl">      In the expression: square <span class="o">(</span>add <span class="m">2</span> 4<span class="o">)</span>
</span></span><span class="line"><span class="cl">      In an equation <span class="k">for</span> ‘it’: <span class="nv">it</span> <span class="o">=</span> square <span class="o">(</span>add <span class="m">2</span> 4<span class="o">)</span>
</span></span></code></pre></div><p>Also, there is no way to access and extend the previous log, since each
computation just returns the singleton list with their log statement.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">2</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">6</span><span class="p">,[</span><span class="s">&#34;Added 2 to 4&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">square</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="mi">4</span><span class="p">,[</span><span class="s">&#34;Squared 2&#34;</span><span class="p">])</span>
</span></span></code></pre></div><p>Of course, we could make both the functions take <code>LoggedInt</code> values. But that&rsquo;s
pretty much equivalent to passing the list as argument and returning it as output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">LoggedInt</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="ow">::</span> <span class="kt">LoggedInt</span> <span class="ow">-&gt;</span> <span class="kt">LoggedInt</span> <span class="ow">-&gt;</span> <span class="kt">LoggedInt</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">log1</span> <span class="o">++</span> <span class="n">log2</span> <span class="o">++</span> <span class="p">[</span><span class="s">&#34;Added &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&#34; to &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">m</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">LoggedInt</span> <span class="ow">-&gt;</span> <span class="kt">LoggedInt</span>
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">log</span> <span class="o">++</span> <span class="p">[</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">])</span>
</span></span></code></pre></div><p>What to do? Well, if we squint, we can see that we have another context (the
previously logged material) that we want to use in our computation, and we want
to return a result that has the updated context (the old logs plus the new log
statement)!</p>
<p>This is exactly the kind of thing monads are built for! Let&rsquo;s implement the
Writer monad from scratch together.</p>
<p>The type of monad we want, is basically an instance of the <code>Writer</code> monad in
Haskell. Let&rsquo;s call ours <code>LogWriter</code>.</p>
<p>The results of our computations are going to be inside the <code>LogWriter</code> monad from now on.
Right off the bat, we want a way to take a computation wrapped in the monad and
<em>unwrap</em> it. That&rsquo;s usually called <em>running</em> the monad, so let&rsquo;s define
<code>LogWriter</code> with a function called <code>run</code> that just unwraps the computation and
gives us the result and the log as a pair.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">l</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>l</code> is the type of the logs and <code>a</code> is the type of the result of the
computation. Since we want to be able to concatenate (possibly empty) logs, <code>l</code>
must be a member of the <code>Monoid</code> type class.</p>
<p>Let&rsquo;s take the old versions of our functions, that take normal integers and
return integers with logs, and rewrite them so return values inside the <code>LogWriter</code> monad. The
<code>LogWriter</code> contains the list of strings (logs) and an integer (result).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">l</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Like we saw earlier, a monad needs a way of putting a normal value (here, an int) into the
container (here, an int with a log). In Haskell, this is called <code>return</code>. We want to find
the &ldquo;simplest&rdquo;, most straightforward way of taking a normal value and putting
into the monad.</p>
<p>In our case, that would be returning the value and the empty
list. But since we specified that <code>l</code> should be a monoid, and not a list in
particular, we can&rsquo;t use <code>[]</code> for the empty list. Instead, we can use <code>mempty</code>
which corresponds to the empty list, but works for all monoids!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mempty</span><span class="p">)</span>
</span></span></code></pre></div><p>Then we need a way to extract a value <em>out of</em> the monad, so that we can use it to
perform computations (such as squaring it) and then putting it <em>back into</em> the
monad. Unwrapping, computing, and wrapping! This is called the &ldquo;bind&rdquo; operator
and in Haskell, it is written as <code>&gt;&gt;=</code>.</p>
<blockquote>
<p>Note that it takes a wrapped value <code>m a</code> and a function that takes a <em>normal</em>
value and returns a <em>wrapped</em> value again <code>(a -&gt; m b)</code>. So we can&rsquo;t just take
any normal function <code>a -&gt; b</code> and bring it into monad-land using the bind
operator - but we&rsquo;ll see later that there is a function that does exactly that,
called <code>fmap</code>!</p>
</blockquote>
<p>Of course, what we want to do is to apply <code>f</code> to the value <code>a</code> inside the monad,
and return the <code>result</code> of that computation. Additionally, we want to take any
new output and append it to the existing logs, and return that as well.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mempty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">logs</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kr">let</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output</span><span class="p">))</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="kr">in</span>   <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">logs</span> <span class="o">&lt;&gt;</span> <span class="n">output</span><span class="p">)</span>
</span></span></code></pre></div><p>Finally, every monad is an applicative functor, and in turn a normal functor.
Therefore, we need to make our monad an instance of those typeclasses as well.
We&rsquo;ll cover how this works in the section about <code>Maybe</code>, but for now, you can
copy these instance declarations to make GHC happy and accept our <code>LogWriter</code>
into the monad family.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span>  <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">fmap</span>  <span class="ow">=</span> <span class="n">liftM</span>
</span></span></code></pre></div><p>Now we can rewrite <code>add</code> and <code>square</code> to return values inside the <code>LogWriter</code>
monad!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">l</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mempty</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">logs</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kr">let</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output</span><span class="p">))</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="kr">in</span>   <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">logs</span> <span class="o">&lt;&gt;</span> <span class="n">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span>  <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">l</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="n">l</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="n">n</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Added &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&#34; to &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">m</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">square</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">n</span><span class="p">])</span>
</span></span></code></pre></div><p>And finally, perform monadic operation that keep track of the log the whole way!
Since the result of <code>add</code> and <code>square</code> is now values within the <code>LogWriter</code>, we
have to remember to <code>run</code> the monad so we get a nice, printable result. <code>run</code> gives
us the final output <em>with</em> the context, after all the computations are done.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; add <span class="m">5</span> <span class="m">3</span>   <span class="c1"># Gives us values INSIDE the monad!</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;interactive&gt;:126:1: error:
</span></span><span class="line"><span class="cl">    • No instance <span class="k">for</span> <span class="o">(</span>Show <span class="o">(</span>LogWriter <span class="o">[</span>String<span class="o">]</span> Int<span class="o">))</span>
</span></span><span class="line"><span class="cl">        arising from a use of ‘print’
</span></span><span class="line"><span class="cl">    • In a stmt of an interactive GHCi command: print it
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; run <span class="o">(</span>add <span class="m">5</span> 3<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>8,<span class="o">[</span><span class="s2">&#34;Added 5 to 3&#34;</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; run <span class="o">(</span>square 2<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>4,<span class="o">[</span><span class="s2">&#34;Squared 2&#34;</span><span class="o">])</span>
</span></span></code></pre></div><p>We can even chain computations using the <code>&gt;&gt;</code> operator, which lets us perform an
operation, ignore the result, and perform the next operation. In these two examples, we see the
result of the last computation in the chain, <code>add 4 5</code>, and the total log.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; run $ add <span class="m">6</span> <span class="m">3</span> &gt;&gt; square <span class="m">2</span> &gt;&gt; add <span class="m">4</span> <span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>9,<span class="o">[</span><span class="s2">&#34;Added 6 to 3&#34;</span>,<span class="s2">&#34;Squared 2&#34;</span>,<span class="s2">&#34;Added 4 to 5&#34;</span><span class="o">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; run $ add <span class="m">5</span> <span class="m">10</span> &gt;&gt; square <span class="o">(</span>fst $ run $ add <span class="m">3</span> 2<span class="o">)</span> &gt;&gt; square <span class="m">2</span> &gt;&gt; add <span class="m">4</span> <span class="m">5</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>9,<span class="o">[</span><span class="s2">&#34;Added 5 to 10&#34;</span>,<span class="s2">&#34;Squared 5&#34;</span>,<span class="s2">&#34;Squared 2&#34;</span>,<span class="s2">&#34;Added 4 to 5&#34;</span><span class="o">])</span>
</span></span></code></pre></div><p>Now, we have a normal function like <code>+</code> between normal values and
a &ldquo;stateful&rdquo; function like <code>add</code> from normal values to wrapped values. As an
example, we can picture <code>run $ add 4 5 &gt;&gt;​= square</code> like this:</p>
<figure><a href="/img/monad-2.png">
    <img loading="lazy" src="/img/monad-2.png"/> </a>
</figure>

<h3 id="maybe-we-ll-get-a-value"><code>Maybe</code> We&rsquo;ll Get A Value<a hidden class="anchor" aria-hidden="true" href="#maybe-we-ll-get-a-value">#</a></h3>
<p>Time for some theory! Hopefully, with the context of the previous examples, this
will feel mostly familiar.</p>
<p>As mentioned, we&rsquo;ll be looking at <em>applicatives</em> and <em>functors</em>. Let&rsquo;s look at some definitions and introduce some terminology:</p>
<blockquote>
<p>Every <strong>monad</strong> is an <strong>applicative functor</strong>, and every applicative functor is a
normal <strong>functor</strong>.</p>
</blockquote>
<p>So, just like a square is a special rectangle, a monad is a special applicative,
which in turn is a special functor.</p>
<p>Let&rsquo;s start at the lowest level, <strong>functors</strong>, and work our way up.</p>
<h4 id="functors">Functors<a hidden class="anchor" aria-hidden="true" href="#functors">#</a></h4>
<p>Formally, a functor is a transformation that maps all the objects (values) in a category
to objects in another, and all the morphisms (functions) in a category to
morphisms in another.</p>
<p>For example, the <code>Maybe</code> functor applied the type <code>Int</code> maps regular integers like <code>5</code>
to <code>Just 5</code> or <code>Nothing</code>, and maps functions that work on <code>Int</code> s to functions that
work on <code>Maybe Int</code> s.</p>
<p>In Haskell, I usually think of values as <em>wrapped</em> or <em>unwrapped</em> values.</p>
<p>An <em>unwrapped</em> value, is just the value as we typically think of them. E.g., <code>5</code>.
A <em>wrapped</em> value, has a &ldquo;container&rdquo; that prevents us from using them as normal.
E.g., <code>Just 5</code>.</p>
<p>Then we need to do something special to use the functions on the wrapped values.
For functors, this is <code>fmap</code>. It &ldquo;lifts&rdquo; a normal function up to functor territory
so we can apply them to values. Or, if you like, it unwraps the value, applies
the function, and wraps it back up.</p>
<p>Here&rsquo;s how a functor is defined in Haskell.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span></code></pre></div><p>So all we need to do to make something an instance of the Functor typeclass, is
define a way to lift a function <code>f</code> to apply it to the wrapped values!</p>
<p>Here&rsquo;s the <code>Maybe</code> functor instance in Haskell:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span>  <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></span></code></pre></div><p>I.e., applying a function <code>f</code> to a <code>Nothing</code> value, will always give you <code>Nothing</code>.
Applying a function <code>f</code> to <code>Just x</code>, is the same as applying <code>f</code> to <code>x</code>, and then
putting the result back into <code>Just</code>.</p>
<p>Trying to use a normal function directly on a wrapped value, results in an
error. But it works just as you might expect when you <code>fmap</code> the function onto the value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; <span class="o">(</span>+2<span class="o">)</span> <span class="o">(</span>Just 5<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;interactive&gt;:1:1: error:
</span></span><span class="line"><span class="cl">    • Non type-variable argument in the constraint: Num <span class="o">(</span>Maybe a<span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">(</span>Use FlexibleContexts to permit this<span class="o">)</span>
</span></span><span class="line"><span class="cl">    • When checking the inferred <span class="nb">type</span>
</span></span><span class="line"><span class="cl">        it :: forall <span class="o">{</span>a<span class="o">}</span>. <span class="o">(</span>Num a, Num <span class="o">(</span>Maybe a<span class="o">))</span> <span class="o">=</span>&gt; Maybe a
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; fmap <span class="o">(</span>+2<span class="o">)</span> <span class="o">(</span>Just 5<span class="o">)</span>
</span></span><span class="line"><span class="cl">Just <span class="m">7</span>
</span></span></code></pre></div><p>These are the two functor laws, which hopefully make sense. They state that
<code>fmap</code>-ing a the identity function is just the identity function, and that
<code>fmap</code>-ing two composed functions is the same as <code>fmap</code>-ing each function and then
composing them.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fmap</span> <span class="n">id</span>      <span class="ow">=</span> <span class="n">id</span>                <span class="c1">-- Identity</span>
</span></span><span class="line"><span class="cl"><span class="nf">fmap</span> <span class="p">(</span><span class="n">g</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">g</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">f</span>   <span class="c1">-- Composition</span>
</span></span></code></pre></div><blockquote>
<p>Note that you can use <code>fmap</code> in its infix form, which is <code>&lt;$&gt;</code>.</p>
<p><code>(+2) &lt;$&gt; (Just 5)   -- ==&gt; (Just 7)</code></p>
</blockquote>
<p>Since it&rsquo;s a mapping from objects to objects and functions to functions, all
instance of the <code>Functor</code> typeclass in Haskell are data structures that can be
<em>mapped over</em>, such as lists, trees, <code>Maybe</code> and <code>Either</code>. Some of them you can find below:</p>
<details>
<summary>More functors for the interested!</summary>
<div class="details">
<p>Lists are probably the most commonly used Functor instance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="ow">=</span> <span class="n">map</span>
</span></span></code></pre></div><p>Trees can be mapped over by applying <code>f</code> to each node recursively.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="kt">Leaf</span> <span class="ow">=</span> <span class="kt">Leaf</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">left</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">right</span><span class="p">)</span>
</span></span></code></pre></div><p><code>Either</code> is defined in a curried way, because it takes two arguments.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span>  <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
</span></span></code></pre></div><p>The <code>IO</code> monad, since it&rsquo;s also a functor, has an <code>fmap</code> defined this way.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="n">action</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">action</span>    <span class="c1">-- perform an IO action and save the result</span>
</span></span><span class="line"><span class="cl">		<span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">result</span><span class="p">)</span>   <span class="c1">-- apply f to the result of the IO action,</span>
</span></span><span class="line"><span class="cl">		<span class="c1">--                     which is itself an IO action</span>
</span></span></code></pre></div><p>And functions are actually also functors! <code>fmap</code> on the function arrow <code>-&gt;</code> looks a
little strange, but it does all make sense.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</span></span></code></pre></div><p>But notice how the type of this function, if you replace all the <code>f</code> s in the type
of <code>fmap</code> with <code>r -&gt;</code>, gives us <code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.Notice also
how we now have a function <code>r -&gt; a</code> and a function <code>a -&gt; b</code> and we end up with a
function <code>r -&gt; b</code>. So this is actually just function composition!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmap</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
</span></span></code></pre></div></div>
</details>
<h4 id="applicatives">Applicatives<a hidden class="anchor" aria-hidden="true" href="#applicatives">#</a></h4>
<p>An applicative functor has more structure than a regular functor, but less than
a monad.</p>
<p>It lets us unwrap both a function <em>and</em> a parameter. For normal functors, we could
only unwrap the parameter, but needed a normal function.</p>
<p>In Haskell, the Applicative typeclass is defined like this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span>  <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span></code></pre></div><p><code>pure</code> is similar to the <code>return</code> function: It takes a value and wraps it in the
applicative functor.</p>
<p>The <code>&lt;*&gt;</code> (&ldquo;application&rdquo;) operator allows us to unwrap both the function <code>a -&gt; b</code> and the parameter
<code>a</code>, and finally wrap the result up to get <code>f b</code>.</p>
<p>Basically, an Applicative functor allows us to take in a function and a
parameter in a given context (<code>f</code>) and perform the function application while
<em>preserving</em> that context (<code>f b</code>).</p>
<p>Note that the following three lines are equivalent.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="p">```</span><span class="n">haskell</span>
</span></span><span class="line"><span class="cl"><span class="nf">pure</span> <span class="n">f</span>   <span class="o">&lt;*&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">fmap</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">f</span>  <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span> <span class="o">&lt;*&gt;</span> <span class="o">...</span>
</span></span></code></pre></div><p>These are the laws for applicative functors.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">v</span>                            <span class="c1">-- Identity</span>
</span></span><span class="line"><span class="cl"><span class="nf">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>               <span class="c1">-- Homomorphism</span>
</span></span><span class="line"><span class="cl"><span class="nf">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>              <span class="c1">-- Interchange</span>
</span></span><span class="line"><span class="cl"><span class="nf">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span> <span class="c1">-- Composition</span>
</span></span></code></pre></div><p>Lists, <code>Maybe</code>, <code>IO</code>, functions, and a bunch of other functors are also applicative
functors.</p>
<details>
<summary>More applicative functors.</summary>
<div class="details">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span>                   <span class="ow">=</span> <span class="kt">Just</span>
</span></span><span class="line"><span class="cl">	<span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span>          <span class="ow">=</span> <span class="kt">Nothing</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">something</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span> <span class="n">x</span>    <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span>    <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">	<span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">		<span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">		<span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">		<span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span> <span class="n">x</span>  <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">ZipList</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">pure</span> <span class="n">x</span>                    <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kt">ZipList</span> <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">fs</span> <span class="n">xs</span><span class="p">)</span>
</span></span></code></pre></div></div>
</details>
<h4 id="monads">Monads<a hidden class="anchor" aria-hidden="true" href="#monads">#</a></h4>
<p>Finally, we get to monads! At this point, remember that you can use all the same
functions on monads as you could on functors and applicative functions.</p>
<p>Functors allow us to <em>lift</em> functions from one context to another, and
applicative functors allow us to lift both functions and an argument while
<em>preserving</em> a context. But the functions were always normal functions without any
context. Monads also allow us to preserve context, but also allow
us to use functions that take a value <em>without</em> context and return a value <em>with</em>
context.</p>
<p>A monad has the following operations. A minimal complete definition requires us
to write return and bind ourselves.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">	<span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>                    <span class="c1">-- return, or unit</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>    <span class="c1">-- bind</span>
</span></span><span class="line"><span class="cl">	<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span>   <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">	<span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="ow">=</span>  <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">	<span class="n">fail</span>   <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">	<span class="n">fail</span> <span class="n">msg</span> <span class="ow">=</span>  <span class="ne">error</span> <span class="n">msg</span>
</span></span></code></pre></div><p>The most interesting function we need for a monad is the bind operator, <code>&gt;&gt;=</code>.</p>
<p>Compare this to <code>fmap</code> and <code>&lt;*&gt;</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">fmap</span>  <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span>     <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span>       <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span></code></pre></div><p>Notice that the second argument to the bind operator, is a function
from a normal value <code>a</code> to a value with context <code>m b</code>.</p>
<p>I think the relationship between the different functions is especially clear when we look at the flipped version of the bind operator, <code>=&lt;&lt;</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Functor</span>     <span class="n">f</span> <span class="ow">=&gt;</span>   <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span>   <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span>   <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">=&lt;&lt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Monad</span>       <span class="n">m</span> <span class="ow">=&gt;</span>   <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span></code></pre></div><p>To see how we might use the bind operator, though, we can write a function that
works on <code>Maybe Int</code> values, which halves the integer value inside it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">halve</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">halve</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">evel</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="kr">then</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">else</span> <span class="kt">Nothing</span>
</span></span></code></pre></div><p>Then we can pass it an <code>Int</code> value, but if we want to pass it a <code>Maybe Int</code> we
have to use the bind operator.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; halve <span class="m">4</span>
</span></span><span class="line"><span class="cl">Just <span class="m">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; halve <span class="o">(</span>Just 4<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&lt;interactive&gt;:1:1: error:
</span></span><span class="line"><span class="cl">    • Non type-variable argument in the constraint: Integral <span class="o">(</span>Maybe a<span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">(</span>Use FlexibleContexts to permit this<span class="o">)</span>
</span></span><span class="line"><span class="cl">    • When checking the inferred <span class="nb">type</span>
</span></span><span class="line"><span class="cl">        it :: forall <span class="o">{</span>a<span class="o">}</span>. <span class="o">(</span>Integral <span class="o">(</span>Maybe a<span class="o">)</span>, Num a<span class="o">)</span> <span class="o">=</span>&gt; Maybe <span class="o">(</span>Maybe a<span class="o">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ghci&gt; <span class="o">(</span>Just 4<span class="o">)</span> &gt;&gt;<span class="o">=</span> halve
</span></span><span class="line"><span class="cl">Just <span class="m">2</span>
</span></span></code></pre></div><p>My thesis supervisor taught me this great trick for remembering how the bind
operator works. It&rsquo;s like a toilet plunger (and it looks a little like it, too)! It extracts the value out of the
monad, but then the function you pass it to has to be responsible for putting
it back into the monad.</p>
<p>There are a bunch of functions from the <code>Functor</code> and <code>Applicative</code> typeclasses that
have equivalent <code>Monad</code> functions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">pure</span>   <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">return</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span>       <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span>  <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">ap</span>     <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span>       <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">fmap</span>   <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span>     <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl"><span class="nf">liftM</span>  <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span>       <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span></code></pre></div><p>And many more! But what&rsquo;s nice about this, is that if we import <code>Control.Monad</code> in
our file, we can define a <code>Monad</code> instance quite easily by setting the <code>Applicative</code>
and <code>Functor</code> functions to be equal to these monadic functions. For example, we
can implement the list monad like this.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span>  <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>
</span></span></code></pre></div><p>Finally, monads also have to obey the monad laws.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="p">(</span><span class="n">return</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">==</span> <span class="n">f</span> <span class="n">x</span>                     <span class="c1">-- &#39;return&#39; is left-identity  wrt. &#39;&gt;&gt;=&#39;</span>
</span></span><span class="line"><span class="cl"><span class="nf">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span>     <span class="o">==</span> <span class="n">m</span>                       <span class="c1">-- &#39;return&#39; is right-identity wrt. &#39;&gt;&gt;=&#39;</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span>  <span class="o">==</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">g</span><span class="p">)</span> <span class="c1">-- &#39;&gt;&gt;=&#39; is associative</span>
</span></span></code></pre></div><h3 id="picturing-a-monad">Picturing A Monad<a hidden class="anchor" aria-hidden="true" href="#picturing-a-monad">#</a></h3>
<h3 id="conclusion-and-further-reading">Conclusion &amp; Further Reading<a hidden class="anchor" aria-hidden="true" href="#conclusion-and-further-reading">#</a></h3>
<p>That&rsquo;s it for the crash course in monads!</p>
<p>It&rsquo;s also really interesting to read about the <code>Monoidal</code> typeclass, and how you
can implement a monad using either <code>(&gt;=&gt;)</code> or <code>join</code> instead of the bind operator.
Bartosz Milewski has a really great <a href="https://youtu.be/gHiyzctYqZ0?si=Pt9eCaT7Z4WJiJnX">lecture on YouTube about monads</a> where he explains this.</p>
<p>There are several cool functions on monads and friends, that let you chain
together computations in a really neat, clean way. For example, my life got
easier when I started using <code>&lt;&amp;&gt;</code>, <code>&lt;$</code>, <code>&lt;*</code> and <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Monad.html">similar functions</a>. Not to mention
do-notation!</p>
<p>And finally, all this learning and reading about monads really becomes useful
when you use them in projects. To get started, check out the <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Reader.html">Reader</a>, <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Writer-Strict.html">Writer</a> and
<a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-RWS-Strict.html">Reader Writer State</a> monads.</p>
<p>I&rsquo;ve had a lot of fun learning how to use monads to write parsers and
interpreters.</p>
<blockquote>
<p>I&rsquo;d appreciate any feedback, comments, corrections, etc. that you might have!
Happy coding!</p>
</blockquote>
<h2 id="first-emacs-config"><span class="org-todo done DONE">DONE</span> Building Your First Emacs Config <span class="tag"><span class="emacs">emacs</span></span><a hidden class="anchor" aria-hidden="true" href="#first-emacs-config">#</a></h2>
<p><a href="https://www.gnu.org/software/emacs/">Emacs</a> is a wonderful piece of software. It&rsquo;s easily my favourite program of all
time. It can also be a little overwhelming to configure for the first time.</p>
<p>One of the many things that make Emacs great, though, is its dedicated and
helpful user base. I hope to add a small contribution to that community with
this post, going over what I would have told my past self as I was just starting
out using Emacs and trying to write my first Emacs configuration file.</p>
<p>I&rsquo;ll assume you know the basics of editing with Emacs and won&rsquo;t cover general
concepts like major modes or how to save files in Emacs. I&rsquo;ll primarily be
focusing on how you can get started personalising it.</p>
<p>Before we get into it, I&rsquo;d like to cover three things: (1) Emacs is a Lisp
interpreter at heart, (2) there are great places to get help,
and (3) you should try out pieces of other people&rsquo;s configs.</p>
<h3 id="preamble">Preamble<a hidden class="anchor" aria-hidden="true" href="#preamble">#</a></h3>
<h4 id="a-primer-in-emacs-and-elisp">A Primer in Emacs and Elisp<a hidden class="anchor" aria-hidden="true" href="#a-primer-in-emacs-and-elisp">#</a></h4>
<p>Emacs is often thought of as a text editor. While it is built around text
editing and has many great packages to do so, I&rsquo;d argue it&rsquo;s more useful to
think of it as an (Emacs) Lisp interpreter.</p>
<p>Your configuration file is a program of Emacs Lisp (or &ldquo;elisp&rdquo; for short) code
that modifies the behaviour of Emacs itself. Most of the behaviours of vanilla
Emacs are <a href="https://en.wikipedia.org/wiki/Emacs_Lisp#:~:text=Emacs%20Lisp%20is%20a%20dialect,as%20is%20the%20Lisp%20interpreter.">written
in Elisp</a>, and the rest in C. Therefore, almost everything that Emacs does, you
can change! You can, of course, add and create new functionality as well.</p>
<p>The power to build your ideal editor is right at your fingertips! As long as
you&rsquo;re willing to learn a little bit of a Lisp dialect.</p>
<p>Thankfully, Elisp is a pretty readable language and as long as you watch your
parentheses, you&rsquo;ll be fine.</p>
<h4 id="get-help">Get Help<a hidden class="anchor" aria-hidden="true" href="#get-help">#</a></h4>
<p>The Emacs community is very friendly and are often keep to help
out. I hang out a lot on the <a href="https://www.reddit.com/r/emacs/">r/emacs
subreddit</a> and have gotten tons of tips and troubleshooting help from there.
<a href="https://www.reddit.com/r/planetemacs">r/planetemacs</a> is also great &mdash; they focus mostly on packages and blog posts/article links.</p>
<p>Emacs also has a pretty good documentation and help system. You can take the
Emacs tutorial using <code>C-h t</code>. Ask Emacs for help using:</p>
<ul>
<li><code>C-h v</code> to see the documentation for a variable</li>
<li><code>C-h f</code> to see the documentation for a function</li>
<li><code>C-h k</code> to see what a keybinding does</li>
<li><code>C-h m</code> to show help for the current major and minor modes</li>
</ul>
<p>Or read on the <a href="https://www.emacswiki.org/">Emacs Wiki</a>.</p>
<h4 id="config-inspo">Config Inspo<a hidden class="anchor" aria-hidden="true" href="#config-inspo">#</a></h4>
<p>This brings me to my first and (I think) most helpful tip: Get inspired by other
people&rsquo;s configurations.</p>
<p>I&rsquo;ll talk a little later about the basics of using Elisp for your config file,
and that might be useful to help you read and understand the configs, but I
think it&rsquo;s good to have a starting point and to start experimenting early.</p>
<p>If you&rsquo;re only just starting out, I invite you to check out <a href="https://github.com/SophieBosio/.emacs.d">my config</a> and send
me any questions you might have by <a href="mailto:sophie.bosio@outlook.com">email</a>. (If you&rsquo;re experienced, I invite you to send me
any corrections or improvements!)</p>
<p>Here are some of the configurations I have stolen a lot of my configuration from and
can heartily recommend checking out.</p>
<ul>
<li><a href="https://github.com/larstvei/dot-emacs">Lars Tveito</a></li>
<li><a href="https://github.com/jakebox/jake-emacs">Jake Boxerman</a>, with <a href="https://youtu.be/Gi7yBMYZylU?si=OO0r57KvYpUL2S9W">accompanying video</a></li>
<li><a href="https://github.com/protesilaos/dotfiles">Protesilaos Stavrou</a></li>
<li><a href="https://github.com/daviwil/dotfiles">David Wilson (System Crafters)</a></li>
<li><a href="https://github.com/rougier/dotemacs">Nicolas Rougier</a></li>
</ul>
<p>Check out the configs piece by piece by copying something into your own config
and testing it out for a while. This is probably what has been the most helpful
to me.</p>
<p>You could also get a lot of useful tips and tricks from checking out some
curated, &ldquo;sane defaults&rdquo; builds of Emacs. These are designed to be minimal and
extensible, just configuring some settings to make the initial switch to Emacs a
little smoother and give you a solid foundation for writing your own config.
Most of them don&rsquo;t include too many extra packages, either.
Some of these include:</p>
<ul>
<li><a href="https://github.com/bbatsov/prelude">Prelude</a></li>
<li><a href="https://github.com/SystemCrafters/crafted-emacs">Crafted Emacs</a></li>
<li><a href="https://github.com/purcell/emacs.d">Purcell&rsquo;s Emacs config</a></li>
<li><a href="https://github.com/rougier/nano-emacs">Nano Emacs</a></li>
</ul>
<h3 id="basics-setting-variables">Basics: Setting Variables<a hidden class="anchor" aria-hidden="true" href="#basics-setting-variables">#</a></h3>
<p>Your configuration file is an Emacs Lisp file called <code>init.el</code>, located in your
Emacs home directory. Usually, this is at <code>~/.emacs.d/init.el</code>. This is where
you&rsquo;ll add your code, and Emacs will load this file at startup.</p>
<p>Emacs can be configured either by modifying default behaviour or by installing
and configuring community packages. You&rsquo;ll probably want to do both.</p>
<p>There are quite a few blog posts and configurations that cover how to set &ldquo;sane
defaults&rdquo; &mdash; i.e., modify the default behaviour of Emacs in a way most people
would agree with. Check out the &ldquo;early init&rdquo; files or startup sections of the
configs above. You might also want to check out <a href="https://github.com/hrs/sensible-defaults.el">sensible-defaults</a>, which
contains a lot of useful and, yes, sensible functions you can use in your config.</p>
<p>In general, you set the value of a variable using <code>setq</code>. Specify the name of the
variable or the mode, then set it to an accepted value. Often variables will use
<code>t</code> / <code>nil</code> and modes will use <code>1</code> / <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">enabled-option</span>  <span class="no">t</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">disabled-option</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	  <span class="nv">enabled-mode</span>    <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">disabled-mode</span>   <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="installing-packages">Installing Packages<a hidden class="anchor" aria-hidden="true" href="#installing-packages">#</a></h3>
<p>After you&rsquo;re done tweaking Emacs&rsquo; default behaviours, you&rsquo;ll probably need some
packages.</p>
<p>You can install a package from a package source or load an installed package in
your load path using the <code>require</code> keyword.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;package-name</span><span class="p">)</span>
</span></span></code></pre></div><p>This is the easiest way to get started. Add the <code>require</code>-line to your <code>init.el</code>
file and use <code>setq</code> to configure the package.</p>
<p>In fact, at the top of your <code>init.el</code> file, you should <code>(require 'package)</code>.
<code>package.el</code> is the default package manager for Emacs.</p>
<p>Many Emacs packages are
available at <a href="https://melpa.org/">MELPA</a>, a package archive with generally high-quality packages. You
might also want to add some other package sources. Here&rsquo;s an example from my
config, where I add quite a few sources and tell Emacs which places to check
first.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">package-archives</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;GNU ELPA&#34;</span>     <span class="o">.</span> <span class="s">&#34;https://elpa.gnu.org/packages/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;MELPA&#34;</span>        <span class="o">.</span> <span class="s">&#34;https://melpa.org/packages/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;ORG&#34;</span>          <span class="o">.</span> <span class="s">&#34;https://orgmode.org/elpa/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;MELPA Stable&#34;</span> <span class="o">.</span> <span class="s">&#34;https://stable.melpa.org/packages/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;nongnu&#34;</span>       <span class="o">.</span> <span class="s">&#34;https://elpa.nongnu.org/nongnu/&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	  <span class="nv">package-archive-priorities</span>
</span></span><span class="line"><span class="cl">	  <span class="o">&#39;</span><span class="p">((</span><span class="s">&#34;GNU ELPA&#34;</span>     <span class="o">.</span> <span class="mi">20</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;MELPA&#34;</span>        <span class="o">.</span> <span class="mi">15</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;ORG&#34;</span>          <span class="o">.</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;MELPA Stable&#34;</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">(</span><span class="s">&#34;nongnu&#34;</span>       <span class="o">.</span> <span class="mi">0</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">package-initialize</span><span class="p">)</span>
</span></span></code></pre></div><p>After setting up your package sources, you can add <code>(require 'package-name)</code> to
your <code>init.el</code> and Emacs will automatically search, download, and install that
package from the source. Remember to evaluate your <code>init.el</code> file for this to happen,
either by using the command <code>eval-buffer</code> on <code>init.el</code> or by restarting Emacs.</p>
<p>Some packages are not available on MELPA &amp; Co., in which case you might want to
download it and save it on your computer manually. Or maybe you want to use a
package you&rsquo;ve written yourself.</p>
<p>In that case, you can also point Emacs to look for <code>.el</code> files on your computer.
It&rsquo;s practical to put all these files in the same place and add all of them to
your &ldquo;load path&rdquo; so Emacs knows where to look for them. Here&rsquo;s a setup for
loading files from the  <code>~/.emacs.d/local-lisp</code> directory and sub-directories.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">defvar</span> <span class="nv">local-lisp</span> <span class="s">&#34;~/.emacs.d/local-lisp/&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">&#39;load-path</span>  <span class="nv">local-lisp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">let</span> <span class="p">((</span><span class="nv">default-directory</span> <span class="nv">local-lisp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">normal-top-level-add-subdirs-to-load-path</span><span class="p">))</span>
</span></span></code></pre></div><details>
<summary>A note on package management</summary>
<div class="details">
<p>Using <code>require</code> and setting all your variables with <code>setq</code> statements can lead to a
long and hard-to-read config when you add many packages.</p>
<p>That&rsquo;s why some people prefer using other systems or wrappers around <code>package.el</code>,
for example <code>use-package</code>, <code>quelpa</code>, or <code>straight</code>. You&rsquo;ll see this a lot in the
installation instructions for packages. Personally, I use <code>use-package</code> because it&rsquo;s so
prevalent and because it&rsquo;s quite convenient.</p>
<p>But don&rsquo;t get too caught up in this, you don&rsquo;t
<em>need</em> to use any of these, and it&rsquo;s not very hard to refactor your code incrementally if you
decide you want to try later.</p>
</div>
</details>
<p>Here&rsquo;s a (simple) example of how to remove some visual elements from vanilla Emacs:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">tool-bar-mode</span>     <span class="mi">0</span>    <span class="c1">;; Remove toolbar</span>
</span></span><span class="line"><span class="cl">      <span class="nv">scroll-bar-mode</span>   <span class="mi">0</span>    <span class="c1">;; Remove scollbars</span>
</span></span><span class="line"><span class="cl">      <span class="nv">menu-bar-mode</span>     <span class="mi">0</span>    <span class="c1">;; Remove menu bar</span>
</span></span><span class="line"><span class="cl">      <span class="nv">blink-cursor-mode</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">;; Solid cursor, not blinking</span>
</span></span></code></pre></div><p>And here&rsquo;s an example of setting up the <a href="https://github.com/rnkn/olivetti">Olivetti</a> package:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;olivetti</span><span class="p">)</span>     <span class="c1">;; Make sure Olivetti is installed</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">olivetti-style</span> <span class="no">t</span><span class="p">)</span> <span class="c1">;; Set the &#39;olivetti-style&#39; variable to true</span>
</span></span></code></pre></div><h3 id="some-package-suggestions">Some Package Suggestions<a hidden class="anchor" aria-hidden="true" href="#some-package-suggestions">#</a></h3>
<p>I still think you should use bits and pieces of other people&rsquo;s configurations to
figure out what look and feel you prefer for your Emacs experience, but below I
have gathered some packages I like and some alternatives to them.</p>
<h4 id="completion-systems">Completion Systems<a hidden class="anchor" aria-hidden="true" href="#completion-systems">#</a></h4>
<p>The really big one is your <strong>completion system</strong>. By default, some things in Emacs
can feel a little clunky, such as entering commands, searching documents, and
finding files. Thankfully, there are packages that give you a nice prompt with auto-completions,
search tools, suggestions, prettification, etc. For example, they can auto-fill
directory and file names when opening a file with <code>C-x C-f</code>.</p>
<p>These packages are usually combined with other supplementary packages, but
there are a few common ones that people use as the core of their systems.
They include:</p>
<ul>
<li><a href="https://github.com/minad/vertico">Vertico</a></li>
<li><a href="https://github.com/emacs-helm/helm">Helm</a></li>
<li><a href="https://www.gnu.org/software/emacs/manual/html_mono/ido.html">Ido</a></li>
</ul>
<p>As mentioned, there are many, <em>many</em> packages people pair with these systems. Ido
comes built-in with Emacs, so you might want to start there. I personally use
Vertico and have been very happy with that. I tried Helm, but found it a little
overwhelming and felt I wasn&rsquo;t using it to its full potential. People do love it
though.</p>
<p>Play around with them a little, and if you like one, I&rsquo;d say stick to
it. Jumping around with these is kind of confusing, so I would only consider
switching if I had a problem with the one I was using, or if another one had
some very attractive feature.</p>
<h4 id="terminal-emulators">Terminal Emulators<a hidden class="anchor" aria-hidden="true" href="#terminal-emulators">#</a></h4>
<p>You can emulate a terminal inside Emacs. I.e., you never have to leave Emacs!</p>
<p>There&rsquo;s a built-in terminal emulator, but it&rsquo;s not particularly nice. Instead, I
would suggest checking out either
<a href="https://github.com/akermu/emacs-libvterm">vterm</a> or <a href="https://codeberg.org/akib/emacs-eat">Eat</a>.</p>
<h4 id="text-editing">Text Editing<a hidden class="anchor" aria-hidden="true" href="#text-editing">#</a></h4>
<p>Some packages just make text editing easier.</p>
<p>Take for example auto-completion packages such as the built-in <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dynamic-Abbrevs.html">dabbrev-mode</a>, or
<a href="https://github.com/minad/corfu">corfu</a> and <a href="https://company-mode.github.io/">company-mode</a>.</p>
<p>Depending on your use, you might find
<a href="https://github.com/magnars/multiple-cursors.el">multiple-cursors</a> useful.</p>
<h4 id="de-facto-standards">De Facto Standards<a hidden class="anchor" aria-hidden="true" href="#de-facto-standards">#</a></h4>
<p><a href="https://magit.vc/">Magit</a> is the best Git interface I&rsquo;ve ever used.</p>
<p>Spell- and syntax-checking is usually done with
<a href="https://www.emacswiki.org/emacs/FlySpell">Flyspell</a> and <a href="https://github.com/flycheck/flycheck">Flycheck</a>, respectively. These are pretty great.</p>
<p><a href="https://github.com/Wilfred/helpful">Helpful</a> gives you better help buffers.</p>
<p>When you start a keybinding combination, <a href="https://github.com/justbur/emacs-which-key">which-key</a> shows a popup with
suggestions for possible continuations of the sequence.</p>
<h4 id="more-packages">More Packages<a hidden class="anchor" aria-hidden="true" href="#more-packages">#</a></h4>
<p>For suggestions on more packages to check out,
<a href="https://github.com/emacs-tw/awesome-emacs">awesome-emacs</a> is a curated and oft-updated package list. I also love browsing
the top posts on the Emacs subreddits mentioned above.</p>
<h3 id="aesthetics-fonts-and-themes">Aesthetics: Fonts &amp; Themes<a hidden class="anchor" aria-hidden="true" href="#aesthetics-fonts-and-themes">#</a></h3>
<p>The quickest way to make your Emacs experience feel more personalised!</p>
<p>There are many different ways to set fonts in Emacs. You can also set different
fonts for the Emacs UI, for programming (monospaced or &ldquo;fixed pitch&rdquo; fonts) and
for prose editing (regular or &ldquo;variable pitch&rdquo; fonts).</p>
<p>Here&rsquo;s how I set my fonts. I use Roboto Mono for the UI and for programming, and
I use Source Sans Pro for my other documents. I check that the relevant font is
installed, and then set their size using the <code>:height</code> property.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">member</span> <span class="s">&#34;Roboto Mono&#34;</span> <span class="p">(</span><span class="nf">font-family-list</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;default</span> <span class="no">nil</span> <span class="nb">:font</span> <span class="s">&#34;Roboto Mono&#34;</span> <span class="nb">:height</span> <span class="mi">108</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;fixed-pitch</span> <span class="no">nil</span> <span class="nb">:family</span> <span class="s">&#34;Roboto Mono&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nf">member</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="p">(</span><span class="nf">font-family-list</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">set-face-attribute</span> <span class="ss">&#39;variable-pitch</span> <span class="no">nil</span> <span class="nb">:family</span> <span class="s">&#34;Source Sans Pro&#34;</span> <span class="nb">:height</span> <span class="mf">1.18</span><span class="p">))</span>
</span></span></code></pre></div><p>Note that I don&rsquo;t set the height of the programming (fixed pitch) font. It
simply uses the same height as the default font. I do set the size of the prose
(variable pitch) font, though, and I do that by giving a <em>relative</em> size &ndash; it&rsquo;s
relative to the size of the default font.</p>
<p>When it comes to themes, I&rsquo;d recommend starting with a pack so you can explore
many different options quickly, without needing to install a bunch of theme
packages by hand. A great place to get started, is Doom Emacs&rsquo; theme pack called
<a href="https://github.com/doomemacs/themes">doom-themes</a>. I particularly like the <code>doom-nord</code> theme. You can install and enable
it like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span><span class="o">&#39;</span> <span class="nv">doom-themes</span><span class="p">)</span>    <span class="c1">;; Make sure doom-themes are installed</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">load-theme</span> <span class="ss">&#39;doom-nord</span> <span class="no">t</span><span class="p">)</span> <span class="c1">;; Load the doom-nord theme</span>
</span></span></code></pre></div><p>I also really like the <a href="https://protesilaos.com/emacs/modus-themes">Modus themes</a>, the
<a href="https://protesilaos.com/emacs/ef-themes">Ef themes</a> and the <a href="https://github.com/rougier/nano-emacs">Nano themes</a>. You can find many more on <a href="https://emacsthemes.com/">emacsthemes.com</a>.</p>
<h3 id="programming">Programming<a hidden class="anchor" aria-hidden="true" href="#programming">#</a></h3>
<p><a href="https://github.com/joaotavora/eglot">Eglot</a> (Emacs polyGLOT) is an LSP server client for Emacs that comes pre-installed from Emacs 29.
You can install it manually in Emacs &gt;26.3.</p>
<p>You can also build Emacs with
<a href="https://emacs-tree-sitter.github.io/">tree-sitter</a> support. It&rsquo;s available for Emacs &gt;25.1.</p>
<p>Besides this, there are tons of major modes for various languages, usually
called <code>&lt;language-name&gt;-mode</code>. These will often give you basic syntax highlighting
and commands.</p>
<p>For example, here&rsquo;s a
simple way to get basic Python 3.11 support:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;python-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">python-shell-interpreter</span> <span class="s">&#34;python3.11&#34;</span><span class="p">)</span>
</span></span></code></pre></div><p>Here&rsquo;s my current setup for Haskell (except I&rsquo;ve rewritten it to use <code>require</code>
instead of <code>use-package</code>) using the Stack tool to build my Haskell projects:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">require</span> <span class="ss">&#39;haskell-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;haskell-mode</span> <span class="ss">&#39;haskell-doc-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">haskell-hoogle-command</span>                    <span class="s">&#34;hoogle&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="nv">haskell-compile-stack-build-command</span>     <span class="s">&#34;stack build&#34;</span>
</span></span><span class="line"><span class="cl">		<span class="nv">haskell-compile-stack-build-alt-command</span> <span class="s">&#34;stack build --pedantic&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">define-key</span> <span class="nv">haskell-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&#34;C-c h&#34;</span><span class="p">)</span>   <span class="ss">&#39;haskell-hoogle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">define-key</span> <span class="nv">haskell-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&#34;C-c C-c&#34;</span><span class="p">)</span> <span class="ss">&#39;haskell-compile</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="hooks">Hooks<a hidden class="anchor" aria-hidden="true" href="#hooks">#</a></h3>
<p>In the Haskell example above, we briefly saw how to add a hook. A hook lets you
run a function each time a specific thing happens. Most of the time, this is
used to execute some function or activate/deactivate a mode when a certain mode
is activated.</p>
<p>For example, in my Haskell config, I want to activate <code>haskell-doc-mode</code> each time
I activate <code>haskell-mode</code>, so that I always have documentation on hand while I&rsquo;m
programming in Haskell.</p>
<p>Maybe you want to activate line numbers each time you start programming. To do
that, you can add a hook to <code>prog-mode</code> like so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="c1">;; Activate &#39;display-line-numbers-mode&#39; when programming</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">&#39;prog-mode-hook</span> <span class="ss">&#39;display-line-numbers-mode</span><span class="p">)</span>
</span></span></code></pre></div><p>Note the apostrophe before the names of the functions (here, the names of the modes)!</p>
<p>You can do so many more things with hooks and get really creative! I mostly use
them to set up my modes the way I like them. E.g., I always center my text
buffers (Org mode, LaTeX, etc.) with Olivetti and I hide the line numbers.</p>
<h3 id="binding-keys">Binding Keys<a hidden class="anchor" aria-hidden="true" href="#binding-keys">#</a></h3>
<p>We can get pretty deep on the subject of keybindings, so I&rsquo;ll try to keep it
brief.</p>
<p>Most major modes with have a dedicated &ldquo;mode map&rdquo; of all the keybindings you can
use while in that mode. Remember that you can always check out the currently
available keybindings with <code>C-h m</code>, which describes the current major and minor
modes.</p>
<p>This separation is very useful, as it allows you to bind the same keys to
similar commands in different settings. E.g., you can bind <code>C-c C-c</code> to the
relevant compilation command in all your programming languages if you like, even
if the actual compilation command is different for each. You can also define
your own custom keymaps and dictate when they should be used (another thing you
can use hooks for!)</p>
<p>In general, you can bind a key globally, locally, or in a specific keymap like
so:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nv">global-set-key</span> <span class="nv">KEY</span> <span class="nv">COMMAND</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nv">local-set-key</span>  <span class="nv">KEY</span> <span class="nv">COMMAND</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">define-key</span>     <span class="nv">KEYMAP</span> <span class="nv">KEY</span> <span class="nv">COMMAND</span><span class="p">)</span>
</span></span></code></pre></div><p>Note that the <code>KEY</code> must be given in a way Emacs understands. You can use the
<code>kbd</code> macro and then provide your keystrokes as a string, e.g., <code>(kbd &quot;C-c C-c&quot;)</code>.
Navigation keys and the function keys must be surrounded by <code>&lt;&gt;</code>, e.g., <code>&lt;tab&gt;</code> and
<code>&lt;F1&gt;</code>.</p>
<p>Again from the Haskell config, I set keybindings for <code>haskell-compile</code> and
<code>haskell-hoogle</code> commands in the <code>haskell-mode-map</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">define-key</span> <span class="nv">haskell-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&#34;C-c h&#34;</span><span class="p">)</span>   <span class="ss">&#39;haskell-hoogle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">define-key</span> <span class="nv">haskell-mode-map</span> <span class="p">(</span><span class="nv">kbd</span> <span class="s">&#34;C-c C-c&#34;</span><span class="p">)</span> <span class="ss">&#39;haskell-compile</span><span class="p">)</span>
</span></span></code></pre></div><p>You can define keybindings for any command in Emacs. People even build
personalised mnemonic systems. If you want to dive deep into keybindings, I
would recommend checking out the package <a href="https://github.com/abo-abo/hydra">Hydra</a>.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>Tinkering with my Emacs config is probably my favourite past-time, but even I
will admit it was a bit of a headache in the very, very beginning. I hope this
post has put a small dent in that frustration for you, or maybe given you some
pointers to where you might want to take your WIP config.</p>
<p>I welcome corrections, feedback, and questions by <a href="mailto:sophie.bosio@outlook.com">email</a>. Happy hacking!</p>
<h2 id="lsp-mode-for-clojure"><span class="org-todo done DONE">DONE</span> Setting Up Emacs LSP-Mode For Clojure <span class="tag"><span class="emacs">emacs</span></span><a hidden class="anchor" aria-hidden="true" href="#lsp-mode-for-clojure">#</a></h2>
<p>I use <a href="https://clojure.org/">Clojure</a> on the backend <a href="https://www.ardoq.com/">where I work</a>. I think it&rsquo;s really fun, especially in combination with Emacs, since Emacs is built with Emacs Lisp and Clojure is a Lisp dialect. So many of Emacs&rsquo; default keybindings started clicking for me once I started working with a language in the same tradition, editing structurally and by semantic units rather than line-by-line or character-by-character. I&rsquo;m not alone in loving both and there&rsquo;s clearly a lot of overlap between the two communities, which is evident from the number of Clojure packages for Emacs.</p>
<p>The probably most famous and popular among these is the excellent package <a href="https://cider.mx/">CIDER</a>, which provides a full-fledged development environment for Emacs with support for interactive development. CIDER has a ton of features for evaluating, debugging, and testing your code. However, you might want to supplement CIDER with other packages for things such as peeking function argument lists, navigating your code, and finding references/implementations. Emacs has some built-in documentation (<code>eldoc</code>), project management (<code>project</code>) and reference-finding capabilities (<code>xref</code>). But when you need more, <a href="https://clojure-lsp.io/">clojure-lsp</a> is your friend and the LSP client for Emacs <a href="https://emacs-lsp.github.io/lsp-mode/">lsp-mode</a> integrates pretty well with the aforementioned built-ins.</p>
<h3 id="basic-setup">Basic Setup<a hidden class="anchor" aria-hidden="true" href="#basic-setup">#</a></h3>
<p>With <code>clojure-lsp</code> installed, you can use your preferred package manager to get the Emacs package <code>lsp-mode</code>. I use <code>use-package</code>. <code>lsp-mode</code> is pretty good at integrating with the built-in Emacs features, so I&rsquo;ll let it autoconfigure, which it does by default. I&rsquo;ll defer the package loading to shave off some precious milliseconds at Emacs&rsquo; startup.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span><span class="p">)</span>
</span></span></code></pre></div><p>Let&rsquo;s add some hooks to start up <code>lsp-mode</code> when I&rsquo;m programming in Clojure. I&rsquo;ll also enable the <a href="https://github.com/justbur/emacs-which-key">which-key</a> integration.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">((</span><span class="nv">clojure-mode</span>  <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">clojurec-mode</span> <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">lsp-mode</span>      <span class="o">.</span> <span class="nv">lsp-enable-which-key-integration</span><span class="p">)))</span>
</span></span></code></pre></div><h3 id="custom-bindings">Custom Bindings<a hidden class="anchor" aria-hidden="true" href="#custom-bindings">#</a></h3>
<p>Next, I&rsquo;ll bind some keys. The LSP server can suggest code actions and to execute these quickly, I&rsquo;ll bind the command <code>lsp-execute-code-action</code> to <code>M-&lt;return&gt;</code>. <code>xref</code> works pretty well in Clojure and lets you jump to the definition of a symbol with <code>M-.</code> (and jump back by popping the ref off the stack with <code>M-,</code>), so to find references instead of the implementation, I&rsquo;ll bind <code>lsp-find-references</code> to <code>C-M-.</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">((</span><span class="nv">clojure-mode</span>  <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">clojurec-mode</span> <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">lsp-mode</span>      <span class="o">.</span> <span class="nv">lsp-enable-which-key-integration</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span> <span class="p">(</span><span class="nb">:map</span> <span class="nv">lsp-mode-map</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-M-.&#34;</span>      <span class="o">.</span> <span class="nv">lsp-find-references</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-c r&#34;</span>      <span class="o">.</span> <span class="nv">lsp-rename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;M-&lt;return&gt;&#34;</span> <span class="o">.</span> <span class="nv">lsp-execute-code-action</span><span class="p">)))</span>
</span></span></code></pre></div><p>Then, <code>C-M-.</code> pops up an <code>xref</code> buffer where I can see all references to a function, in which I can select an entry and jump to the call site.</p>
<figure><a href="/img/lsp-xref.png">
    <img loading="lazy" src="/img/lsp-xref.png"/> </a>
</figure>

<p>I can also press <code>C-c r</code> to rename a symbol as you&rsquo;d expect.</p>
<figure><a href="/img/lsp-rename.png">
    <img loading="lazy" src="/img/lsp-rename.png"/> </a>
</figure>

<p><code>M-&lt;return&gt;</code> gives me a minibuffer with available code actions.</p>
<figure><a href="/img/lsp-code-actions.png">
    <img loading="lazy" src="/img/lsp-code-actions.png"/> </a>
</figure>

<blockquote>
<p>As a quick note, the code actions show up in a regular minibuffer. I just use <a href="https://github.com/minad/vertico">vertico</a> with <a href="https://github.com/tumashu/vertico-posframe">vertico-posframe</a>, which gives me a nice childframe for mine.</p>
<p>In case you&rsquo;re interested, you can get rounded corners (on Mac OS) and fringes (Mac OS &amp; Linux) by setting the variable <code>vertico-posframe-paramters</code> with the following settings:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">setq</span> <span class="nv">vertico-posframe-parameters</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">left-fringe</span>  <span class="o">.</span> <span class="mi">12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">(</span><span class="nv">right-fringe</span> <span class="o">.</span> <span class="mi">12</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                    <span class="p">(</span><span class="nv">undecorated</span>  <span class="o">.</span> <span class="no">nil</span><span class="p">)))</span>
</span></span></code></pre></div></blockquote>
<h3 id="diagnostics">Diagnostics<a hidden class="anchor" aria-hidden="true" href="#diagnostics">#</a></h3>
<p>LSP mode automatically tries to figure out which diagnostics tool you&rsquo;re using, but I ran into some strange problem with the <code>:auto</code> setting when using <a href="https://www.flycheck.org/en/latest/">Flycheck</a>, so I set it to use Flycheck manually.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">((</span><span class="nv">clojure-mode</span>  <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">clojurec-mode</span> <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">lsp-mode</span>      <span class="o">.</span> <span class="nv">lsp-enable-which-key-integration</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span> <span class="p">(</span><span class="nb">:map</span> <span class="nv">lsp-mode-map</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-M-.&#34;</span>      <span class="o">.</span> <span class="nv">lsp-find-references</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-c r&#34;</span>      <span class="o">.</span> <span class="nv">lsp-rename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;M-&lt;return&gt;&#34;</span> <span class="o">.</span> <span class="nv">lsp-execute-code-action</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-diagnostics-provider</span> <span class="nb">:flycheck</span><span class="p">))</span>
</span></span></code></pre></div><p>This gives me the regular Flycheck indicators (the arrows) that something&rsquo;s wrong, but also information in the echo area and in a popup childframe on mouse hover.</p>
<figure><a href="/img/lsp-unused-var.png">
    <img loading="lazy" src="/img/lsp-unused-var.png"/> </a>
</figure>

<h3 id="customisation">Customisation<a hidden class="anchor" aria-hidden="true" href="#customisation">#</a></h3>
<p>From this point onwards, the LSP server works really well on my machine for Clojure. However, <code>lsp-mode</code> comes with a few more bells and whistles than I&rsquo;d like, so I&rsquo;ll finish by deactivating some features. A tour of on-by-default features and guide on how to disable them can be found <a href="https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/">here</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">((</span><span class="nv">clojure-mode</span>  <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">clojurec-mode</span> <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">lsp-mode</span>      <span class="o">.</span> <span class="nv">lsp-enable-which-key-integration</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span> <span class="p">(</span><span class="nb">:map</span> <span class="nv">lsp-mode-map</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-M-.&#34;</span>      <span class="o">.</span> <span class="nv">lsp-find-references</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-c r&#34;</span>      <span class="o">.</span> <span class="nv">lsp-rename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;M-&lt;return&gt;&#34;</span> <span class="o">.</span> <span class="nv">lsp-execute-code-action</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-diagnostics-provider</span> <span class="nb">:flycheck</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">;; Disable visual features</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-headerline-breadcrumb-enable</span> <span class="no">nil</span>   <span class="c1">;; No breadcrumbs</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-ui-sideline-enable</span>           <span class="no">nil</span>   <span class="c1">;; No sideline</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-lens-enable</span>                  <span class="no">nil</span>   <span class="c1">;; No lenses</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Disable all mode line features, since I use a custom mode line</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-modeline-code-actions-enable</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-modeline-diagnostics-enable</span>  <span class="no">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Limit raising of the echo area to show docs</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-signature-doc-lines</span> <span class="mi">3</span><span class="p">))</span>
</span></span></code></pre></div><p>With all this, I get a lot of nice LSP features. In conjunction with CIDER, this is starting to feel really smooth.</p>
<p>For example, the function&rsquo;s docstring in the echo area when it&rsquo;s at point.</p>
<figure><a href="/img/lsp-lookup-signature.png">
    <img loading="lazy" src="/img/lsp-lookup-signature.png"/> </a>
</figure>

<p>LSP-mode also plays nicely with my completion system, here using <a href="https://github.com/minad/corfu">corfu</a>.</p>
<figure><a href="/img/lsp-corfu.png">
    <img loading="lazy" src="/img/lsp-corfu.png"/> </a>
</figure>

<h3 id="performance-improvements">Performance Improvements<a hidden class="anchor" aria-hidden="true" href="#performance-improvements">#</a></h3>
<p>And finally, LSP-mode works a little bit faster if we set it to use plists for serialisation. We can set this in the <code>:init</code>-block of the <code>use-package</code> declaration.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="nb">:init</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-use-plists</span> <span class="no">t</span><span class="p">)</span>
</span></span></code></pre></div><p>Note that if you want to do this, you also need to add <code>(setenv &quot;LSP_USE_PLISTS&quot; &quot;true&quot;)</code> to your <code>early-init.el</code>. See <a href="https://emacs-lsp.github.io/lsp-mode/page/performance/">the performance part</a> of the <code>lsp-mode</code> documentation for more information.</p>
<h3 id="final-configuration-and-further-reading">Final Configuration &amp; Further Reading<a hidden class="anchor" aria-hidden="true" href="#final-configuration-and-further-reading">#</a></h3>
<p>And here&rsquo;s the final configuration that I&rsquo;m using for Clojure as of September 2024.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-emacs-lisp" data-lang="emacs-lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">use-package</span> <span class="nv">lsp-mode</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:defer</span> <span class="no">t</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:init</span> <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-use-plists</span> <span class="no">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:hook</span> <span class="p">((</span><span class="nv">clojure-mode</span>       <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">clojurec-mode</span>      <span class="o">.</span> <span class="nv">lsp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">(</span><span class="nv">lsp-mode</span>           <span class="o">.</span> <span class="nv">lsp-enable-which-key-integration</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:bind</span> <span class="p">(</span><span class="nb">:map</span> <span class="nv">lsp-mode-map</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-M-.&#34;</span>      <span class="o">.</span> <span class="nv">lsp-find-references</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;C-c r&#34;</span>      <span class="o">.</span> <span class="nv">lsp-rename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">              <span class="p">(</span><span class="s">&#34;M-&lt;return&gt;&#34;</span> <span class="o">.</span> <span class="nv">lsp-execute-code-action</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">  <span class="nb">:config</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-diagnostics-provider</span> <span class="nb">:flycheck</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1">;; Disable visual features</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nb">setq</span> <span class="nv">lsp-headerline-breadcrumb-enable</span> <span class="no">nil</span>   <span class="c1">;; No breadcrumbs</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-ui-sideline-enable</span>           <span class="no">nil</span>   <span class="c1">;; No sideline</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-lens-enable</span>                  <span class="no">nil</span>   <span class="c1">;; No lenses</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Disable all mode line features, since I use a custom mode line</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-modeline-code-actions-enable</span> <span class="no">nil</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-modeline-diagnostics-enable</span>  <span class="no">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">;; Limit raising of the echo area to show docs</span>
</span></span><span class="line"><span class="cl">        <span class="nv">lsp-signature-doc-lines</span> <span class="mi">3</span><span class="p">))</span>
</span></span></code></pre></div><p>The next thing I would consider to enhance my Clojure coding experience even further, is incorporating structural editing. Clojure, being a LISP dialect and therefore pretty close to an abstract syntax tree, is especially well-suited to structural editing. <a href="https://paredit.org/">paredit</a> is the classic and what I&rsquo;ve used previously. Now, I use a combination of paredit and <a href="https://github.com/abo-abo/lispy">lispy</a>, which has many more functions than paredit, with paredit-style keybindings. <a href="https://github.com/Fuco1/smartparens">Smartparens</a> is a paredit-alternative. <a href="https://github.com/AmaiKinono/puni">puni</a> is the most language-agnostic alternative, as far as I can tell.</p>
<p>Thanks for reading! I welcome feedback, comments, or questions. You can reach me via email or GitHub.</p>
<h2 id="a-pragmatic-view-on-monads-part-1-3"><span class="org-todo todo TODO">TODO</span> A Pragmatic View on Monads - Part 1/3<a hidden class="anchor" aria-hidden="true" href="#a-pragmatic-view-on-monads-part-1-3">#</a></h2>
<p>This is a rather long and opinionated introduction to monads. I hope you find it useful, or at least interesting.</p>
<aside>
<p>This is part 1 out of 3.</p>
<p>It aims to give you some theoretical foundations before we jump into the practical example. I hope it makes you feel not only that the example is easier to follow and better motivated, but also like you have a jumping off point to learn more about monads if the topic interests you.</p>
<p>Feel free to skip it if you&rsquo;re familiar with monads as a concept.</p>
<p>Part 2 is a practical example and the meat of the series, while part 3 consists of monad examples and further reading.</p>
</aside>
<p>I loved reading Elements of Clojure by Zachary Tellmann and I really appreciated his effort to make explicit knowledge that for most programmers is <em>tacit</em>. Tacit knowledge is all the innate/explicit/subconscious knowledge we have and rely on for other things. As an example, he explains that speaking requires tacit knowledge of how to articulate all the sounds in a given language. This does not mean we know how to explain the process of articulating or to teach it to a beginner. Rather, we tend to teach through demonstration, leading to trial and error for the student. Most people need practice in order to become good educators.</p>
<p>In general, I think failing or neglecting to communicate tacit knowledge is what makes a new topic seem mystical or opaque. If we try to learn something without naming and separating the building blocks its made up of, I think we often become frustrated and whole topic becomes solidified as a &ldquo;difficult topic&rdquo;. I feel this is the case for monads. It&rsquo;s a rich subject, but in my opinion, we should be able to teach the principal applications of monads in computer science without inducing headaches.</p>
<p>On that note, we can outline some key questions that a decent explanation should try to answer:</p>
<ol>
<li><strong>What?</strong> What <em>is</em> a monad, technically speaking?</li>
<li><strong>Why?</strong> Why are we interested in using monads in programming?</li>
<li><strong>But&hellip; WHY?</strong> What are the benefits of using monads over other methods?</li>
<li><strong>How?</strong> How can we implement a monad from scratch and how is it used?</li>
<li><strong>Okay, so&hellip;</strong> What are some common monads?</li>
<li><strong>Cool!</strong> What can I search for to learn more?</li>
</ol>
<p>In part 1, we&rsquo;ll cover questions 1-3. Part 2 covers 4, and part 3 covers 5 and 6.</p>
<h3 id="1-what-a-lightly-theoretical-introduction">1 - <strong>What?</strong> A Lightly Theoretical Introduction<a hidden class="anchor" aria-hidden="true" href="#1-what-a-lightly-theoretical-introduction">#</a></h3>
<p>So, what <em>are</em> monads?</p>
<p>Monads are a concept from a formalism called category theory. Just like set theory and logical theories, it overlaps with both mathematics and computer science. Loosely, category theory is the study of mathematical <em>structures</em>. Informally speaking, the category theorist asks:</p>
<ul>
<li>If a lot of concepts seem to have similarities, is there a <em>generalised</em> structure that is common to all of these?</li>
<li>What properties does this generalised structure have?</li>
<li>How do different structures relate to one another?</li>
</ul>
<p>Turns out knowing that concept X is actually just a specific case of the general structure Y can be very useful. &ldquo;Ah, but X is a Y, so therefore I can do all these things with it!&rdquo; Monads are one of these general structures and we actually them all the time in computer science. For example, lists are monads! Therefore, all properties of monads are also properties of lists. Knowing a few examples of common monads and the properties of a monad can therefore be valuable in and of itself.</p>
<p>Typically, somebody familiar with monads are tempted to use terminology, convention, shorthand, and notation from category theory or math without explaining them properly. They are very nice once you&rsquo;ve become comfortable with these, because they&rsquo;re very precise, but it&rsquo;s easy to get lost in the definition sauce if you&rsquo;re just starting out. I think it&rsquo;s important to focus on <em>why</em> we are interested in using them in the first place and how you can begin applying this knowledge yourself.</p>
<p>In this post, I&rsquo;ll therefore first give you a (not <em>the</em>) rationale for using monads in functional programming and computer science more broadly. It&rsquo;ll include a brief and utilitarian introduction to the category theoretical concepts involved so that if you do feel compelled to read more about them, you&rsquo;ll have hooks to hang your knowledge on. And if you forget something, you&rsquo;ll have a name that you can look up.</p>
<p>Part 2 will contain the practical example. The code examples will be in Python and Haskell, mainly because (1) I am familiar with them and (2) their syntaxes are relatively minimal, in my opinion making the patterns easier to see.</p>
<h3 id="2-why-pure-functions-and-stateful-computations">2 - <strong>Why?</strong> Pure Functions &amp; Stateful Computations<a hidden class="anchor" aria-hidden="true" href="#2-why-pure-functions-and-stateful-computations">#</a></h3>
<p>So, what is the point of learning monads? Essentially, it&rsquo;s a way for us to write stateful computations in a purely functional way. Let me elaborate.</p>
<p>In purely functional programming languages, we cannot normally have stateful computations, because all our functions are <em>pure</em>. Pure functions are functions in the mathematical sense: They take some input and they return some output - nothing more. The function always returns the same output for a given input. Because of this property, we can replace a function called on a particular value with the final value without losing anything. I.e., <code>3 + 5</code> can be replaced with <code>8</code> and nothing breaks or changes because of this replacement. This is called &ldquo;referential transparency&rdquo;.</p>
<p>A pure function cannot access mutable state. It cannot read from or write to some variable that may change and use it to determine its output. Reading from or writing to some variable is what we would call a <em>side-effect</em>. Pure functions are free of side-effects, and instead the output is <em>solely</em> dependent on the input.</p>
<p>Recall that for a particular input, a pure function will <em>always</em> return the same output. Because of this property, it is safe for pure functions to call other pure functions in their definition. So maybe I lied when I said they only depend on the input, but just like replacing a function call on a concrete with its output, we can replace the call to the external function with the code of the function losslessly. So splitting or code up into smaller functions mainly helps us reuse and read code.</p>
<p>The minute a function calls an <em>impure</em> function, therefore, the original function becomes impure as well. In purely functional languages like Haskell, impure functions are disallowed. In languages like Python and JavaScript, we can write purely functional functions and compose them into other pure functions by being mindful of only composing pure functions.</p>
<p>All this may sound restrictive, but these properties mean we can be pretty confident about what will happen when we compose functions, since the result of one is simply piped/threaded into the next, with no chance of side-effects doing something expected. No external state can change between this call and the next, at least in an asynchronous context. Testing small, pure functions is simpler for this reason, as well. If all the small functions are correct, then any large functions (composed of the right small functions) will be correct, too.</p>
<p>At the same time, a lot of what we want our computers to do for us, <em>does</em> require state. State is good sometimes! For example, in order to print to the terminal, our program needs to know the current state of the terminal (what has already been printed) and add to it (a new line of text, for example).</p>
<p>Monads allow us to write and execute stateful computations in a purely functional and restricted way. The restriction is key. Monads require us to specify exactly how we are allowed to interact with the state, which makes for safer state mutation than we normally have in imperative, impure contexts.</p>
<h3 id="3-but-dot-dot-dot-why-the-case-for-monads">3 - <strong>But&hellip; WHY?</strong> The Case for Monads<a hidden class="anchor" aria-hidden="true" href="#3-but-dot-dot-dot-why-the-case-for-monads">#</a></h3>
<p>I just said earlier that pure functions are mappings from inputs to outputs. How can this be used to model state? To convince you that this is possible before we see some practical examples, I&rsquo;ll ask you to consider the Turing machine.</p>
<p>The Turing machine is a computational model that can (given enough space and time) perform all the same computations that our modern computers can. Any program written on a regular computer, can be translated to an equivalent Turing machine program and executed on it, in theory.</p>
<p>The lambda calculus is another model of computation. In its simplest form, it consists of three elements:</p>
<ul>
<li>Variables</li>
<li>Function abstraction</li>
<li>Function application</li>
</ul>
<p>Note that the relevant function abstractions are <em>pure</em>.</p>
<p>Alonzo Church, Alan Turing, and Stephen Kleene proved that the lambda calculus is <em>equivalent</em> to Turing machines (and in turn to general recursive functions). In other words, even the nastiest, most stateful imperative program can be translated to an equivalent program consisting only of pure functions. Thus, there must be a way to represent stateful computations in a purely functional context as well.</p>
<p>If you can write your program either in an imperative, stateful style or in the functional style, why would you choose the one that forces you to learn about monads to do something as simple as print to the terminal?</p>
<p>There are two arguments that I find compelling.</p>
<p>The first is that you can determine statically and on the type-level whether a function is pure or whether it may have potential side-effects. This is more interesting in strongly typed languages.</p>
<p>The second, and I think stronger, argument is that monads force you to define an interface to access state.</p>
<p>In imperative, mutable, stateful code, you give every function access to your state as default, and then you must restrict that access via encapsulation. In purely functional, immutable code, you give <em>no one</em> access to change state by default and then you define a specific interface to some state by defining a monad, whose operations determine how you can access the state.</p>
<p>For this reason, I think a monad is a useful design pattern/abstraction even in languages with mutable state, when the allowed actions on the state are well-defined, narrow in scope, and unlikely to change.</p>
<h3 id="some-category-theory-and-a-teaser-for-part-2">Some Category Theory &amp; A Teaser for Part 2<a hidden class="anchor" aria-hidden="true" href="#some-category-theory-and-a-teaser-for-part-2">#</a></h3>
<p>In category theory, a category is just a collection of things that relate to each other, together with those relations. The things are called &ldquo;objects&rdquo; and we treat them like black boxes with names. However, we can tell a lot about them by the way they relate to one another. These relations are called &ldquo;morphisms&rdquo;. This is the root of many important words in mathematics, in particular &ldquo;isomorphism&rdquo;, which you may have encountered before. A morphism is a generalisation of functions, mappings, pairs, and anything else that relates two objects. We represent them with arrows from one object to another.</p>
<p>Categories have two important properties. The first is that each object has an identity morphism - i.e., a looping arrow that points from the object and back to the same object. The second is that morphisms can be composed if the target of one is the source of another, and this composition is <em>associative</em>. Associativity just means that when composing three morphisms \(f, g, h\) with the composition operator \(\circ\), the final result doesn&rsquo;t change based on which we choose to compose first, as long as the composition is valid. So \(h \circ (g \circ f)\) produces the <em>same</em> composite morphism as \((h \circ g) \circ f\), similar to how \(5 + (3 + 1) = (5 + 3) + 1\).</p>
<p>A monad is a transformation that takes an object (or a morphism) and gives it a way to:</p>
<ul>
<li>Access (read from or add to) state</li>
<li>Thread the result from one stateful computation into the next to create a chain of stateful computations</li>
<li>Resolve the chain of computations to get the final result and the accumulated state</li>
</ul>
<p>In particular, this transformation is a functor. A functor is like a super function: It can take objects (values) like a regular function and map it to another object, but it can also take whole morphisms (functions) and map them to other morphisms. This mapping must preserve the source and target of each morphism so that the original morphism and its mapped version correspond, and composition is preserved.</p>
<p>TODO: Insert picture here</p>
<p>Normally a functor maps objects and morphisms (functions) from one one category (&ldquo;domain&rdquo;) to another, but monads are functors that map from one category to within the same category. This mapping imbues regular objects and morphisms with the state and the operations on it. I hope to make this notion a bit clearer with the example in part 2.</p>
<aside>
<p>Feedback and corrections are very much welcome. Please direct them to me by email or by opening an issue on the blog&rsquo;s <a href="https://github.com/SophieBosio/sophiebosio.github.io">GitHub repo</a>.</p>
</aside>
<h2 id="a-pragmatic-view-on-monads-part-2-3"><span class="org-todo todo TODO">TODO</span> A Pragmatic View on Monads - Part 2/3<a hidden class="anchor" aria-hidden="true" href="#a-pragmatic-view-on-monads-part-2-3">#</a></h2>
<p>Finally, it&rsquo;s time to look at some code!</p>
<aside>
<p>This is part 2 out of 3.</p>
<p>Part 1 was a high-level introduction to monads and gave the motivation for using monads in (functional) programming. It answered questions 1-3 in the following list:</p>
<ol>
<li>What <em>is</em> a monad, technically speaking?</li>
<li>Why are we interested in using monads in programming?</li>
<li>What are the benefits of using monads over other methods?</li>
<li>How can we implement a monad from scratch?</li>
<li>What are some common monads?</li>
<li>What can I search for to learn more?</li>
</ol>
<p>Here in part 2, we&rsquo;ll cover question 4 by an example implementation.</p>
<p>Part 3 covers questions 5 and 6.</p>
</aside>
<p>Recall from part 1 that a monad is a transformation that takes an input and gives it a way to:</p>
<ul>
<li>Access (read from or add to) state</li>
<li>Thread the result from one stateful computation into the next to create a chain of stateful computations</li>
<li>Resolve the chain of computations to get the final result and the accumulated state</li>
</ul>
<p>Let&rsquo;s make this clearer with an example.</p>
<p>This following example is well-known and not my invention.</p>
<h3 id="introducing-our-running-example">Introducing Our Running Example<a hidden class="anchor" aria-hidden="true" href="#introducing-our-running-example">#</a></h3>
<p>Say you have two functions, <code>inc</code> and <code>sqr</code>, which take an integer and increments it and squares it, respectively. Below is a Python implementation.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span>
</span></span></code></pre></div><p>These functions are nice and pure.</p>
<p>Now let&rsquo;s say you want to add logging to these functions. The logs are a list of strings and each function should add the string <code>&quot;Incremented/Squared x&quot;</code> for a number <code>x</code> to the logs.</p>
<p>In Python, we could simply use a global variable, initialised to the empty list, and add to it for each function call.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Incremented </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Squared </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span> <span class="o">**</span> <span class="mi">2</span>
</span></span></code></pre></div><p>But now, these functions are no longer pure and it&rsquo;s harder to tell which functions might modify the <code>logs</code>.</p>
<p>To fix this, we could instead take and return a tuple, each containing a number and the corresponding log string. It takes the input number and the old logs, and it returns the result number and the updated logs. Since each input corresponds to exactly one output and there are no side effects, these functions are pure!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logs</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Incremented </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logs</span> <span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Squared </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">))</span>
</span></span></code></pre></div><p>However, there&rsquo;s a subtle problem with this approach: Why does our simple arithmetic functions know about list concatenation?</p>
<p>It&rsquo;s a muddying of responsibilities and we can imagine a data structure that is updated in a more cumbersome way than lists.</p>
<p>Instead, we can take just the number as the argument and return the tuple with the resulting number and the part of the logs that we wish to <em>add</em> to the total state. Now, our function is just dealing with values.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Incremented </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Squared </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span></code></pre></div><p>Now we have a new problem. If we want to perform several computations and pipe the result from one to the next, we need to manually extract the number from the previous result and accumulate the logs to get the final list.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Incremented </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Squared </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">runComputations</span> <span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="o">=</span> <span class="n">inc</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="o">=</span> <span class="n">sqr</span> <span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">log3</span><span class="p">)</span> <span class="o">=</span> <span class="n">inc</span> <span class="p">(</span><span class="n">result3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">finalLog</span> <span class="o">=</span> <span class="n">log1</span> <span class="o">+</span> <span class="n">log2</span> <span class="o">+</span> <span class="n">log3</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">finalLog</span><span class="p">)</span>
</span></span></code></pre></div><p>Then, we would get the desired result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">&gt;&gt;&gt; runComputations <span class="o">()</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>5, <span class="o">[</span><span class="s2">&#34;Incremented 1&#34;</span>, <span class="s2">&#34;Squared 2&#34;</span>, <span class="s2">&#34;Incremented 4&#34;</span><span class="o">])</span>
</span></span></code></pre></div><p>But at what cost? All this manual collection and concatenation is pretty cumbersome, and if we want to add a computation in the middle, we have to change the code.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">inc</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Incremented </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sqr</span> <span class="p">(</span><span class="n">x</span> <span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&#34;Squared </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">runComputations</span> <span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="o">=</span> <span class="n">inc</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="o">=</span> <span class="n">sqr</span> <span class="p">(</span><span class="n">result1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">log3</span><span class="p">)</span> <span class="o">=</span> <span class="n">sqr</span> <span class="p">(</span><span class="n">result2</span><span class="p">)</span>      <span class="c1"># added computational step</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">log4</span><span class="p">)</span> <span class="o">=</span> <span class="n">inc</span> <span class="p">(</span><span class="n">result4</span><span class="p">)</span>      <span class="c1"># changed this line</span>
</span></span><span class="line"><span class="cl">    <span class="n">finalLog</span> <span class="o">=</span> <span class="n">log1</span> <span class="o">+</span> <span class="n">log2</span> <span class="o">+</span> <span class="n">log3</span> <span class="o">+</span> <span class="n">log4</span> <span class="c1"># changed this line</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">finalLog</span><span class="p">)</span>           <span class="c1"># changed this line</span>
</span></span></code></pre></div><p>As a segue, here&rsquo;s the previous program rewritten in Haskell.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="mi">1</span>                 <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqr</span> <span class="n">result1</span>           <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">log3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqr</span> <span class="n">result2</span>           <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">log4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="n">result4</span>           <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="n">finalLog</span> <span class="ow">=</span> <span class="n">log1</span> <span class="o">++</span> <span class="n">log2</span> <span class="o">++</span> <span class="n">log3</span> <span class="o">++</span> <span class="n">log4</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">finalLog</span><span class="p">)</span>
</span></span></code></pre></div><h3 id="embellished-functions--kleisli-arrows">Embellished Functions (Kleisli Arrows)<a hidden class="anchor" aria-hidden="true" href="#embellished-functions--kleisli-arrows">#</a></h3>
<p>The type of function that we saw above, that returns the <em>result</em> of a computation (the computed number) <strong>and</strong> some update to the state (the logstring for that function call), is a special kind of function.</p>
<p>We can say that the function is &ldquo;embellished&rdquo; with an new addition to the state - or &ldquo;context&rdquo; - for that computation, that can be added to the &ldquo;global&rdquo; state by a defined &ldquo;update&rdquo; function.</p>
<p>In our case, the state addition is a list with a single string and the update function is list concatenation.</p>
<p>The general, category theoretical term for this type of function is a <em>Kleisli arrow</em>.</p>
<p>Kleisli arrows are actually a fantastic starting point for defining our monad, so let&rsquo;s use the functions we already have.</p>
<p>Let&rsquo;s call the normal, non-logging versions of our functions by their old names and the new, Kleisli arrow versions <code>inc'</code> and <code>sqr'</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="c1">-- Normal functions</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- Kleisli arrow versions</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sqr&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</span></span></code></pre></div><p>Then we can draw a picture to represent them like this. Here, <code>a, b, c</code> are arbitrary numbers, related as expected by the functions.</p>
<p>TODO: Insert picture here.</p>
<p>Now the problem we want to tackle is exactly the same as we saw before. Can we somehow abstract away the threading of results and accumulation of state? After calling <code>inc'</code> , we want to pass <code>b</code> from the result <code>(b, logs1)</code> into <code>sqr'</code> and then combine <code>logs2</code> and <code>logs1</code>.</p>
<p>In a sense, we want to define a function that can <em>compose</em> two Kleisli arrows.</p>
<p>This is where monads come in. A monad <code>m</code> is a transformation that takes a regular object (like our <code>b</code>) and transforms it into an object <code>m(b)</code> that has an implicit state update - in this case, <code>logs1</code>. This is often written <code>m b</code> in Haskell, without parentheses.</p>
<p>The transformation (monad) <code>m</code> implements two functions of particular note: <code>return</code> and <code>&gt;&gt;=</code> (&ldquo;bind&rdquo;).</p>
<p><code>return</code> takes a regular value and embellishes it with the &ldquo;empty&rdquo; or neutral state addition, called the &ldquo;identity element&rdquo; for that kind of state. For lists, this is the empty list, <code>[]</code>.</p>
<p>Bind (<code>&gt;&gt;=</code> in Haskell) is the function that threads results from one computation to the next and combines their states using the &ldquo;update&rdquo; function. For lists, the update function is list concatenation, <code>++</code>. I think the bind function in particular is easier to understand in the context of an example implementation, so I&rsquo;ll leave it at that for now.</p>
<p>So, if the transformed object <code>m b</code> can represent the combination of <code>b</code> and <code>logs1</code> <strong>and</strong> it has these two handy functions, we can replace <code>(b, logs1)</code> with <code>m b</code>, and by the same token change <code>(c, logs2)</code> to <code>m c</code>.</p>
<p>TODO: Insert picture here.</p>
<p>These new versions of the functions <code>inc'</code> and <code>sqr'</code> are still Kleisli arrows, because they still embellish the original computational result with additional context.</p>
<p>Now, since each function returns a computation result and an addition to the existing state, we must always start our chain of monadic computations with an initial state. In our case, the natural initial state is the empty list, <code>[]</code>.</p>
<p>The result of running the (now monadic) computations, should be the final number and the final logs as we saw before, which has the type <code>(Int, [String])</code>.</p>
<p>TODO: Insert picture here.</p>
<p>At this point, I think we&rsquo;re ready to jump into the code.</p>
<h3 id="4-how-logwriter-implementation">4 - <strong>How?</strong> <code>LogWriter</code> Implementation<a hidden class="anchor" aria-hidden="true" href="#4-how-logwriter-implementation">#</a></h3>
<p>We never want to delete anything from our logs and our functions don&rsquo;t need to read the logs, so we&rsquo;re content with defining one operation for modifying the state, namely <em>adding</em> to the logs. A monad is well-suited to manage this kind of state. Our state will be a write-only list of strings representing our logs and we&rsquo;ll only ever write to it. Let&rsquo;s therefore call our monad the <code>LogWriter</code>.</p>
<aside>
<p>The <code>LogWriter</code> is actually a specific case of the general monad pattern <code>Writer</code>, that is defined in the standard monad library <code>mtl</code> (&ldquo;Monad Transformer Library&rdquo;) for Haskell.</p>
<p>The <code>Writer</code> monad is quite a lot more powerful than what we&rsquo;re defining here and does not provide a write-only state, so I would recommend reading through its documentation after this post.</p>
</aside>
<p>First, we need to define a new type for our monad. Remember that a monad takes a regular object as input and creates a transformed object. Let&rsquo;s call this input <code>a</code>, where <code>a</code> represents the type of the computation result (in our case, <code>Int</code> for both our functions).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="o">?</span>
</span></span></code></pre></div><p>The first thing we&rsquo;ll define at the type level, is a constructor for the type. By convention, the constructor has the same name as the type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="o">?</span>
</span></span></code></pre></div><p>The final thing we need at this stage, is to define the function that we&rsquo;ll use to run computations in the <code>LogWriter</code> monad. Let&rsquo;s call it <code>run</code>. The following Haskell record syntax is kind of funky, but essentially states that <code>run</code> is a function defined for <code>LogWriter</code>-transformed objects that returns a <code>(a, [String])</code>. The actual implementation is generically derivable in Haskell, so at this point, we&rsquo;re done with the type declaration.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">}</span>
</span></span></code></pre></div><p>Next, we&rsquo;ll need to declare <code>LogWriter</code> as a monad. In Haskell, this means making <code>LogWriter</code> an instance of the <code>Monad</code> typeclass. The <code>Monad</code> typeclass just requires us to define the two functions mentioned earlier, <code>return</code> and <code>bind</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">LogWriter</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>The <code>return</code> function is relatively straightforward to implement for our <code>[String]</code> state. As mentioned, the identity element of lists under concatenation, <code>++</code>, is the empty list, <code>[]</code>. This represents the &ldquo;emtpy&rdquo; state addition - i.e., an addition that doesn&rsquo;t change the existing state.</p>
<p><code>return</code> has the type signature <code>return :: Monad m ==&gt; a -&gt; m a</code>, because it takes a regular object <code>a</code> and turns it into a monadic object <code>m a</code>. In our case, <code>m</code> is <code>LogWriter</code>. And we just need to wrap the result and the empty state in our custom <code>LogWriter</code> constructor and we&rsquo;re done. Easy!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">LogWriter</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Now, the bind operator <code>&gt;&gt;=</code> is a little particular. Recall that what we want to do is to take an embellished result from a previous computation &ndash; <code>m b</code>, where <code>b</code> is the result of the computation &ndash; and pipe the <code>b</code> to the next computation &ndash; something that takes a regular, non-embellished <code>b</code> and returns a new embellished result <code>m c</code> &ndash; and combines them.</p>
<p>TODO: Insert image here</p>
<p>The type signature of bind is <code>(&gt;&gt;</code>) :: Monad m <code>=&gt; m b -&gt; (b -&gt; m c) -&gt; m c</code>. We&rsquo;re starting with an embellished result, which is a <code>LogWriter</code> object that contains a tuple <code>(b, oldLogs)</code> where <code>b</code> is a number that we want to pipe to the next computation. Then we&rsquo;re taking the next computation that we want to run, which we&rsquo;ll call <code>f</code>. The result of calling <code>f</code> on <code>b</code> is another embellished result, which is a <code>LogWriter</code> wrapper around a tuple <code>(c, newLogs)</code>. We can bind these names in a <code>let</code>-statement for easy access to the values. Finally, we want to return a new <code>LogWriter</code> which contains <code>c</code> and the combined logs.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">LogWriter</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">{</span> <span class="n">run</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">LogWriter</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">LogWriter</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">LogWriter</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">LogWriter</span> <span class="n">c</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">oldLog</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">newLog</span><span class="p">))</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">                                  <span class="kr">in</span>  <span class="p">(</span><span class="kt">LogWriter</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">oldLog</span> <span class="o">++</span> <span class="n">newLog</span><span class="p">))</span>
</span></span></code></pre></div><p>And that does it for the <code>Monad</code> typeclass part!</p>
<p>However, we&rsquo;re not quite done yet. There&rsquo;s something I&rsquo;ve neglected to mention. The experienced among you will have read that a monad is &ldquo;a monoid in the category of endofunctors&rdquo;, and it&rsquo;s finally time to dig into that statement a little further. At the end of the next section, we&rsquo;ll complete our monad definition and in the following section, I&rsquo;ll show you some examples of our monad in action. Hang tight!</p>
<h3 id="functors">Functors<a hidden class="anchor" aria-hidden="true" href="#functors">#</a></h3>
<p>At this point, we need to hop back to category theory briefly. Recall how a category is a collection of objects and morphisms between objects, with identity morphisms and an associative composition operator. In part 1, we also touched briefly on the concept of functors and endofunctors, stating that</p>
<h3 id="the-logwriter-in-action">The <code>LogWriter</code> In Action<a hidden class="anchor" aria-hidden="true" href="#the-logwriter-in-action">#</a></h3>
<h3 id="review">Review<a hidden class="anchor" aria-hidden="true" href="#review">#</a></h3>
<h2 id="a-pragmatic-view-on-monads-part-3-3"><span class="org-todo todo TODO">TODO</span> A Pragmatic View on Monads - Part 3/3<a hidden class="anchor" aria-hidden="true" href="#a-pragmatic-view-on-monads-part-3-3">#</a></h2>
<h3 id="okay-so-dot-dot-dot-common-monads"><strong>Okay, so&hellip;</strong> Common Monads<a hidden class="anchor" aria-hidden="true" href="#okay-so-dot-dot-dot-common-monads">#</a></h3>
<h3 id="a-deeper-dive-into-kleisli-arrow-composition">A Deeper Dive Into Kleisli Arrow Composition<a hidden class="anchor" aria-hidden="true" href="#a-deeper-dive-into-kleisli-arrow-composition">#</a></h3>
<p>This operator is called the Kleisli composition operator. In Haskell, it&rsquo;s also called the &ldquo;fish operator&rdquo; because it looks like this: <code>&gt;=&gt;</code>.</p>
<p>The Kleisli composition operator should take two Kleisli arrows and combine them into one.</p>
<h3 id="cool-further-reading"><strong>Cool!</strong> Further Reading<a hidden class="anchor" aria-hidden="true" href="#cool-further-reading">#</a></h3>
<h2 id="demystifying-monads-1"><span class="org-todo todo TODO">TODO</span> Demystifying Monads - Part 1/3 <span class="tag"><span class="functionalprogramming">functionalprogramming</span><span class="haskell">haskell</span><span class="monads">monads</span></span><a hidden class="anchor" aria-hidden="true" href="#demystifying-monads-1">#</a></h2>
<p>Zachary Tellman opens his book <em>Elements of Clojure</em> by explaining the concept of <em>tacit knowledge</em>. Paraphrasing, it&rsquo;s all the innate/implicit/subconscious knowledge that we have acquired through experience and, because we didn&rsquo;t learn it in a straightforward manner ourselves, often struggle to explain clearly to others. The result is that others, too, have to go through a frustrating and non-linear process to learn it.</p>
<p>I think this is what often happens with monads, which mystify and confuse a lot of people. If they&rsquo;re like me, it&rsquo;s because they&rsquo;re ambushed by it while checking out a purely functional language like Haskell for the first time.</p>
<p>Maybe they get curious about it, but Googling the topic leaves them just as confused &ndash; many of the explanations found are either terminology-heavy or overly simplified. Typically definitions range between &ldquo;a monad is a monoid in the category of endofunctors&rdquo; on one end and &ldquo;a burrito!&rdquo; on the other. Neither is particularly helpful the first time around.</p>
<p>I think this happens because people who understand monads struggle to communicate their tacit knowledge, which leads to people trying to learn becoming frustrated!</p>
<p>But that&rsquo;s a shame. I think we should be able to teach and learn about monads without this much pain. I won&rsquo;t pretend I understand monads completely (for example, I haven&rsquo;t looked into their applications in mathematics), but the way we tend to use monads in computer science isn&rsquo;t all that crazy. So in this blog series, we&rsquo;ll have a closer look at the humble monad.</p>
<p>I personally feel a need to know <em>where</em> a concept came from and <em>why</em> I should bother with it. So in this first part, I&rsquo;ll cover some of the theory behind monads. In Part 2, we&rsquo;ll roll up our shirt sleeves, iteratively implement our own monad, and finally see that theory in action. Finally, in Part 3, we&rsquo;ll implement a couple of famous monads for fun and I&rsquo;ll provide some resources for further reading.</p>
<p>If you&rsquo;re just interested in the application of monads or you&rsquo;re already familiar with the theory, then you have my blessing to jump right to Part 2. Otherwise, let&rsquo;s dive in!</p>
<h3 id="what-is-a-monad">What <em>is</em> a Monad?<a hidden class="anchor" aria-hidden="true" href="#what-is-a-monad">#</a></h3>
<p>The monad is a concept from a formalism called category theory.</p>
<p>Just like set theory, category theory has applications in both mathematics and computer science. Category theory is the study of mathematical <em>structures</em>. Informally speaking, the category theorist wants to know:</p>
<ul>
<li>If different mathematical concepts have similarities, what are their commonalities? Can we make out the general, shared structure?</li>
<li>What properties does this generalised structure have?</li>
<li>How are different generalised structures related to one another?</li>
</ul>
<p>This all sounds abstract because it is. Category theory is sometimes referred to as the &ldquo;mathematics of mathematics&rdquo;. But here, we&rsquo;ll just dip our toes into the stuff I think is useful to us right now, and the rest you can read about later if you&rsquo;re interested.</p>
<p>Now, when we prove a property of a generalised structure, that property holds true for all the specific cases, too. Turns out this is really useful! And a lot of the mathematical concepts we use in programming are specific cases like these.</p>
<p>As you might already have guessed, monads are one of these general structures that we actually use all the time. For example, lists are monads! Consider that a teaser for Part 3.</p>
<p>Okay, now we&rsquo;ve covered some  theoretical grounds. Before we jump into more theory, I think now is a good time to explain why we&rsquo;re even interested in monads in the first place. They&rsquo;re not just a source of factoids about things we already know how to use, like lists, but a pretty neat design pattern that we can use to structure our code.</p>
<h3 id="pure-functions--or-why-use-monads">Pure Functions (Or, Why Use Monads?)<a hidden class="anchor" aria-hidden="true" href="#pure-functions--or-why-use-monads">#</a></h3>
<p>The <em>need</em> for monads (or some alternative) is mostly in purely functional programming languages. This being said, monads are language agnostic and can be used to great effect regardless. A monad in Haskell is the same as a monad in Typescript.</p>
<p>But back to our motivation.</p>
<p>A purely functional programming language only allows you to write <em>pure</em> functions. There are many equivalent ways of defining pure functions. I find it useful to think of it as a mapping between outputs and inputs: Each input is mapped to one and only one output, and the function does nothing else. The function is defined <em>entirely</em> by its definition &ndash; nothing else can affect what the function does.</p>
<p>The fact that calling a function on a given input returns the same output every time you call it, is called <em>referential transparency</em>. It means that anywhere in your code, you can replace a given function call with its result and vice versa without changing the semantics of your code.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="c1">-- This program</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;I&#39;m &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="mi">99</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">++</span> <span class="s">&#34; years old!&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- is exactly equivalent to this program</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;I&#39;m &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="mi">100</span> <span class="o">++</span> <span class="s">&#34; years old!&#34;</span>
</span></span></code></pre></div><p>But, borrowing an example from Tellman, if we have a strange definition of <code>+</code> that <em>first</em> sends out an email and <em>then</em> adds our two numbers together, the two programs above aren&rsquo;t equivalent anymore!</p>
<p>Pure functions therefore cannot perform <em>side-effects</em>, such as sending emails or generally, reading from or writing to a mutable variable/state/context.</p>
<p>I cannot call a function on Monday and get one result, then call it on Tuesday and get a different result because a variable changed in the meantime.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="c1">-- &#39;punctuation&#39; is a variable defined elsewhere</span>
</span></span><span class="line"><span class="cl"><span class="nf">ageInfo</span> <span class="n">age</span> <span class="ow">=</span> <span class="s">&#34;I&#39;m &#34;</span> <span class="o">++</span> <span class="n">age</span> <span class="o">++</span> <span class="s">&#34; years old&#34;</span> <span class="o">++</span> <span class="n">punctuation</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- On Monday:</span>
</span></span><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ageInfo</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;I&#39;m 100 years old!&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- On Tuesday:</span>
</span></span><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ageInfo</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;I&#39;m 100 years old???&#34;</span>
</span></span></code></pre></div><p>Another way to say this, is that a pure function cannot have any <em>side effects</em>. These include things like updating a mutable variable, but also reading from and writing to the terminal.</p>
<p>A <strong>read</strong> from the terminal is a function call that receives some of its input at runtime and the exact same program may return different results. The definition of the function does therefore <em>not</em> define its behaviour completely &ndash; it also depends on non-deterministic user input. Just like reading from a mutable variable, this breaks the rules.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">greet</span> <span class="ow">=</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>            <span class="c1">-- Read a line of input, save in the variable &#39;name&#39;</span>
</span></span><span class="line"><span class="cl">  <span class="n">putStrLn</span> <span class="s">&#34;Hello, &#34;</span> <span class="o">++</span> <span class="n">name</span> <span class="c1">-- Print greeting with supplied &#39;name&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- Alice is using the computer:</span>
</span></span><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">greet</span>
</span></span><span class="line"><span class="cl"><span class="kt">Alice</span>               <span class="c1">-- User inputs &#34;Alice&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kt">Hello</span><span class="p">,</span> <span class="kt">Alice</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- Bella is using the computer:</span>
</span></span><span class="line"><span class="cl"><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">greet</span> <span class="s">&#34;Bella&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kt">Bella</span>               <span class="c1">-- User inputs &#34;Bella&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kt">Hello</span><span class="p">,</span> <span class="kt">Bella</span>
</span></span></code></pre></div><p>A <strong>write</strong> to the terminal appends line(s) of text to the bottom of whatever text was there before. Therefore, writing to the terminal is like updating an existing, mutable variable. Therefore, its behaviour depends on the current state of the terminal output and will change between calls. Also illegal!</p>
<p>Just like a function call that returns a value can be replaced with that value, a pure function definition can be replaced with its definition. In other words, pure functions are immutable declarations that we can safely use in and compose with other pure functions. Therefore, a pure function can use other pure functions. The programs below are equivalent.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">compute</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- is equivalent to</span>
</span></span><span class="line"><span class="cl"><span class="nf">double</span>  <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">compute</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">40</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- is equivalent to</span>
</span></span><span class="line"><span class="cl"><span class="nf">double</span>    <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">plusForty</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">40</span>
</span></span><span class="line"><span class="cl"><span class="nf">compute</span>     <span class="ow">=</span> <span class="n">plusForty</span> <span class="o">.</span> <span class="n">double</span>  <span class="c1">-- Read &#34;plusForty&#34; after &#34;double&#34;</span>
</span></span></code></pre></div><p>But the second we use an impure function in our chain of pure functions, the whole thing becomes impure.</p>
<p>All this function purity may sound a bit restrictive, but it makes it super easy to reason about our code and to test it. Because each small function is a simple mapping from input to output, we can compose functions with confidence and quickly experiment or write tests to check that our function actually does what we expect. Composition is the core of functional programming!</p>
<p>We prefer to use pure functions as much as possible. The &ldquo;meat&rdquo; of our program should preferably consist of concise, pure functions that we compose to get bigger and more complex, pure functions. But at some point, we need to deal with stateful computation. Either because of the domain we&rsquo;re dealing with or simply because we want to print to the terminal!</p>
<p>This is where monads come in: We can use monads to model stateful computations in a purely functional way!</p>
<h3 id="the-case-for-monads">The Case For Monads<a hidden class="anchor" aria-hidden="true" href="#the-case-for-monads">#</a></h3>
<p>For now, you can think of a monad as a strict interface that defines how you can read from/write to state in your computations. The monad defines what operations are permissible and how to chain together stateful computations.</p>
<p>Now, if we can use monads to perform stateful computations, then we can break the guarantees that functional programming gives us (confidence and composability) so why not just use an imperative language with mutable variables?</p>
<p>Monads deal with <em>immutable</em> data structures and define explicitly wh</p>
<h3 id="a-taste-of-category-theory">A Taste of Category Theory<a hidden class="anchor" aria-hidden="true" href="#a-taste-of-category-theory">#</a></h3>
<h2 id="demystifying-monads-2"><span class="org-todo todo TODO">TODO</span> Demystifying Monads - Part 2/3 <span class="tag"><span class="functionalprogramming">functionalprogramming</span><span class="haskell">haskell</span><span class="monads">monads</span></span><a hidden class="anchor" aria-hidden="true" href="#demystifying-monads-2">#</a></h2>
<p>In the previous entry of this blog post series, we covered some of the theory of monads and motivated their use in the general case. This time, we&rsquo;ll take a crack at a practical example.</p>
<p>This post is largely my take on explaining a famous example. I don&rsquo;t know where it originates, but I&rsquo;ve seen others explaining the same thing, for example in the YouTube video (TODO insert reference) and this article and my lecturers and Bartosz Milewski.</p>
<p>We&rsquo;ll add some mutable state to a series of simple computations by implementing a monad from scratch. Throughout, I&rsquo;ll refer back to some of the theory from Part 1 and I&rsquo;ll be clear about what parts of our implementation are core concepts relating directly to monads and what depend on our specific case. Once we&rsquo;ve seen how one monad works, I want to show how this stuff generalises, but that deserves its own blog post - that will be Part 3 of this series.</p>
<p>I&rsquo;ll be using Haskell in the code examples below, but I&rsquo;ll try my best to explain concepts underway so you can follow along even if you haven&rsquo;t used Haskell before.</p>
<h3 id="a-running-example">A Running Example<a hidden class="anchor" aria-hidden="true" href="#a-running-example">#</a></h3>
<p>Say you have two pure functions, <code>inc</code> and <code>sqr</code>, that increments and squares a number, respectively. It takes an <code>Int</code> and returns an <code>Int</code>. In Haskell, this is what it would look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>      <span class="c1">-- Type signature</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c1">-- Implementation</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
</span></span></code></pre></div><p>Now say we want to add logging to each function so that we can run a computation like this:</p>
<ol>
<li>Increment 5</li>
<li>Increment the previous result</li>
<li>Square the previous result</li>
<li>Increment the previous result</li>
</ol>
<p>Let our log be a list of strings.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Log</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span></code></pre></div><p>The final result should give us both the number and the following log:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="p">[</span><span class="s">&#34;Incremented 5&#34;</span><span class="p">,</span> <span class="s">&#34;Incremented 6&#34;</span><span class="p">,</span> <span class="s">&#34;Squared 7&#34;</span><span class="p">,</span> <span class="s">&#34;Incremented 49&#34;</span><span class="p">]</span>
</span></span></code></pre></div><p>If we pretend Haskell is an imperative language, we could imagine that we had a mutable variable <code>log</code> that we could append to. Let&rsquo;s just take the case of <code>inc</code>, since the procedure would be the same for <code>sqr</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">log</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">log</span> <span class="ow">=</span> <span class="kt">[]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">log</span> <span class="o">+=</span> <span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></div><p>This function would no longer be pure and it would be impossible from the call site to see that it modified the <code>log</code>.</p>
<p>In Haskell, it is also illegal. Our function can only know about what is immutable or explicitly passed to it as an argument.</p>
<p>To fix this, we could also take the old log as argument and return the new log. Our new function takes and returns a tuple with an integer and a log.</p>
<blockquote>
<p><strong>NOTE:</strong></p>
<p>In Haskell, you can prepend an element to a string using the cons operator <code>:</code> but to append, you must use the list concatenation operator <code>++</code> and append a singleton <em>list</em>. That&rsquo;s why the string below is in square brackets.</p>
<p>We also convert integers to strings using the <code>show</code> operator.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Log</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">oldLog</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">oldLog</span> <span class="o">++</span> <span class="p">[</span><span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</span></span></code></pre></div><p>At first glance, this looks fine, right? Now our function is completely pure again!</p>
<p>But there&rsquo;s a subtle problem with this approach: Why does our simple arithmetic function know about list concatenation?</p>
<p>We&rsquo;re mixing concerns here, both incrementing integers and implementing our logging mechanism.</p>
<p>If we had a bunch of functions with added logging, but realised later that we wanted a different data structure for our logs and redefined the <code>Log</code> data type, we would also have to change the list concatenation operator <code>++</code> in every single function definition implementing logging.</p>
<p>Instead, we could return just the string that we&rsquo;d like to add to the logs. Then the concrete data structure and the operation used to accumulate the logs becomes opaque to the <code>inc</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">inc&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">))</span>
</span></span></code></pre></div><p>Nice, now we can write functions that just deal with values.</p>
<p>But now we have a new problem.</p>
<p>We <em>can</em> run our computations the way we want, but we need to write a new function. Let&rsquo;s call it <code>runComputations</code>.</p>
<p>It needs to take the result from each function call and thread/pipe it to the next computation and also accumulates the log fragments. We can do this by binding each intermediary result in a <code>let</code>-binding.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Log</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="s">&#34;Incremented &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="s">&#34;Squared &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="mi">5</span>       <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="n">result1</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">log3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqr</span> <span class="n">result2</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">log4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="n">result3</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="p">[</span><span class="n">log1</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log2</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log4</span><span class="p">])</span>
</span></span></code></pre></div><p>In the Haskell REPL, called GHCi, we can now run our computations and get the desired result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ghci&gt; runComputations
</span></span><span class="line"><span class="cl"><span class="o">(</span>50, <span class="o">[</span><span class="s2">&#34;Incremented 5&#34;</span>, <span class="s2">&#34;Incremented 6&#34;</span>, <span class="s2">&#34;Squared 7&#34;</span>, <span class="s2">&#34;Incremented 49&#34;</span><span class="o">])</span>
</span></span></code></pre></div><p>Well, it&rsquo;s pure and cleanly separates concerns, but&hellip; It&rsquo;s ugly and verbose. We&rsquo;re binding a series of temporary variables that are only really used to thread the values to the next computations. And worse, adding a new computation in the middle of the chain requires several changes to the code.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="mi">5</span>       <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result2</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqr</span> <span class="n">result1</span> <span class="kr">in</span> <span class="c1">-- Add this line</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- Change all temp vars in the following lines:</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result3</span><span class="p">,</span> <span class="n">log3</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="n">result2</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result4</span><span class="p">,</span> <span class="n">log4</span><span class="p">)</span> <span class="ow">=</span> <span class="n">sqr</span> <span class="n">result3</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl">  <span class="kr">let</span> <span class="p">(</span><span class="n">result5</span><span class="p">,</span> <span class="n">log5</span><span class="p">)</span> <span class="ow">=</span> <span class="n">inc</span> <span class="n">result4</span> <span class="kr">in</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- Add an extra log fragment to the result:</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="n">result5</span><span class="p">,</span> <span class="p">[</span><span class="n">log1</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log2</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log4</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="n">log5</span><span class="p">])</span>
</span></span></code></pre></div><p>Enter: Monads!</p>
<p>By implementing the above code with monads, we&rsquo;ll be able to rewrite the above function in a seemingly imperative style. This is a teaser for (one version) of what we could do with a monad:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Log</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">runComputations</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="n">run</span> <span class="o">$</span>
</span></span><span class="line"><span class="cl">  <span class="n">inc</span> <span class="mi">5</span> <span class="o">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqr</span>   <span class="o">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">  <span class="n">inc</span>   <span class="o">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">  <span class="n">sqr</span>   <span class="o">&gt;&gt;=</span>
</span></span><span class="line"><span class="cl">  <span class="n">inc</span>
</span></span></code></pre></div><h3 id="bind">Bind<a hidden class="anchor" aria-hidden="true" href="#bind">#</a></h3>
<p>Let&rsquo;s take a cue from category theory and go abstract. Our two functions, <code>inc</code> and <code>sqr</code> are functions that originally took an integer and returned an integer. Now, we&rsquo;ve proposed two modified functions, that each take an integer and return an integer plus a log string. Let&rsquo;s mark the new ones with an apostrophe.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="c1">-- Old definitions:</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">-- New definitions:</span>
</span></span><span class="line"><span class="cl"><span class="nf">inc&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">sqr&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
</span></span></code></pre></div><p>We can see that these have the same shape: Take an input, return the result of the computation plus a &ldquo;log fragment&rdquo;.</p>
<p>We can generalise the kind of function we&rsquo;re interested in like this,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">g</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span></span></code></pre></div><p>where <code>f, g, h, ...</code> are functions, <code>a, b, c, ...</code> are input/output types of the computation and <code>x, y, z, ...</code> are the &ldquo;state fragments&rdquo; (log strings, in our case).</p>
<p>First, we just had regular arithmetic functions.</p>
<figure><a href="/img/simple-arrows.png">
    <img loading="lazy" src="/img/simple-arrows.png"/> </a>
</figure>

<h3 id="kleisli-arrows">Kleisli Arrows<a hidden class="anchor" aria-hidden="true" href="#kleisli-arrows">#</a></h3>
<p>We just proposed a function <code>inc :: Int -&gt; (Int, Log)</code>. In other words, a function that takes an integer and returns an integer <em>and</em> a log.</p>
<p>This kind of transformation, that takes a given type and returns the same type plus something extra, is called a <em>Kleisli arrow</em>.</p>
<h3 id="kleisli-composition">Kleisli Composition<a hidden class="anchor" aria-hidden="true" href="#kleisli-composition">#</a></h3>
<p>The fish operator</p>
<h3 id="monads">Monads<a hidden class="anchor" aria-hidden="true" href="#monads">#</a></h3>
<p>Imperative style, or Clojure threading, but with the strange bind operator.</p>
<p>Monad transformation: Change state, empty <code>m ()</code> - Return result <code>m a</code>.
Single state - put a pin in it for when we talk about monad transformers!</p>
<p>Return and bind</p>
<p>Run</p>
<p>Diagrams</p>
<h3 id="implementing-a-logwriter-monad">Implementing a <code>LogWriter</code> Monad<a hidden class="anchor" aria-hidden="true" href="#implementing-a-logwriter-monad">#</a></h3>
<h3 id="using-logwriter">Using <code>LogWriter</code>!<a hidden class="anchor" aria-hidden="true" href="#using-logwriter">#</a></h3>
<h3 id="different-kinds-of-state">Different Kinds of State<a hidden class="anchor" aria-hidden="true" href="#different-kinds-of-state">#</a></h3>
<h2 id="demystifying-monads-2"><span class="org-todo todo TODO">TODO</span> Demystifying Monads - Part 3/3 <span class="tag"><span class="functionalprogramming">functionalprogramming</span><span class="haskell">haskell</span><span class="monads">monads</span></span><a hidden class="anchor" aria-hidden="true" href="#demystifying-monads-2">#</a></h2>
<p>Common monads</p>
<ul>
<li>List</li>
<li>Maybe</li>
<li>Either</li>
</ul>
<p>State
Writer
Monad transformers</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/posts/hugo/">
    <span class="title">« Prev</span>
    <br>
    <span>Static Site Generation with Hugo</span>
  </a>
  <a class="next" href="http://localhost:1313/posts/demystifying-monads-1/">
    <span class="title">Next »</span>
    <br>
    <span>Demystifying Monads - Part 2/3</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on x"
            href="https://x.com/intent/tweet/?text=&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f&amp;title=&amp;summary=&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f&title=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on whatsapp"
            href="https://api.whatsapp.com/send?text=%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on telegram"
            href="https://telegram.me/share/url?text=&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share  on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fall-posts%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="http://localhost:1313/">Sophie Bosio</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
