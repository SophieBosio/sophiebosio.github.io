<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Implementing a Small Interpreter in Haskell | PaperMod</title>
<meta name="keywords" content="functional, programming, haskell">
<meta name="description" content="One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.
We&rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here&rsquo;s how we approached it and some of my reflections when looking back at it.
I&rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it&rsquo;s easier to see how monads work when seeing the implementation.">
<meta name="author" content="Sophie">
<link rel="canonical" href="https://sophiebosio.github.io/posts/boa-interpreter-haskell/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0c4fd3725171366f335155acde6fb3c7b7042cd2fd075bebf5023d9b28a701b2.css" integrity="sha256-DE/TclFxNm8zUVWs3m&#43;zx7cELNL9B1vr9QI9myinAbI=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sophiebosio.github.io/static/img/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://sophiebosio.github.io/static/img/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sophiebosio.github.io/static/img/favicon.png">
<link rel="apple-touch-icon" href="https://sophiebosio.github.io/static/img/favicon.png">
<link rel="mask-icon" href="https://sophiebosio.github.io/static/img/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Implementing a Small Interpreter in Haskell" />
<meta property="og:description" content="One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.
We&rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here&rsquo;s how we approached it and some of my reflections when looking back at it.
I&rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it&rsquo;s easier to see how monads work when seeing the implementation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sophiebosio.github.io/posts/boa-interpreter-haskell/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-14T10:24:00+02:00" />
<meta property="article:modified_time" content="2023-09-14T10:24:00+02:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Implementing a Small Interpreter in Haskell"/>
<meta name="twitter:description" content="One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.
We&rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here&rsquo;s how we approached it and some of my reflections when looking back at it.
I&rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it&rsquo;s easier to see how monads work when seeing the implementation."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sophiebosio.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Implementing a Small Interpreter in Haskell",
      "item": "https://sophiebosio.github.io/posts/boa-interpreter-haskell/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Implementing a Small Interpreter in Haskell",
  "name": "Implementing a Small Interpreter in Haskell",
  "description": "One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.\nWe\u0026rsquo;d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here\u0026rsquo;s how we approached it and some of my reflections when looking back at it.\nI\u0026rsquo;ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it\u0026rsquo;s easier to see how monads work when seeing the implementation.",
  "keywords": [
    "functional", "programming", "haskell"
  ],
  "articleBody": "One of my favourite assignments in my advanced functional programming course, was implementing a parser and interpreter for a subset of Python, called Boa, in Haskell.\nWe’d just started getting a grasp of what monads are and how they work, and this project is what really solidified it for me. Here’s how we approached it and some of my reflections when looking back at it.\nI’ll be focusing on the interpreter, because we implemented the monad for the interpreter by hand, and I feel it’s easier to see how monads work when seeing the implementation. The parser, on the other hand, uses the monad combinator library Parsec, which is both more complicated and more well-documented elsewhere.\nI’ll assume you’re familiar with monads and their operations, but this is also a great project to try your hand at if you’re still getting the hang of using them.\nThe code is available in its entirety on my GitHub, and I would encourage you to follow along!\nThe Boa Language The Boa language is a small subset of Python. It looks pretty familiar to anyone who has programmed in Python before, and if you’re interested in a more thorough explanation of the language, you can check out the ./docs folder in the repo.\nThe most important aspects of the language, for our interpreter, is that it has global state. In our purely functional implementation language, computations are normally not stateful. So, we have to make use of a monad to model the program environment and interpret terms with respect to the existing bindings.\nThankfully, Boa computations can make do with read-only access to the environment. Therefore, we can use a neat and (as far as monads go) pretty intuitive monad, namely the Reader monad. We’ll implement it ourselves, but you could also just import the above package in your project.\nSpoiler Alert! Syntax File Below, you can find the finished Syntax.hs file. If you want to implement the language yourself, you might want to try your hand at writing this file, too, before seeing this suggestion.\nSyntax.hs\rmodule Syntax where data Value = None | Boolean Bool | Number Integer | Text String | List [Value] deriving (Eq, Show, Read) data Expression = Constant Value | Variable VariableName | Operation OperationSymbol Expression Expression | Not Expression | Call FunctionName FunctionInput | ListExpression [Expression] | ListComprehension Expression [Clause] deriving (Eq, Show, Read) type VariableName = String type FunctionName = String type FunctionInput = [Expression] type FunctionArguments = [Value] data OperationSymbol = Plus | Minus | Times | Div | Mod | Eq | Less | Greater | In deriving (Eq, Show, Read) data Clause = For VariableName Expression | If Expression deriving (Eq, Show, Read) type Program = [Statement] data Statement = Define VariableName Expression | Execute Expression deriving (Eq, Show, Read) Monad Implementation Executing a Boa program means evaluating all the program statements, starting from the empty environment and populating it as we go. If we encounter any runtime errors underway, we’ll stop execution and print an error message. If all is well, we’ll continue until there are no more statements, and then print the output of the program.\nLet’s use the following abbreviations.\ntype Output = [String] type ErrorMessage = String data RuntimeError = UnboundVariable VariableName | BadFunction FunctionName | BadArgument ErrorMessage deriving (Eq, Show) type Environment = [(VariableName, Value)] type Runtime a = Environment -\u003e (Either RuntimeError a, Output) An environment is a mapping from variable names to values. What we want is a monad that allows us to keep track of the variable bindings in the environment. When we want to perform a computation, we need a runtime where we can read from the environment and either raise a runtime error or return a value, and append the output from the computation so we can print it later. This is essentially what we would want to use the Reader monad for! Let’s implement a simple version.\nThe Boa Monad Every monad is an applicative functor and every applicative functor is a functor. Those are interesting to read about in their own right, but for now, we just need to know that if we implement the monad correctly, we get these two for free. For these freebies, we need to import Control.Monad. We’ll also need a newtype Boa a, whose “run” action will have the type Runtime a.\nimport Control.Monad newtype Boa a = Boa {run :: Runtime a} instance Functor Boa where fmap = liftM instace Applicative Boa where pure = return (\u003c$\u003e) = ap Nice! Now, we need to define two functions for our monad, namely return and \u003e\u003e=, and we have a fully fledged monad instance!\nFor a quick refresher, let’s look at their type signatures.\nreturn :: Monad m =\u003e a -\u003e m a (\u003e\u003e=) :: Monad m =\u003e m a -\u003e (a -\u003e m b) -\u003e m b In the case of return, we just want to take a value and put it inside the monad. What’s the simplest way we can do that? Well, our monad lets us read from the environment and we’re supposed to return either an error message or a value a, and then the output we want to print after the computation is done. The simplest way, then, is to not read anything from the environment, just put in the value, and not add anything to the output.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u003e\u003e= f = undefined Essentially, this says “I don’t care about the environment, just give me the tuple with a and no output in it, then put it all inside the Boa monad for me”. The following notation is semantically equivalent, but the syntax may be easier to read depending on what you’re used to.\nreturn a = Boa (\\_ -\u003e (Right a, [])) Then what do we want to do for \u003e\u003e=, is define a way to take a value out of the monad, apply a function to it, and then put the result back into the monad. To unwrap the value a from ba, we can simply use our monad’s run function. We have to take in an environment so that we can run the monad in the environment and look at the result. If it’s an error, then we just return the error. But if we get a value a out and some output, then we want to run the function f on a. What we’re gonna return, is the result of f a and the output of that computation appended to all the previous output. Finally, we put it all back into the Boa monad.\ninstance Monad Boa where return a = Boa $ const (Right a, []) ba \u003e\u003e= f = Boa $ \\env -\u003e case run ba env of (Left re, out) -\u003e (Left re, out) -- just return the error (Right a, out) -\u003e let (result, out') = run (f a) env -- run f a in the environment in (result, out ++ out') -- append the new output to the old Sweet! Now let’s define some operations that let us interact with the monad in a more ergonomic way.\nMonad Operations Now we have the monad itself, but it’s nice to abstract away some details and instead work with more intuitive function names. Let’s write some functions with more easily understood names.\nabort :: RuntimeError -\u003e Boa a look :: VariableName -\u003e Boa Value bind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a) output :: String -\u003e Boa () abort should just accept a runtime error and put it into the Boa monad.\nabort :: RuntimeError -\u003e Boa a abort re = Boa $ const (Left re, []) -- or equivalently, abort re = Boa (\\_ -\u003e (Left re, [])) look should accept a variable name and look to see if it is in the environment. if it is, return the value inside the monad. If it isn’t, return an “unbound variable” runtime error inside the monad. In either case, no output is necessary.\nlook :: VariableName -\u003e Boa Value look x = Boa $ \\env -\u003e case lookup x env of Just a -\u003e (Right a, []) Nothing -\u003e (Left (UnboundVariable x), []) bind takes a variable name and a value. What it should do, is run the monad with that name-value binding prepended to the old environment, and then put the value of that computation back into the monad. It needs to be prepended and not appended because when we perform a lookup, we want to find the most recent bindings first.\nbind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a) bind x v ba = Boa $ \\env -\u003e run ba $ (x,v) : env -- or equivalently, bind x v ba = Boa (\\env -\u003e run ba ( [(x,v)] ++ env )) output should take an string and put it into the monad as output.\noutput :: String -\u003e Boa () output s = Boa $ const (Right (), [s]) Interpreter Functions Finally, we need the main operations of the interpreter. To execute a Boa program, we want to take a program and return a tuple with the output of the program and possibly a runtime error.\nexecute :: Program -\u003e (Output, Maybe Runtime Error) execute p = undefined Since a Program is made up of Define and Execute statements, we can write a helper function exec that pattern matches on the type of statement.\nexec :: Program -\u003e Boa () exec [] = undefined exec ((Define x e) : s) = undefined exec ((Execute e) : s) = undefined And finally, we’ll need a helper function eval that’s responsible for evaluating a single expression and putting the resulting value into the Boa monad for us. This is what we’ll focus on for now.\neval :: Expression -\u003e Boa Value Since they’re not the most interesting part of the interpreter, I’m omitting quite a few other helper functions, notably operate ::\rOperationSymbol -\u003e Value -\u003e Value -\u003e Either ErrorMessage Value and apply ::\rFunctionName -\u003e FunctionArguments -\u003e Boa Value. They’re of course in the repo, and I’d encourage you to try implementing them yourself.\neval needs to pattern match on each expression. There are the following types of Expression:\nConstant Variable VariableName Not Expression Operation OperationSymbol Expression Expression Call FunctionName FunctionInput ListExpression [Expression] ListComprehension Expression [Clause] Constant Let’s start with Constant.\neval (Constant v) = return v It’s already a value, so we can just take it and put it directly in the monad. Easy!\nVariable What about a variable? Well, either it’s bound in the environment or it’s not and should return an error. look seems like a perfect fit for the job. It even returns an error message for us if x is not present in the environment.\neval (Variable x) = look x Not If we meet a Not expression, we should evaluate the sub-expression to a Boolean value, then take the opposite value, cast it as a Boolean and put it in the Boa monad. Actually, we can do all of this by fmap-ing (Boolean . not . truthy) onto the evaluated expression. That unwraps the expression, applies the three functions above, and then wraps it back up in the monad.\nNote that \u003c$\u003e is just an infix version of fmap, and truthy is a helper function that evaluates a Value to a Boolean value.\neval (Not e) = Boolean . not . truthy \u003c$\u003e eval e Operation An Operation is performed by evaluating each of its arguments, extracting the Value from each, using operate on them to get the result Value, and wrapping that result back in the monad. In this case, do-notation makes our code much more readable.\neval (Operation o e1 e2) = do v1 \u003c- eval e1 v2 \u003c- eval e2 case operate o v1 v2 of Right v -\u003e return v Left re -\u003e abort $ BadArgument re Call Recall that Call takes a function name f and a list of expressions es, which is the function input. What we want to do, is to evaluate all the function arguments, and then send all those values to our helper function apply, which will apply f to the evaluated es and put the result into the Boa monad.\nWith the help of mapM, we can write the function for Call expressions very succinctly. Its type signature is\nmapM :: (Traversable t, Monad m) ==\u003e (a -\u003e m b) -\u003e t a -\u003e m (t b).\nIn our case, the traversable structure is a list and the monad is the Boa monad. In our case, we can rewrite it as\nmapM :: (Expression -\u003e Boa Value) -\u003e [Expression] -\u003e Boa ([Value]).\neval, of course has the type Expression -\u003e Boa Value and the function input has type [Expression].\nGreat! So if we do mapM eval es, we’ll get a Boa [Value], where each Value is an evaluated function argument. Then we just want to take this list of values out of the monad and send it to the apply f function.\neval (Call f es) = mapM eval es \u003e\u003e= apply f List Expression We can do something similar for ListExpression, except this case is much easier! We want to evaluate all the expressions, as above, but then all we need is to put the results in a List and wrap it in the monad. Then we can just fmap List onto the evaluated expressions.\neval (ListExpression es) = List \u003c$\u003e mapM eval es List Comprehension Now, the ListComprehension is probably the trickiest case to write. Once way is to write two mutually recursive functions, the eval case for ListComprehension and a helper function comprehension.\nThe eval case for list comprehension, does more or less the same as the ListExpression does: It takes the result of evaluating the contents, and puts the resulting List into the Boa monad. Then, comprehension is the function that actually computes the result.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension = undefined comprehension takes in a list of clauses, and a Clause is either an if-statement on the form If Expression or a for-statement on the form For VariableName Expression=.\nTherefore, comprehension pattern matches on three cases: The empty list, a for-statement and more clauses, or an if-statement and more clauses.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = undefined comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined In the case of the empty list, we have a list comprehension that is really just a list expression, on the form ListComprehension Expression []. So in that case, comprehension can just evaluate e1 and return the list containing that one value, inside the Boa monad.\nOnce again, there’s a very handy function we can use, to write this code in a single, short line, namely \u003c\u0026\u003e. It’s implemented as flip fmap and has the type signature\n(\u003c\u0026\u003e) :: Functor f ==\u003e f a -\u003e (a -\u003e b) -\u003e f b.\nIn our case, we’re applying it like this,\n(\u003c\u0026\u003e) :: Boa Value -\u003e (Value -\u003e [Value]) -\u003e Boa [Value].\nThe return we’re using here is the return of the list monad. Basically, we’re saying “evaluate e1, which gives us a Boa Value. Then, take that value out of the Boa monad, put it into the list monad with return, and finally put that list with the value back in the Boa monad”.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = undefined comprehension (For x e2 : c2) = undefined Recall that the result of evaluating a list comprehension should be on the form Boa (List [Value]), which (because List [Value] is itself a Value) is just a Boa\rValue. When we return from comprehension to eval, we can fmap the constructor List onto the Boa [Value], which accomplishes exactly this: It turns the result Boa [Value] into Boa (List [Value]).\nWhen we encounter an If-expression, the syntax corresponds to e1 if e2 . So we know that the expression e2 should be a Boolean value. Luckily, in Boa as in Python, non-Boolean values correspond to a Boolean value. E.g., 1==True is true and 0==True is false.The first thing we can do, then, is to evaluate e2 and find the corresponding Boolean value with truthy.\nBy fmap-ing truthy onto the evaluated expression, we get a Boa Bool, i.e., a normal Haskell Boolean inside the Boa monad. By using do-notation, then, we can give b the unwrapped Boolean and we can use it directly in an if-statement. If the condition b holds, then evaluate the rest of the list comprehension. Else, there’s no more to evaluate.\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = undefined The case for For statements is probably the hardest to read, but it’s not that bad now that we’re more familiar with \u003c$\u003e and mapM.\nThe corresponding syntax is e1 for x in e2 so we know that e2 is the list where we should bind the variable name x to an element, for each iteration.\nWe evaluate e2 to v2. If v2 is not iterable, then it’s not possible to use it in a for-statement and we should throw an error. If it’s a list, then we want to bind each value in xs to x inside the rest of the comprehension, c2.\nRecall the following function types.\ncomprehension :: [Clause] -\u003e Boa [Value]\nbind :: VariableName -\u003e Value -\u003e (Boa a -\u003e Boa a)\nmapM :: (a -\u003e m b) -\u003e [a] -\u003e m ([b])\nWe want to do bind x v (comprehension c2), where v is each of the values from xs. We already have the variable name x and the comprehension c2, but bind needs a single value v, whereas xs is a list of values. Time for some mapM magic.\nSince xs has the type [Value], we can rewrite mapM as\nmapM :: (Value -\u003e Boa Value) -\u003e [Value] -\u003e Boa [Value]\nThen xs can be the second argument! In order for bind to be the first argument, we can write an anonymous function (\\v -\u003e bind x v (comprehension c2)) :: Value\r-\u003e Boa Value.\nNow mapM (\\v -\u003e bind x v (comprehension c2)) xs does exactly what we wanted it to do! Except that we’re mapping a function that returns a list, over a list, so the result is a Boa [[Value]]. To fix this, we can simply fmap the function concat over the result to turn it into a single, flat list and put it inside the Boa monad. And then, we’re all done with eval!\neval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] comprehension (For x e2 : c2) = do v2 \u003c- eval e2 case v2 of (List xs) -\u003e concat \u003c$\u003e mapM (\\v -\u003e bind x v (comprehension c2)) xs _ -\u003e abort $ BadArgument $ \"Argument \" ++ showValue v2 ++ \" is not iterable\" If eval and comprehension look completely crazy to you - especially if you’re wondering how we can use e1 inside of comprehension - I’d recommend reading about closures and mutually recursive functions. It’s really powerful stuff, but I was definitely confused the first time I saw it!\nPutting It All Together Now we have the following eval function.\neval :: Expression -\u003e Boa Value eval (Constant v) = return v eval (Variable x) = look x eval (Operation o e1 e2) = do v1 \u003c- eval e1 v2 \u003c- eval e2 case operate o v1 v2 of Right v -\u003e return v Left re -\u003e abort $ BadArgument re eval (Not e) = Boolean . not . truthy \u003c$\u003e eval e eval (Call f es) = mapM eval es \u003e\u003e= apply f eval (ListExpression es) = List \u003c$\u003e mapM eval es eval (ListComprehension e1 c1) = List \u003c$\u003e comprehension c1 where comprehension :: [Clause] -\u003e Boa [Value] comprehension [] = eval e1 \u003c\u0026\u003e return comprehension (For x e2 : c2) = do v2 \u003c- eval e2 case v2 of (List xs) -\u003e concat \u003c$\u003e mapM (\\v -\u003e bind x v (comprehension c2)) xs _ -\u003e abort $ BadArgument $ \"Argument \" ++ showValue v2 ++ \" is not iterable\" comprehension (If e2 : c2) = do b \u003c- truthy \u003c$\u003e eval e2 if b then comprehension c2 else return [] At this point, all we need is to write exec and execute!\nexec should just perform the computations in order and collect the output. It doesn’t need to keep track of which value was just computed, so the return type of exec is just Boa ().\nWe decided earlier that it should pattern match on Define and Execute statements. If it’s a definition, then we should evaluate the expression and bind the variable name to the result in the environment.\nexec :: Program -\u003e Boa () exec [] = return () exec ((Define x e) : s) = do v \u003c- eval e bind x v (exec s) exec ((Execute e) : s) = undefined If it’s an execution statement, then we should just evaluate the expression and keep executing the rest of the program.\nexec :: Program -\u003e Boa () exec [] = return () exec ((Define x e) : s) = do v \u003c- eval e bind x v (exec s) exec ((Execute e) : s) = eval e \u003e\u003e exec s And… That’s it! All our hard work when writing eval and its helper functions is finally paying off. This code it short, easy to read, and (relatively) easy to understand.\nThen execute is just the function that runs exec program in the empty environment.\nexecute :: Program -\u003e (Output, Maybe RuntimeError) execute p = case run (exec p) [] of (Right _, out) -\u003e (out, Nothing) (Left re, out) -\u003e (out, Just re) Then we’re all done! After writing a driver program (like Main.hs in the repo), you can install this boa executable by typing stack install in the directory. Now you can interpret Boa ASTs!\nContact I appreciate any feedback, comments, corrections, etc. you may have. If that’s the case, you can reach me via my GitHub or my email at sophie.bosio@outlook.com. Happy coding!\n",
  "wordCount" : "3815",
  "inLanguage": "en",
  "datePublished": "2023-09-14T10:24:00+02:00",
  "dateModified": "2023-09-14T10:24:00+02:00",
  "author":[{
    "@type": "Person",
    "name": "Sophie"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sophiebosio.github.io/posts/boa-interpreter-haskell/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sophiebosio.github.io/static/img/favicon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sophiebosio.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sophiebosio.github.io/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://sophiebosio.github.io/education" title="Education">
                    <span>Education</span>
                </a>
            </li>
            <li>
                <a href="https://sophiebosio.github.io/search/" title="Search">
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sophiebosio.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/SophieBosio" title="GitHub">
                    <span>GitHub</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://sophiebosio.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://sophiebosio.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Implementing a Small Interpreter in Haskell
    </h1>
    <div class="post-meta"><span title='2023-09-14 10:24:00 +0200 CEST'>September 14, 2023</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Sophie

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-boa-language" aria-label="The Boa Language">The Boa Language</a><ul>
                        
                <li>
                    <a href="#spoiler-alert-syntax-file" aria-label="Spoiler Alert! Syntax File">Spoiler Alert! Syntax File</a></li></ul>
                </li>
                <li>
                    <a href="#monad-implementation" aria-label="Monad Implementation">Monad Implementation</a><ul>
                        
                <li>
                    <a href="#the-boa-monad" aria-label="The Boa Monad">The Boa Monad</a></li>
                <li>
                    <a href="#monad-operations" aria-label="Monad Operations">Monad Operations</a></li></ul>
                </li>
                <li>
                    <a href="#interpreter-functions" aria-label="Interpreter Functions">Interpreter Functions</a><ul>
                        
                <li>
                    <a href="#constant" aria-label="Constant">Constant</a></li>
                <li>
                    <a href="#variable" aria-label="Variable">Variable</a></li>
                <li>
                    <a href="#not" aria-label="Not">Not</a></li>
                <li>
                    <a href="#operation" aria-label="Operation">Operation</a></li>
                <li>
                    <a href="#call" aria-label="Call">Call</a></li>
                <li>
                    <a href="#list-expression" aria-label="List Expression">List Expression</a></li>
                <li>
                    <a href="#list-comprehension" aria-label="List Comprehension">List Comprehension</a></li></ul>
                </li>
                <li>
                    <a href="#putting-it-all-together" aria-label="Putting It All Together">Putting It All Together</a></li>
                <li>
                    <a href="#contact" aria-label="Contact">Contact</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>One of my favourite assignments in my advanced functional programming course,
was implementing a parser and interpreter for a subset of Python, called Boa, in
Haskell.</p>
<p>We&rsquo;d just started getting a grasp of what monads are and how they work, and this
project is what really solidified it for me. Here&rsquo;s how we approached it and
some of my reflections when looking back at it.</p>
<p>I&rsquo;ll be focusing on the interpreter, because we implemented the monad for the
interpreter by hand, and I feel it&rsquo;s easier to see how monads work when seeing
the implementation. The parser, on the other hand, uses the monad combinator
library Parsec, which is both more complicated and more well-documented elsewhere.</p>
<p>I&rsquo;ll assume you&rsquo;re familiar with monads and their operations, but this is also a
great project to try your hand at if you&rsquo;re still getting the hang of using them.</p>
<p>The code is available in its entirety on my <a href="https://github.com/SophieBosio/boa">GitHub</a>, and I would encourage you to
follow along!</p>
<h2 id="the-boa-language">The Boa Language<a hidden class="anchor" aria-hidden="true" href="#the-boa-language">#</a></h2>
<p>The Boa language is a small subset of Python. It looks pretty familiar to anyone
who has programmed in Python before, and if you&rsquo;re interested in a more thorough
explanation of the language, you can check out the <code>./docs</code> folder in the repo.</p>
<p>The most important aspects of the language, for our interpreter, is that it has
global state. In our purely functional implementation language, computations are
normally <em>not</em> stateful. So, we have to make use of a monad to model the program
environment and interpret terms with respect to the existing bindings.</p>
<p>Thankfully, Boa computations can make do with read-only access to the
environment. Therefore, we can use a neat and (as far as monads go) pretty
intuitive monad, namely the <a href="https://hackage.haskell.org/package/mtl-2.3.1/docs/Control-Monad-Reader.html">Reader monad</a>. We&rsquo;ll implement it ourselves, but you
could also just import the above package in your project.</p>
<h3 id="spoiler-alert-syntax-file">Spoiler Alert! Syntax File<a hidden class="anchor" aria-hidden="true" href="#spoiler-alert-syntax-file">#</a></h3>
<p>Below, you can find the finished <code>Syntax.hs</code> file. If you want to implement the
language yourself, you might want to try your hand at writing this file, too,
before seeing this suggestion.</p>
<details>
<summary><code>Syntax.hs</code></summary>
<div class="details">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">module</span> <span class="nn">Syntax</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Value</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">None</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Boolean</span> <span class="kt">Bool</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Number</span>  <span class="kt">Integer</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Text</span>    <span class="kt">String</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">List</span>    <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Expression</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Constant</span>  <span class="kt">Value</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Variable</span>  <span class="kt">VariableName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Operation</span> <span class="kt">OperationSymbol</span> <span class="kt">Expression</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Not</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Call</span> <span class="kt">FunctionName</span> <span class="kt">FunctionInput</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">ListExpression</span>    <span class="p">[</span><span class="kt">Expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">ListComprehension</span> <span class="kt">Expression</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">VariableName</span>      <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionName</span>      <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionInput</span>     <span class="ow">=</span> <span class="p">[</span><span class="kt">Expression</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">FunctionArguments</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">OperationSymbol</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Plus</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Minus</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Times</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Div</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Mod</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Eq</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Less</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Greater</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">In</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Clause</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">For</span> <span class="kt">VariableName</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">If</span>               <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Program</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Statement</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">Statement</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Define</span>  <span class="kt">VariableName</span> <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">Execute</span>              <span class="kt">Expression</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</span></span></code></pre></div></div>
</details>
<h2 id="monad-implementation">Monad Implementation<a hidden class="anchor" aria-hidden="true" href="#monad-implementation">#</a></h2>
<p>Executing a Boa program means evaluating all the program statements, starting
from the empty environment and populating it as we go. If we encounter any
runtime errors underway, we&rsquo;ll stop execution and print an error message. If all
is well, we&rsquo;ll continue until there are no more statements, and then print the output of the program.</p>
<p>Let&rsquo;s use the following abbreviations.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Output</span>      <span class="ow">=</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">ErrorMessage</span> <span class="ow">=</span> <span class="kt">String</span>
</span></span><span class="line"><span class="cl"><span class="kr">data</span> <span class="kt">RuntimeError</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">    <span class="kt">UnboundVariable</span> <span class="kt">VariableName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">BadFunction</span>     <span class="kt">FunctionName</span>
</span></span><span class="line"><span class="cl">  <span class="o">|</span> <span class="kt">BadArgument</span>     <span class="kt">ErrorMessage</span>
</span></span><span class="line"><span class="cl">  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Environment</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">VariableName</span><span class="p">,</span> <span class="kt">Value</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="kt">Runtime</span> <span class="n">a</span>   <span class="ow">=</span> <span class="kt">Environment</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">RuntimeError</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span>
</span></span></code></pre></div><p>An environment is a mapping from variable names to values. What we want is a
monad that allows us to keep track of the variable bindings in the environment.
When we want to perform a computation, we need a runtime where we can read from
the environment and either raise a runtime error or return a value, and append
the output from the computation so we can print it later.
This is essentially what we would want to use the Reader monad for! Let&rsquo;s
implement a simple version.</p>
<h3 id="the-boa-monad">The Boa Monad<a hidden class="anchor" aria-hidden="true" href="#the-boa-monad">#</a></h3>
<p>Every monad is an applicative functor and every applicative functor is a
functor. Those are interesting to read about in their own right, but for now, we
just need to know that if we implement the monad correctly, we get these two for
free. For these freebies, we need to import <code>Control.Monad</code>. We&rsquo;ll also need a
newtype <code>Boa a</code>, whose &ldquo;run&rdquo; action will have the type <code>Runtime a</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">newtype</span> <span class="kt">Boa</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">{</span><span class="n">run</span> <span class="ow">::</span> <span class="kt">Runtime</span> <span class="n">a</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">fmap</span> <span class="ow">=</span> <span class="n">liftM</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">instace</span> <span class="kt">Applicative</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">pure</span>  <span class="ow">=</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">ap</span>
</span></span></code></pre></div><p>Nice! Now, we need to define two functions for our monad, namely
<code>return</code> and <code>&gt;&gt;=</code>, and we have a fully fledged monad instance!</p>
<p>For a quick refresher, let&rsquo;s look at their type signatures.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">return</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></span></code></pre></div><p>In the case of <code>return</code>, we just want to take a value and put it inside the monad.
What&rsquo;s the simplest way we can do that? Well, our monad lets us read from the
environment and we&rsquo;re supposed to
return either an error message or a value <code>a</code>, and then the output we want to
print after the computation is done. The simplest way, then, is to not read
anything from the environment, just put in the value, and not add anything to the
output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">ba</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Essentially, this says &ldquo;I don&rsquo;t care about the environment, just give me the
tuple with <code>a</code> and no output in it, then put it all inside the Boa monad for me&rdquo;.
The following notation is semantically equivalent, but the syntax may be easier
to read depending on what you&rsquo;re used to.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">))</span>
</span></span></code></pre></div><p>Then what do we want to do for <code>&gt;&gt;=</code>, is define a way to take a value out of the monad,
apply a function to it, and then put the result back into the monad. To unwrap
the value <code>a</code> from <code>ba</code>, we can simply use our monad&rsquo;s <code>run</code> function. We have to take
in an environment so that we can run the
monad in the environment and look at  the result. If it&rsquo;s an error, then we just
return the error. But if we get a value <code>a</code> out and some output, then we want to run
the function <code>f</code> on <code>a</code>. What we&rsquo;re gonna return, is the result of <code>f a</code> and the
output of that computation appended to all the previous output. Finally, we put
it all back into the Boa monad.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Boa</span> <span class="kr">where</span>
</span></span><span class="line"><span class="cl">  <span class="n">return</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">ba</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kr">case</span> <span class="n">run</span> <span class="n">ba</span> <span class="n">env</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>      <span class="c1">-- just return the error</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="kr">let</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">out&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">run</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="n">env</span>  <span class="c1">-- run f a in the environment</span>
</span></span><span class="line"><span class="cl">        <span class="kr">in</span>  <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">out</span> <span class="o">++</span> <span class="n">out&#39;</span><span class="p">)</span>           <span class="c1">-- append the new output to the old</span>
</span></span></code></pre></div><p>Sweet! Now let&rsquo;s define some operations that let us interact with the monad in a
more ergonomic way.</p>
<h3 id="monad-operations">Monad Operations<a hidden class="anchor" aria-hidden="true" href="#monad-operations">#</a></h3>
<p>Now we have the monad itself, but it&rsquo;s nice to abstract away some details and
instead work with more intuitive function names. Let&rsquo;s write some functions with
more easily understood names.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">abort</span>  <span class="ow">::</span> <span class="kt">RuntimeError</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">look</span>   <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span>   <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Boa</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">output</span> <span class="ow">::</span> <span class="kt">String</span>       <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span></code></pre></div><p><code>abort</code> should just accept a runtime error and put it into the Boa monad.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">abort</span> <span class="ow">::</span> <span class="kt">RuntimeError</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl"><span class="nf">abort</span> <span class="n">re</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- or equivalently,</span>
</span></span><span class="line"><span class="cl"><span class="nf">abort</span> <span class="n">re</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="kt">[]</span><span class="p">))</span>
</span></span></code></pre></div><p><code>look</code> should accept a variable name and look to see if it is in the environment.
if it is, return the value inside the monad. If it isn&rsquo;t, return an &ldquo;unbound
variable&rdquo; runtime error inside the monad. In either case, no output is
necessary.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">look</span> <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">look</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">lookup</span> <span class="n">x</span> <span class="n">env</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Just</span> <span class="n">a</span>  <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Left</span> <span class="p">(</span><span class="kt">UnboundVariable</span> <span class="n">x</span><span class="p">),</span> <span class="kt">[]</span><span class="p">)</span>
</span></span></code></pre></div><p><code>bind</code> takes a variable name and a value.  What it should do, is run the monad
with that name-value binding <em>prepended</em> to the old environment, and then put the
value of that computation back into the monad. It needs to be
prepended and not appended because when we perform a lookup, we want to find the
most recent bindings first.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">bind</span> <span class="ow">::</span> <span class="kt">VariableName</span> <span class="ow">-&gt;</span> <span class="kt">Value</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Boa</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="n">ba</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span> <span class="n">run</span> <span class="n">ba</span> <span class="o">$</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="kt">:</span> <span class="n">env</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- or equivalently,</span>
</span></span><span class="line"><span class="cl"><span class="nf">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="n">ba</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="p">(</span><span class="nf">\</span><span class="n">env</span> <span class="ow">-&gt;</span> <span class="n">run</span> <span class="n">ba</span> <span class="p">(</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="o">++</span> <span class="n">env</span> <span class="p">))</span>
</span></span></code></pre></div><p><code>output</code> should take an string and put it into the monad as output.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">output</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">output</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">Boa</span> <span class="o">$</span> <span class="n">const</span> <span class="p">(</span><span class="kt">Right</span> <span class="nb">()</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
</span></span></code></pre></div><h2 id="interpreter-functions">Interpreter Functions<a hidden class="anchor" aria-hidden="true" href="#interpreter-functions">#</a></h2>
<p>Finally, we need the main operations of the interpreter. To execute a Boa
program, we want to take a program and return a tuple with the output of the
program and possibly a runtime error.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">execute</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Output</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">Runtime</span> <span class="kt">Error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">execute</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>Since a <code>Program</code> is made up of <code>Define</code> and <code>Execute</code> statements, we can write a
helper function <code>exec</code> that pattern matches on the type of statement.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>And finally, we&rsquo;ll need a helper function <code>eval</code> that&rsquo;s responsible for evaluating
a single expression and putting the resulting value into the Boa monad for us.
This is what we&rsquo;ll focus on for now.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expression</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span></code></pre></div><p>Since they&rsquo;re not the most interesting part of the interpreter, I&rsquo;m omitting quite a few other helper functions, notably <code>operate :: OperationSymbol -&gt; Value -&gt; Value -&gt; Either ErrorMessage Value</code> and <code>apply :: FunctionName -&gt; FunctionArguments -&gt; Boa Value</code>. They&rsquo;re of course in the repo,
and I&rsquo;d encourage you to try implementing them yourself.</p>
<p><code>eval</code> needs to pattern match on each expression. There are the following types of
<code>Expression</code>:</p>
<ul>
<li><code>Constant</code></li>
<li><code>Variable VariableName</code></li>
<li><code>Not Expression</code></li>
<li><code>Operation OperationSymbol Expression Expression</code></li>
<li><code>Call FunctionName FunctionInput</code></li>
<li><code>ListExpression [Expression]</code></li>
<li><code>ListComprehension Expression [Clause]</code></li>
</ul>
<h3 id="constant">Constant<a hidden class="anchor" aria-hidden="true" href="#constant">#</a></h3>
<p>Let&rsquo;s start with <code>Constant</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Constant</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">v</span>
</span></span></code></pre></div><p>It&rsquo;s already a value, so we can just take it and put it directly in the
monad. Easy!</p>
<h3 id="variable">Variable<a hidden class="anchor" aria-hidden="true" href="#variable">#</a></h3>
<p>What about a variable? Well, either it&rsquo;s bound in the environment or it&rsquo;s not
and should return an error. <code>look</code> seems like a perfect fit for the job. It even
returns an error message for us if <code>x</code> is not present in the environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">look</span> <span class="n">x</span>
</span></span></code></pre></div><h3 id="not">Not<a hidden class="anchor" aria-hidden="true" href="#not">#</a></h3>
<p>If we meet a <code>Not</code> expression, we should evaluate the sub-expression to a Boolean
value, then take the opposite value, cast it as a <code>Boolean</code> and put it in the Boa
monad. Actually, we can do all of this by <code>fmap</code>-ing <code>(Boolean . not . truthy)</code> onto
the evaluated expression. That unwraps the expression, applies the three
functions above, and then wraps it back up in the monad.</p>
<p>Note that <code>&lt;$&gt;</code> is just an infix version of <code>fmap</code>, and <code>truthy</code> is a helper function that evaluates a <code>Value</code> to a Boolean value.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Boolean</span> <span class="o">.</span> <span class="n">not</span> <span class="o">.</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e</span>
</span></span></code></pre></div><h3 id="operation">Operation<a hidden class="anchor" aria-hidden="true" href="#operation">#</a></h3>
<p>An <code>Operation</code> is performed by evaluating each of its arguments,
extracting the <code>Value</code> from each, using <code>operate</code> on them to get the result <code>Value</code>,
and wrapping that result back in the monad. In this case, <code>do</code>-notation makes our code much more readable.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Operation</span> <span class="n">o</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v1</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e1</span>
</span></span><span class="line"><span class="cl">     <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">     <span class="kr">case</span> <span class="n">operate</span> <span class="n">o</span> <span class="n">v1</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Right</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Left</span> <span class="n">re</span> <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="n">re</span>
</span></span></code></pre></div><h3 id="call">Call<a hidden class="anchor" aria-hidden="true" href="#call">#</a></h3>
<p>Recall that <code>Call</code> takes a function name <code>f</code> and a list of expressions <code>es</code>, which is the
function input. What we want to do, is to evaluate all the function arguments,
and then send all those values to our helper function <code>apply</code>, which will apply <code>f</code>
to the evaluated <code>es</code> and put the result into the Boa monad.</p>
<p>With the help of <code>mapM</code>, we can write the function for <code>Call</code> expressions very
succinctly. Its type signature is</p>
<p><code>mapM :: (Traversable t, Monad m) ==&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</code>.</p>
<p>In our case, the traversable structure is a list and the
monad is the Boa monad. In our case, we can rewrite it as</p>
<p><code>mapM :: (Expression -&gt; Boa Value) -&gt; [Expression] -&gt; Boa ([Value])</code>.</p>
<p><code>eval</code>, of course has the type <code>Expression -&gt; Boa Value</code> and the function input has type <code>[Expression].</code></p>
<p>Great! So if we do <code>mapM eval es</code>, we&rsquo;ll get a <code>Boa [Value]</code>, where each <code>Value</code> is an
evaluated function argument. Then we just want to take this list of values out
of the monad and send it to the <code>apply f</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Call</span> <span class="n">f</span> <span class="n">es</span><span class="p">)</span> <span class="ow">=</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">f</span>
</span></span></code></pre></div><h3 id="list-expression">List Expression<a hidden class="anchor" aria-hidden="true" href="#list-expression">#</a></h3>
<p>We can do something similar for <code>ListExpression</code>, except this case is much easier!
We want to evaluate all the expressions, as above, but then all we need is to
put the results in a <code>List</code> and wrap it in the monad. Then we can just <code>fmap</code> <code>List</code>
onto the evaluated expressions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListExpression</span> <span class="n">es</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span>
</span></span></code></pre></div><h3 id="list-comprehension">List Comprehension<a hidden class="anchor" aria-hidden="true" href="#list-comprehension">#</a></h3>
<p>Now, the <code>ListComprehension</code> is probably the trickiest case to write. Once way is to write
two mutually recursive functions, the <code>eval</code> case for <code>ListComprehension</code> and a
helper function <code>comprehension</code>.</p>
<p>The <code>eval</code> case for list comprehension, does more or less the same as the
<code>ListExpression</code> does: It takes the result of evaluating the contents, and puts
the resulting <code>List</code> into the Boa monad. Then, <code>comprehension</code> is the function that
actually computes the result.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p><code>comprehension</code> takes in a list of clauses, and a <code>Clause</code> is either an if-statement
on the form <code>If Expression</code> or a for-statement
on the form <code>For VariableName Expression=</code>.</p>
<p>Therefore, <code>comprehension</code> pattern matches on three cases: The empty list, a
for-statement and more clauses, or an if-statement and more clauses.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span>    <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>In the case of the empty list, we have a list comprehension that is really just
a list expression, on the form <code>ListComprehension Expression []</code>. So in that case,
<code>comprehension</code> can just evaluate <code>e1</code> and return the list containing that one
value, inside the <code>Boa</code> monad.</p>
<p>Once again, there&rsquo;s a very handy function we can use, to write this code in a single, short
line, namely <code>&lt;&amp;&gt;</code>. It&rsquo;s implemented as <code>flip fmap</code> and has the type signature</p>
<p><code>(&lt;&amp;&gt;) :: Functor f ==&gt; f a -&gt; (a -&gt; b) -&gt; f b.</code></p>
<p>In our case, we&rsquo;re applying it like this,</p>
<p><code>(&lt;&amp;&gt;) :: Boa Value -&gt; (Value -&gt; [Value]) -&gt; Boa [Value]</code>.</p>
<p>The <code>return</code> we&rsquo;re using here is the <code>return</code> of the list monad. Basically, we&rsquo;re
saying &ldquo;evaluate <code>e1</code>, which gives us a <code>Boa Value</code>. Then, take that value out of
the <code>Boa</code> monad, put it into the list monad with <code>return</code>, and finally put that list
with the value back in the <code>Boa</code> monad&rdquo;.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span>    <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><blockquote>
<p>Recall that the result of evaluating a list comprehension should be on the form
<code>Boa (List [Value])</code>, which (because <code>List [Value]</code> is itself a <code>Value</code>) is just a <code>Boa Value</code>. When we return from <code>comprehension</code> to <code>eval</code>, we can <code>fmap</code> the constructor <code>List</code> onto
the <code>Boa [Value]</code>, which accomplishes exactly this: It turns the result <code>Boa [Value]</code> into
<code>Boa (List [Value])</code>.</p>
</blockquote>
<p>When we encounter an <code>If</code>-expression, the syntax corresponds to <code>e1 if e2</code> . So we
know that the expression <code>e2</code> should be a Boolean value. Luckily, in Boa as in
Python, non-Boolean values correspond to a Boolean value. E.g., <code>1==True</code> is true
and <code>0==True</code> is false.The first thing we can do, then, is to evaluate <code>e2</code> and find
the corresponding Boolean value with <code>truthy</code>.</p>
<p>By <code>fmap</code>-ing <code>truthy</code> onto the evaluated expression, we get a <code>Boa Bool</code>, i.e., a
normal Haskell Boolean inside the Boa monad. By using <code>do</code>-notation, then, we can
give <code>b</code> the unwrapped Boolean and we can use it directly in an if-statement. If the condition <code>b</code> holds,
then evaluate the rest of the list comprehension. Else, there&rsquo;s no more to evaluate.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>The case for <code>For</code> statements is probably the hardest to read, but it&rsquo;s not that
bad now that we&rsquo;re more familiar with <code>&lt;$&gt;</code> and <code>mapM</code>.</p>
<p>The corresponding syntax is <code>e1 for x in e2</code> so we know that <code>e2</code> is the list where
we should bind the variable name <code>x</code> to an element, for each iteration.</p>
<p>We evaluate <code>e2</code> to <code>v2</code>. If <code>v2</code> is not iterable, then it&rsquo;s
not possible to use it in a for-statement and we should throw an error. If it&rsquo;s
a list, then we want to
bind each value in <code>xs</code> to <code>x</code> inside the rest of the comprehension, <code>c2</code>.</p>
<p>Recall the following function types.</p>
<p><code>comprehension :: [Clause] -&gt; Boa [Value]</code></p>
<p><code>bind :: VariableName -&gt; Value -&gt; (Boa a -&gt; Boa a)</code></p>
<p><code>mapM :: (a -&gt; m b) -&gt; [a] -&gt; m ([b])</code></p>
<p>We want to do <code>bind x v (comprehension c2)</code>, where <code>v</code> is each of the values from <code>xs</code>. We
already have the variable name <code>x</code> and the comprehension <code>c2</code>, but <code>bind</code> needs a
single value <code>v</code>, whereas <code>xs</code> is a <em>list</em> of values. Time for some <code>mapM</code> magic.</p>
<p>Since <code>xs</code> has the type <code>[Value]</code>, we can rewrite <code>mapM</code> as</p>
<p><code>mapM :: (Value -&gt; Boa Value) -&gt; [Value] -&gt; Boa [Value]</code></p>
<p>Then <code>xs</code> can be the second argument! In order for <code>bind</code> to be the first argument,
we can write an anonymous function <code>(\v -&gt; bind x v (comprehension c2)) :: Value -&gt; Boa Value</code>.</p>
<p>Now <code>mapM (\v -&gt; bind x v (comprehension c2)) xs</code> does exactly what we wanted it
to do! Except that we&rsquo;re mapping a function that returns a list, over a list,
so the result is a <code>Boa [[Value]]</code>. To fix this, we can simply <code>fmap</code> the function
<code>concat</code> over the result to turn it into a single, flat list and put it inside
the Boa monad. And <strong>then</strong>, we&rsquo;re all done with <code>eval</code>!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">case</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="kt">List</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="p">(</span><span class="nf">\</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">comprehension</span> <span class="n">c2</span><span class="p">))</span> <span class="n">xs</span>
</span></span><span class="line"><span class="cl">           <span class="kr">_</span>         <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="o">$</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Argument &#34;</span> <span class="o">++</span> <span class="n">showValue</span> <span class="n">v2</span> <span class="o">++</span> <span class="s">&#34; is not iterable&#34;</span>
</span></span></code></pre></div><blockquote>
<p>If <code>eval</code> and <code>comprehension</code> look completely crazy to you - especially if you&rsquo;re
wondering how we can use <code>e1</code> inside of <code>comprehension</code> - I&rsquo;d recommend reading
about <em>closures</em> and <em>mutually recursive</em> functions. It&rsquo;s really powerful stuff, but
I was definitely confused the first time I saw it!</p>
</blockquote>
<h2 id="putting-it-all-together">Putting It All Together<a hidden class="anchor" aria-hidden="true" href="#putting-it-all-together">#</a></h2>
<p>Now we have the following <code>eval</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">Expression</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="kt">Value</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Constant</span> <span class="n">v</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Variable</span> <span class="n">x</span><span class="p">)</span>              <span class="ow">=</span> <span class="n">look</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Operation</span> <span class="n">o</span> <span class="n">e1</span> <span class="n">e2</span><span class="p">)</span>       <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v1</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e1</span>
</span></span><span class="line"><span class="cl">     <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">     <span class="kr">case</span> <span class="n">operate</span> <span class="n">o</span> <span class="n">v1</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Right</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">v</span>
</span></span><span class="line"><span class="cl">       <span class="kt">Left</span> <span class="n">re</span> <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="n">re</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Not</span> <span class="n">e</span><span class="p">)</span>                   <span class="ow">=</span> <span class="kt">Boolean</span> <span class="o">.</span> <span class="n">not</span> <span class="o">.</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">Call</span> <span class="n">f</span> <span class="n">es</span><span class="p">)</span>               <span class="ow">=</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span> <span class="o">&gt;&gt;=</span> <span class="n">apply</span> <span class="n">f</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListExpression</span> <span class="n">es</span><span class="p">)</span>       <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="n">eval</span> <span class="n">es</span>
</span></span><span class="line"><span class="cl"><span class="nf">eval</span> <span class="p">(</span><span class="kt">ListComprehension</span> <span class="n">e1</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">List</span> <span class="o">&lt;$&gt;</span> <span class="n">comprehension</span> <span class="n">c1</span>
</span></span><span class="line"><span class="cl">  <span class="kr">where</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Clause</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="p">[</span><span class="kt">Value</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="kt">[]</span>              <span class="ow">=</span> <span class="n">eval</span> <span class="n">e1</span> <span class="o">&lt;&amp;&gt;</span> <span class="n">return</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">For</span> <span class="n">x</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">v2</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">case</span> <span class="n">v2</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">           <span class="p">(</span><span class="kt">List</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">concat</span> <span class="o">&lt;$&gt;</span> <span class="n">mapM</span> <span class="p">(</span><span class="nf">\</span><span class="n">v</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">comprehension</span> <span class="n">c2</span><span class="p">))</span> <span class="n">xs</span>
</span></span><span class="line"><span class="cl">           <span class="kr">_</span>         <span class="ow">-&gt;</span> <span class="n">abort</span> <span class="o">$</span> <span class="kt">BadArgument</span> <span class="o">$</span>
</span></span><span class="line"><span class="cl">                        <span class="s">&#34;Argument &#34;</span> <span class="o">++</span> <span class="n">showValue</span> <span class="n">v2</span> <span class="o">++</span> <span class="s">&#34; is not iterable&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">comprehension</span> <span class="p">(</span><span class="kt">If</span> <span class="n">e2</span> <span class="kt">:</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">      <span class="kr">do</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">truthy</span> <span class="o">&lt;$&gt;</span> <span class="n">eval</span> <span class="n">e2</span>
</span></span><span class="line"><span class="cl">         <span class="kr">if</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">           <span class="kr">then</span> <span class="n">comprehension</span> <span class="n">c2</span>
</span></span><span class="line"><span class="cl">           <span class="kr">else</span> <span class="n">return</span> <span class="kt">[]</span>
</span></span></code></pre></div><p>At this point, all we need is to write <code>exec</code> and <code>execute</code>!</p>
<p><code>exec</code> should just perform the computations in order and collect the output. It
doesn&rsquo;t need to keep track of which value was just computed, so the return type
of <code>exec</code> is just <code>Boa ()</code>.</p>
<p>We decided earlier that it should pattern match on
<code>Define</code> and <code>Execute</code> statements. If it&rsquo;s a definition, then we should evaluate the
expression and bind the variable name to the result in the environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl">     <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">exec</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">undefined</span>
</span></span></code></pre></div><p>If it&rsquo;s an execution statement, then we should just evaluate the expression and
keep executing the rest of the program.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">exec</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="kt">Boa</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="kt">[]</span>                 <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Define</span> <span class="n">x</span> <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">do</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">eval</span> <span class="n">e</span>
</span></span><span class="line"><span class="cl">     <span class="n">bind</span> <span class="n">x</span> <span class="n">v</span> <span class="p">(</span><span class="n">exec</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">exec</span> <span class="p">((</span><span class="kt">Execute</span>  <span class="n">e</span><span class="p">)</span> <span class="kt">:</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">eval</span> <span class="n">e</span> <span class="o">&gt;&gt;</span> <span class="n">exec</span> <span class="n">s</span>
</span></span></code></pre></div><p>And&hellip; That&rsquo;s it! All our hard work when writing <code>eval</code> and its helper functions
is finally paying off. This code it short, easy to read, and (relatively) easy
to understand.</p>
<p>Then <code>execute</code> is just the function that runs <code>exec program</code> in the empty
environment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-haskell" data-lang="haskell"><span class="line"><span class="cl"><span class="nf">execute</span> <span class="ow">::</span> <span class="kt">Program</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Output</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">RuntimeError</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nf">execute</span> <span class="n">p</span> <span class="ow">=</span>
</span></span><span class="line"><span class="cl">  <span class="kr">case</span> <span class="n">run</span> <span class="p">(</span><span class="n">exec</span> <span class="n">p</span><span class="p">)</span> <span class="kt">[]</span> <span class="kr">of</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Right</span> <span class="kr">_</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">(</span><span class="kt">Left</span> <span class="n">re</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="kt">Just</span> <span class="n">re</span><span class="p">)</span>
</span></span></code></pre></div><p>Then we&rsquo;re all done! After writing a driver program (like <code>Main.hs</code> in the repo),
you can install this <code>boa</code> executable by typing <code>stack install</code> in the directory.
Now you can interpret Boa ASTs!</p>
<h2 id="contact">Contact<a hidden class="anchor" aria-hidden="true" href="#contact">#</a></h2>
<p>I appreciate any feedback, comments, corrections, etc. you may have. If that&rsquo;s
the case, you can reach me via my
<a href="https://github.com/SophieBosio">GitHub</a> or my email at <a href="mailto:sophie.bosio@outlook.com">sophie.bosio@outlook.com</a>. Happy coding!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sophiebosio.github.io/tags/functional/">functional</a></li>
      <li><a href="https://sophiebosio.github.io/tags/programming/">programming</a></li>
      <li><a href="https://sophiebosio.github.io/tags/haskell/">haskell</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://sophiebosio.github.io/posts/beautifying-emacs-org-mode/">
    <span class="title">Next »</span>
    <br>
    <span>Beautifying Emacs Org Mode</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on twitter"
        href="https://twitter.com/intent/tweet/?text=Implementing%20a%20Small%20Interpreter%20in%20Haskell&amp;url=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f&amp;hashtags=functional%2cprogramming%2chaskell">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f&amp;title=Implementing%20a%20Small%20Interpreter%20in%20Haskell&amp;summary=Implementing%20a%20Small%20Interpreter%20in%20Haskell&amp;source=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f&title=Implementing%20a%20Small%20Interpreter%20in%20Haskell">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on whatsapp"
        href="https://api.whatsapp.com/send?text=Implementing%20a%20Small%20Interpreter%20in%20Haskell%20-%20https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on telegram"
        href="https://telegram.me/share/url?text=Implementing%20a%20Small%20Interpreter%20in%20Haskell&amp;url=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Implementing a Small Interpreter in Haskell on ycombinator"
        href="https://news.ycombinator.com/submitlink?t=Implementing%20a%20Small%20Interpreter%20in%20Haskell&u=https%3a%2f%2fsophiebosio.github.io%2fposts%2fboa-interpreter-haskell%2f">
        <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
            xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
            <path
                d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sophiebosio.github.io/">PaperMod</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
