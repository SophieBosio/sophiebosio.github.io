#+hugo_base_dir: ../
#+title:Blog Posts

* TODO Fibonacci in Haskell :blog:@tech:
:PROPERTIES:
:EXPORT_FILE_NAME: hugo
:END:
The Fibonacci sequence is one of - if not /the/ - most famous sequences in
mathematics. In my first course in functional programming, we learnt recursion
by writing a function to enumerate the Fibonacci numbers. It looked a little
something like this:

#+begin_src haskell
fib :: Integer -> Integer
fib 1 = 1
fib 2 = 1
fib n = fib (n - 1) + fib (n - 2)
#+end_src

However, in my courses in algorithms and programming, I learnt that this isn't
really a particularly fast implementation. Try this for yourself, by using the
above function to enumerate the sequence:

#+begin_src shell
ghci> map fib [1..]
#+end_src

And as I got to know people who were more advanced functional programmers, I
also learnt some neat new tricks. Let's look at a few different implementations
for Fibonacci numbers.

* DONE Static Site Generation with Hugo                          :blog:@tech:
CLOSED: [2023-06-08 Thu 12:18]
:PROPERTIES:
:EXPORT_FILE_NAME: hugo
:END:
This website is built with [[https://gohugo.io/][Hugo]] and [[https://ox-hugo.scripter.co/][=ox-hugo=]], an exporting engine that lets me
write my posts in [[https://orgmode.org/][Org mode]] and then put it online easily.

Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using =ox-hugo= to write our blogs
(besides staying in the comfort of a well-known format and editing flow).

For example, I can use this code snippet as a template to create a new blog post
and bind it to a key combination in my Emacs configuration:

#+begin_src emacs-lisp
;; Populates only the EXPORT_FILE_NAME property in the inserted heading.
(with-eval-after-load 'org-capture
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
    (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("h"                ;`org-capture' binding + h
                 "Hugo post"
                 entry
                 ;; It is assumed that below file is present in `org-directory'
                 ;; and that it has a "Blog Ideas" heading. It can even be a
                 ;; symlink pointing to the actual location of all-posts.org!
                 (file+olp "all-posts.org" "Blog Ideas")
                 (function org-hugo-new-subtree-post-capture-template))))
#+end_src

* TODO Monads in Haskell                                         :blog:@tech:
:PROPERTIES:
:EXPORT_FILE_NAME: monads-haskell
:END:
*Please note:* This is a test "post" to see how different formatting in
Org+Hugo works, it's not a proper or finished post :~)

Monads are a special kind of mathematical structure that make our lives as
functional programmers much easier. They allow us to do /stateful/ computations
in a /functional/ way.

You're bound to have seen a monad if you've ever used Haskell, since the main
function usually has the signature =IO ()=. And so does every other function
you'll use that just prints or reads something to/from the console.

But what exactly is a monad? That question has been posed to Google by many
a beginner to functional programming. Usually, the results will include the
formal definition: "A monoid in the category of endofunctors." Which doesn't
really help the average person much.

Personally, I had the most luck starting with /how/ to use monads in functional
programming, and as I got better at using them, I would re-read the definitions
and slowly feel like I started to understand them.

To have a something to re-read and hopefully understand later, let's look at some definitions and introduce some terminology:

#+begin_center
Every *monad* is an *applicative functor*, and every applicative functor is a
normal *functor*.
#+end_center

Let's start at the lowest level, *functors*, and work our way up.

** Functors

To understand functors, it's useful to have a look at a simple function in Haskell. How about
addition?

The built-in function is the infix =+= operator, but to be clear, let's define
our own =add= function:

#+begin_src haskell
add :: Num a => a -> a -> a
add x y = x + y
#+end_src

Now I think we're ready to look at our first functor, =Maybe=. If you've worked with
Haskell before, you might already be familiar with how it works.

Essentially, it allows you to return =Nothing= for a computation that for some
reason has no return, and otherwise wrap a real result in =Just=. This is
really useful if we want to deal with functions that /may/ fail. In that case,
we can return =Nothing= when it fails and =Just result= if it succeeds.

=Maybe= is a /type constructor/, meaning it's not a type in and of itself, but
you can pass it a real, concrete type to construct a new type. If we try to
check the type of =Maybe=, we therefore get an error:

#+begin_src haskell
ghci> :t Maybe

<interactive>:1:1: error:
    * Illegal term-level use of the type constructor `Maybe'
        imported from `Prelude' (and originally defined in `GHC.Maybe')
    * In the expression: Maybe
#+end_src

On the other hand, we can check its /kind/:

#+begin_src haskell
ghci> :k Maybe
Maybe :: * -> *
#+end_src

This indicates how we can use it. It takes exactly one concrete type, like
=String= or =Int=, and returns a concrete type, like =Maybe String= or =Maybe
Int=.

An instance of the type =Maybe Int= could be for example =Just 3= or =Nothing=.
Notice that in =Just 3=, the normal integer =3= is "wrapped" inside of the
=Just=. What this means, is that we can't use =Just 3= exactly like we would
use =3=.

Let's define our =add= function and try to use it on normal ints, and then on
some =Maybe= ints.

#+begin_src haskell
ghci> add x y = x + y
ghci> add 3 5
8
ghci> add 5 (Just 3)

<interactive>:5:1: error:
    * No instance for (Num (Maybe Integer)) arising from a use of `it'
    * In the first argument of `print', namely `it'
      In a stmt of an interactive GHCi command: print it
#+end_src

To use a value that has been wrapped, or "lifted", by a functor, we need to use
a special function called =fmap=. This is how the Functor typeclass is defined
in Haskell:

#+begin_src haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b
#+end_src

Basically, it says "give me a normal function and a wrapped value, and I'll
unwrap the value, apply the function, and wrap up the result again".

What should happen with our =Maybe Int= then, is that we can give it a normal
function (like =add 5=) and a wrapped value (like =Just 3=) and it should
perform the computation as we would expect (=add 5 3=) and wrap up the result
for us (=Just 8=).

#+begin_comment
Note that =add 5= is a /partially applied function/. Since =add= takes two arguments,
giving it only one argument, like =add 5=, results in a partially applied
function that has "already gotten one of its arguments". In other words, =add 5= is a function that accepts one number and
adds 5 to it.
#+end_comment

#+begin_src haskell
ghci> fmap (add 5) (Just 3)
Just 8
#+end_src

Wow, great! Now we know how to apply a function to a wrapped value.

Now that we have seen =fmap= in action, I think we're ready to see how the =Maybe=-instance of =Functor= is defined:

#+begin_src haskell
instance Functor Maybe where
	fmap f Nothing  = Nothing
	fmap f (Just x) = Just (f x)
#+end_src

This means that if we try to apply the normal function =f= to =Nothing=, then
the result is always just =Nothing=. I.e., if we try to add =5= to =Nothing=, we
actually get =Nothing= back. That's because =Nothing= is not equivalent to 0, but rather
to some computation having failed earlier. For example, if we tried to divide
by zero earlier and got =Nothing= as a result, it doesn't really make sense to
add 5 to it and expect an actual result.

But if we try to apply the normal function =f= to =Just x= where =f= is defined
for the type of =x=, then we should apply =f= to =x= and wrap up the result in
a =Just=. I.e., if we try to add =5= to =Just 3=, we'll get =Just 8= back, as
expected!


