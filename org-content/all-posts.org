#+hugo_base_dir: ../

* DONE Static Site Generation with Hugo                          :emacs:@tech:
CLOSED: [2023-06-08 Thu 12:18]
:PROPERTIES:
:EXPORT_FILE_NAME: hugo
:END:
This website is built with [[https://gohugo.io/][Hugo]] and [[https://ox-hugo.scripter.co/][=ox-hugo=]], an exporting engine that lets me
write my posts in [[https://orgmode.org/][Org mode]] and then put it online easily.

Org mode is a really clever and powerful plain text format that works great for note
taking, text editing, and TODO lists/agendas. Moreover, there are a lot of
convenient features for us Emacs users when using =ox-hugo= to write our blogs
(besides staying in the comfort of a well-known format and editing flow).

For example, I can use this code snippet from [[https://ox-hugo.scripter.co/doc/org-capture-setup/][ox-hugo's blog]] as a template to
create a new blog post and bind it to a key combination in my Emacs configuration:

#+begin_src elisp
(with-eval-after-load 'org-capture
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
    (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title)
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (add-to-list 'org-capture-templates
               '("h"                ;`org-capture' binding + h
                 "Hugo post"
                 entry
                 (file "~/path/to/your/all-posts.org")
                 (function org-hugo-new-subtree-post-capture-template))))
#+end_src

* TODO Monads in Haskell                                         :blog:@tech:
:PROPERTIES:
:EXPORT_FILE_NAME: monads-haskell
:END:
*Please note:* This is a test "post" to see how different formatting in
Org+Hugo works, it's not a proper or finished post :~)

Monads are a special kind of mathematical structure that make our lives as
functional programmers much easier. They allow us to do /stateful/ computations
in a /functional/ way.

You're bound to have seen a monad if you've ever used Haskell, since the main
function usually has the signature =IO ()=. And so does every other function
you'll use that just prints or reads something to/from the console.

But what exactly is a monad? That question has been posed to Google by many
a beginner to functional programming. Usually, the results will include the
formal definition: "A monoid in the category of endofunctors." Which doesn't
really help the average person much.

Personally, I had the most luck starting with /how/ to use monads in functional
programming, and as I got better at using them, I would re-read the definitions
and slowly feel like I started to understand them.

To have a something to re-read and hopefully understand later, let's look at some definitions and introduce some terminology:

#+begin_center
Every *monad* is an *applicative functor*, and every applicative functor is a
normal *functor*.
#+end_center

Let's start at the lowest level, *functors*, and work our way up.

** Functors

To understand functors, it's useful to have a look at a simple function in Haskell. How about
addition?

The built-in function is the infix =+= operator, but to be clear, let's define
our own =add= function:

#+begin_src haskell
add :: Num a => a -> a -> a
add x y = x + y
#+end_src

Now I think we're ready to look at our first functor, =Maybe=. If you've worked with
Haskell before, you might already be familiar with how it works.

Essentially, it allows you to return =Nothing= for a computation that for some
reason has no return, and otherwise wrap a real result in =Just=. This is
really useful if we want to deal with functions that /may/ fail. In that case,
we can return =Nothing= when it fails and =Just result= if it succeeds.

=Maybe= is a /type constructor/, meaning it's not a type in and of itself, but
you can pass it a real, concrete type to construct a new type. If we try to
check the type of =Maybe=, we therefore get an error:

#+begin_src haskell
ghci> :t Maybe

<interactive>:1:1: error:
    * Illegal term-level use of the type constructor `Maybe'
        imported from `Prelude' (and originally defined in `GHC.Maybe')
    * In the expression: Maybe
#+end_src

On the other hand, we can check its /kind/:

#+begin_src haskell
ghci> :k Maybe
Maybe :: * -> *
#+end_src

This indicates how we can use it. It takes exactly one concrete type, like
=String= or =Int=, and returns a concrete type, like =Maybe String= or =Maybe
Int=.

An instance of the type =Maybe Int= could be for example =Just 3= or =Nothing=.
Notice that in =Just 3=, the normal integer =3= is "wrapped" inside of the
=Just=. What this means, is that we can't use =Just 3= exactly like we would
use =3=.

Let's define our =add= function and try to use it on normal ints, and then on
some =Maybe= ints.

#+begin_src haskell
ghci> add x y = x + y
ghci> add 3 5
8
ghci> add 5 (Just 3)

<interactive>:5:1: error:
    * No instance for (Num (Maybe Integer)) arising from a use of `it'
    * In the first argument of `print', namely `it'
      In a stmt of an interactive GHCi command: print it
#+end_src

To use a value that has been wrapped, or "lifted", by a functor, we need to use
a special function called =fmap=. This is how the Functor typeclass is defined
in Haskell:

#+begin_src haskell
class Functor f where
	fmap :: (a -> b) -> f a -> f b
#+end_src

Basically, it says "give me a normal function and a wrapped value, and I'll
unwrap the value, apply the function, and wrap up the result again".

What should happen with our =Maybe Int= then, is that we can give it a normal
function (like =add 5=) and a wrapped value (like =Just 3=) and it should
perform the computation as we would expect (=add 5 3=) and wrap up the result
for us (=Just 8=).

#+begin_comment
Note that =add 5= is a /partially applied function/. Since =add= takes two arguments,
giving it only one argument, like =add 5=, results in a partially applied
function that has "already gotten one of its arguments". In other words, =add 5= is a function that accepts one number and
adds 5 to it.
#+end_comment

#+begin_src haskell
ghci> fmap (add 5) (Just 3)
Just 8
#+end_src

Wow, great! Now we know how to apply a function to a wrapped value.

Now that we have seen =fmap= in action, I think we're ready to see how the =Maybe=-instance of =Functor= is defined:

#+begin_src haskell
instance Functor Maybe where
	fmap f Nothing  = Nothing
	fmap f (Just x) = Just (f x)
#+end_src

This means that if we try to apply the normal function =f= to =Nothing=, then
the result is always just =Nothing=. I.e., if we try to add =5= to =Nothing=, we
actually get =Nothing= back. That's because =Nothing= is not equivalent to 0, but rather
to some computation having failed earlier. For example, if we tried to divide
by zero earlier and got =Nothing= as a result, it doesn't really make sense to
add 5 to it and expect an actual result.

But if we try to apply the normal function =f= to =Just x= where =f= is defined
for the type of =x=, then we should apply =f= to =x= and wrap up the result in
a =Just=. I.e., if we try to add =5= to =Just 3=, we'll get =Just 8= back, as
expected!

* DONE Beautifying Emacs Org Mode              :emacs:@tech:
  CLOSED: [2023-08-10 Thu 22:19]
:PROPERTIES:
:EXPORT_FILE_NAME: beautifying-emacs-org-mode
:END:

In my opinion, the power of Emacs is that you're able to program your own
working environment. Other editors may be just as, or possibly more, efficient
to use, but I haven't come across any that give you control over as many aspects
of your editor as Emacs does. Customising and tweaking your configuration may be an
endless endeavour, but it's also a highly rewarding one.

All that being said, I was inspired to tweak the look of my Org Mode setup,
especially after reading [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][this post]]. Below you can find screenshots and code. I
hope there's something in here that you might want to steal for your own config!
In case I change these settings later, my most recently updated config is always
available on my [[https://github.com/SophieBosio/.emacs.d][GitHub]].

[[file:/images/init-org-screenshot.png][file:/images/init-org-screenshot.png]]

** Theme

The easiest and quickest way to change the look of vanilla Emacs is to load a
colour theme. I'm using the =doom-nord= theme, which is part of the [[https://github.com/doomemacs/themes][=doom-themes=]]
package. I find both it and several of the other themes from that pack to be
excellent.

You can find an updated list of themes on [[https://emacsthemes.com/][emacsthemes.com]] where they
have screenshots. From spending time on the Emacs subreddit, I also know that
people are very fond of Prot's [[https://github.com/protesilaos/modus-themes][Modus]] and [[https://github.com/protesilaos/ef-themes][Ef themes]], as well as the built-in
=leuven= theme. Feel free to play around!

** Fonts

Next up is setting up variable-pitch and fixed-pitch fonts. I love Roboto Mono
and I use a ligaturised version of it for programming, from the
[[https://github.com/lemeb/a-better-ligaturizer][a-better-ligaturizer project]]. Here, I'll add that a package such as =ligature.el=
is required to display the ligatures.

I also think the regular version of Roboto is fine
for normal text. For the headers etc. I want to use [[https://fonts.adobe.com/fonts/source-sans][Source Sans Pro]].

In the regular part of my Emacs config, I set these fonts.

#+begin_src emacs-lisp
(when (member "Roboto Mono" (font-family-list))
  (set-face-attribute 'default nil :font "Roboto Mono" :height 108)
  (set-face-attribute 'fixed-pitch nil :family "Roboto Mono"))

(when (member "Source Sans 3" (font-family-list))
  (set-face-attribute 'variable-pitch nil :family "Source Sans Pro" :height 1.8))
#+end_src

Then, in the Org-specific part, I resize the Org headings and choose Source Sans
Pro to be the header font.

#+begin_src emacs-lisp
;; Resize Org headings
(dolist (face '((org-level-1 . 1.4)
                (org-level-2 . 1.35)
                (org-level-3 . 1.3)
                (org-level-4 . 1.2)
                (org-level-5 . 1.2)
                (org-level-6 . 1.2)
                (org-level-7 . 1.2)
                (org-level-8 . 1.2)))
  (set-face-attribute (car face) nil :font "Source Sans Pro" :weight 'bold :height (cdr face)))

;; Make the document title a bit bigger
(set-face-attribute 'org-document-title nil :font "Source Sans Pro" :weight
'bold :height 1.8)
#+end_src

In order to avoid line spacing issues when a line of text contains both
variable- and fixed-pitch text, we need to make sure that the =org-indent= face
inherits from =fixed-pitch=.

#+begin_src emacs-lisp
(org-indent ((t (:inherit (org-hide fixed-pitch)))))
#+end_src

And then, we want to make sure that some parts of the Org document
always use fixed-pitch even when =variable-pitch-mode= is on.

#+begin_src emacs-lisp
(set-face-attribute 'org-block nil           :foreground nil :inherit 'fixed-pitch)
(set-face-attribute 'org-table nil           :inherit 'fixed-pitch)
(set-face-attribute 'org-formula nil         :inherit 'fixed-pitch)
(set-face-attribute 'org-code nil            :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-verbatim nil        :inherit '(shadow fixed-pitch))
(set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-meta-line nil       :inherit '(font-lock-comment-face fixed-pitch))
(set-face-attribute 'org-checkbox nil        :inherit 'fixed-pitch)
#+end_src

For this all to come together, we need to make sure that  =variable-pitch-mode= is always active in Org buffers.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

Also, if you're having troubles with the size of LaTeX-previews like I did, you
can increase the size like so.

#+begin_src emacs-lisp
(plist-put org-format-latex-options :scale 2)
#+end_src

** Decluttering

We'll declutter by hiding leading starts in headings and emphasis markers (e.g.,
the slashes in  =/.../= ). We'll also use [[https://orgmode.org/manual/Special-Symbols.html]["pretty entities"]], which allow us to
insert special characters LaTeX-style by using a leading backslash (e.g., =\alpha= to
write the greek letter alpha) and display ellipses in a condensed way.

#+begin_src emacs-lisp
(setq org-adapt-indentation t
      org-hide-leading-stars t
      org-hide-emphasis-markers t
      org-pretty-entities t
	  org-ellipsis "…")
#+end_src

For source code blocks specifically, I want Org to display the contents using
the major mode of the relevant language. I also want TAB to behave inside the
source code block like it normally would when writing code in that language.

#+begin_src emacs-lisp
(setq org-src-fontify-natively t
	  org-src-tab-acts-natively t
      org-edit-src-content-indentation 0)
#+end_src

** Centring and Line Breaks

I want the text to fill the screen adaptively, so that long lines of text adapt
to the size of the window. It also breaks lines instead of truncating them.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

I prefer having my Org buffer centred. I think it looks prettier when I only
have one buffer open, and it's barely noticeable when several are open because
the width of the margins adapt. For this, I use [[https://github.com/rnkn/olivetti][Olivetti]], which I think is a
great package for this purpose.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'olivetti-mode)
#+end_src

** Prettier UI Elements

The packages[[https://github.com/sabof/org-bullets][=org-bullets=]]and[[https://github.com/integral-dw/org-superstar-mode][=org-superstar=]] are both great for displaying UTF-8
bullets instead of the normal asterisks of your headings, but I stopped using
them because the package [[https://github.com/minad/org-modern][=org-modern=]] does that and so much more. For example,
this is the package that gives me such pretty source code blocks. Here's my
(relatively minimal) setup for it.

#+begin_src emacs-lisp
(use-package org-modern
  :config
  (setq
   org-auto-align-tags nil
   org-tags-column 0
   org-fold-catch-invisible-edits 'show-and-error
   org-special-ctrl-a/e t
   org-insert-heading-respect-content t

   ;; Agenda styling
   org-agenda-tags-column 0
   org-agenda-block-separator ?─
   org-agenda-time-grid
   '((daily today require-timed)
	 (800 1000 1200 1400 1600 1800 2000)
	 " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
   org-agenda-current-time-string
   "⭠ now ─────────────────────────────────────────────────")

  (global-org-modern-mode))
#+end_src

** Conclusion

There it is, that's pretty much all of the visual Org-specific code in my
config. If you're interested in other aspects of my config, you're of course
welcome to [[https://github.com/SophieBosio/.emacs.d][check it out]]. I'm just starting out, so I'd also really appreciate constructive criticism or tips!
